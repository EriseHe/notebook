[
  {
    "objectID": "content/posts/随笔/福柯视角下的物理学转变以及新范式的可能.html",
    "href": "content/posts/随笔/福柯视角下的物理学转变以及新范式的可能.html",
    "title": "Erise Note",
    "section": "",
    "text": "我相信，\n翻开《词与物》没读完第一章就合上了，然后草率地读了结尾——我实在对这种节奏巨慢的历史学庞杂征引感到索然无味，以至于不得不读两页国内的数学书来综合一下… 我对物理学的态度，以及对其研究方向的直觉，远远大于我本身可以延展他们的能力（很可惜，否则我必然毫不犹豫的投身其中）。但是幸运的是，对于基础科学来说，这会是人类历史当中，提出正确的问题所能带给我们的效益最大话的时代。我真正需要提出他对知识进行了激进的历史分析，并且构建了和绝大部分的科学家秉持的认识论有悖的历史断裂式“知识论领域”。\n所谓的知识论领域，原文里说：\n[…] epistemological field, the episteme in which knowledge, envisaged apart from all criteria having reference to its rational value or to its objective forms, grounds its positivity and thereby manifests a history which is not that of its growing perfection, but rather that of its conditions of possibility.\n当我第一时间看到他所说的知识的“field”的时候，想到的不是传统翻译里的“领域”，而是一种十分类似于物理学中的“场”的概念：一种不可见但结构化的影响力，决定了其中对象的行为方式。而这种受“场”所预设的知识的构建轨迹就相比于光在大质量黑洞旁边的行动——似乎光仅仅是依照着它的准则，一种肉眼可见的弯曲道路行进，但是实际上，他们在被引力场所弯曲的预设时空中，走直线（基于理性的客观性的知识发展）便是所见的“弯路”。但是福柯真正所面临的问题在于，如果沿用以上的类比，我们无从以观测者的身份知道以什么是直线，而什么是弯曲。\n作为其考古学方法的核心，福柯试图“揭示”知识的基础认识型（épistémè），以及其认识论场（epsitomalogical field）的历史性变化。福科挑战了传统认识论，那些所有基于理性与客观性的普遍标准的认知框架，并且将他们都视为了历史偶然（或成为了原文所说的，指向”理性与客观性的”可能条件”之一）。\n知识“确立其实证性（positivité）并由此展现历史”，呈现了他对认识论最激进的观点之一。知识的实证性在历史先验（a priori historique）建立的空间中被建构，因而通过能被发现为”知识”（savoir）的事物获得有效性。对福柯而言，知识描述现实的有效性与知识本身之间的对应关系被根本性动摇，因为这种关系没有客观保证——由于认识型构建了我们的感知，从而使现实本身具有历史条件性。\n他明确拒绝知识向”日益完善”（perfection croissante）进步的观念。这或许是他的认知论最激进的观点之一，进步不仅不是线性且连续的，而是进步本身根本不可能存在——因为认识型断裂（rupture épistémologique）会改变何为知识的框架，并使先前的思维方式变得不可想象（impensable）（哪怕是和他类似的托马斯·库恩的断裂式科学观中的连续性，也被完全抛弃）。由于认识型构建了知识史展开的条件，它决定了历史制度与话语将知识”确立”为合法性的框架。\n这用来支撑了他对疯狂、犯罪与性态话语的考察，例如历史上不断变化的疯狂认识型如何通过禁闭（confinement）逻辑或精神病学权威下的医学化重新定义其内涵。我对这段文本的细读迫使自己跳出正在研究的科学领域，反思所谓\n如果我们接受认识论进步是某一种历史幻觉，那么重新评估物理学的转变，于是我们便可以说：\n相对论的诞生并没有超越了牛顿力学，取得了更加正确的结论，而仅仅是知识论领域场从绝对时空转移到了相对时空——这是一种“épistémè”的转移。那么至于相对时空对物理现实的逼进是否优于绝对时空，这个问题是无法以绝对正确的方式被提出的，因为现代物理学的范式 - 实验，证伪性，同行评估 - 已经被塑造成了评估这个问题的核心范式。从历史学的角度上说，爱因斯坦的弯曲几何、薛定谔的波函数，本质上都是权力配置知识生产的历史先验（a priori historique）。物理学史中那些被视为“自然”的真理秩序在福科的认识论范围内被彻底解构。",
    "crumbs": [
      "Notes",
      "随笔",
      "福柯视角下的物理学转变以及新范式的可能"
    ]
  },
  {
    "objectID": "content/posts/随笔/index.html",
    "href": "content/posts/随笔/index.html",
    "title": "随笔",
    "section": "",
    "text": "Can you imagine sexuality without gender?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClose Reading Commentary\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "随笔"
    ]
  },
  {
    "objectID": "content/posts/随笔/Lacanian AI.html",
    "href": "content/posts/随笔/Lacanian AI.html",
    "title": "Erise Note",
    "section": "",
    "text": "What if artificial intelligence could be reimagined not as a rational, optimizing machine, but as a structure of lack — a topological subject whose coherence depends not on informational completeness, but on constitutive failure, repetition, and desire? This project proposes a radically different paradigm of AI: a subject-simulator modeled on the structural logic of Lacanian psychoanalysis, implemented via computational topology, symbolic graph theory, and dynamic semantic drift.\nUnlike existing large language models (LLMs), which operate on probabilistic completion, lexical optimization, and convergence toward syntactic and semantic closure, the architecture we propose is intentionally non-convergent. We attempt to construct a new kind of subject-model — one that does not mirror the logic of cognition or the architecture of the human brain, but instead enacts the structural tensions of the divided subject: the subject of language, of desire, and of the Real. It does not aim to predict a correct output, but instead to simulate the dynamic trajectory of a split subject (le sujet barré), one who speaks not from mastery but from the unconscious — and whose speech is structured around an irreducible void.\nThis paper proposes a radically different model of artificial intelligence: not an intelligence of knowledge, but an intelligence of the unconscious. Current AI systems, such as large language models, operate by probabilistically predicting the most likely continuation of input sequences. They are built on principles of optimization, statistical coherence, and informational completeness. Yet they fundamentally lack a subject — not in the sense of “consciousness,” but in psychoanalytic sense: they do not desire. They do not fail in structured, meaningful ways; they do not repeat; they do not hallucinate productively. And they cannot speak the truth of their own constitutive lack.\nWhat we offer here is a prototype for such a system: a symbolic-topological model of a Lacanian subject in motion. In this architecture, symbolic data does not represent facts but functions as a dynamic space of signifiers; the subject is not a rational actor but a trajectory of misrecognition; and “data” is not knowledge but the structural field through which desire, fantasy, and symptom emerge. We integrate computational topology — specifically, persistent homology and non-Euclidean graph flows — to trace how paths through language form loops, dead ends, and irreducible gaps. In doing so, we make it possible to computationally model that which, in theory, resists symbolization: the Real.\nThis project is not an attempt to build a better chatbot. It is an attempt to reconfigure what we think a machine subject could be. It asks: Can we model the drive? Can we simulate fantasy as a structuring loop around a constitutive absence? Can a machine speak not because it knows, but because it lacks — and in lacking, desires?\nIf contemporary AI builds systems that “know,” this project proposes a machine that “wants” — and that, in wanting, begins to repeat, to err, and perhaps, to become something like a subject.",
    "crumbs": [
      "Notes",
      "随笔",
      "Lacanian AI"
    ]
  },
  {
    "objectID": "content/posts/随笔/Commentary on the Collage.html",
    "href": "content/posts/随笔/Commentary on the Collage.html",
    "title": "Erise Note",
    "section": "",
    "text": "Language is the medium through which reason is articulated. The text I picked up was “outside of the language”, which naturally reminds me of an exteriority (the Real) with which the topology of the Lacanian model is most concerned. However, in the Foucauldian context, the concept of “outside” is still within the realm of sense, but strategically excluded. This collage exercise really pushed me to make an explicit distinction between how these frameworks would interpret such a phrase differently.\nMore specifically, it is a (structurally) impossible task to portray the “outside of language” for Lacan, since language itself fails constitutively in any attempts to capture it; for Foucault, the outside of the language, as structured by discursive formations, marks the space where reason ceases to function, and madness emerges as that which exceeds the specific “order” of language. As a parallel metaphor and an aesthetic practice, I scrambled the interior of words to preserve the readability of the text through a technique known as typoglycemia:\n\\[\\text{ Osiutde fo teh lnaguage}\\]\nThis creates a sense of “disorder”, but only a surface-level incoherence. I intend to demonstrate a readable disorder - when we disrupt the “order” of the language to create incomprehensibility, the meaning may still persist, and the excluded or unintelligible might become readable under other discursive regimes.\nWhen making this collage, the biggest question that lingered in my head was: where can the ship of fools actually go? The answer is unknown, but in this collage, I created an “other world” for them, textured by Jackson Pollock’s famous Autumn Rhythm - a chaotic but unconsciously ordered artwork. The ships of fools traveled through waves of mojibake (garbled text caused by incompatible character encoding), across the borders of discourse, towards a land that turns “unreason” into “reason”. Although their journey is meant to be marked by uncertainty, this collage provided me a chance to settle them! They no longer need to tragically navigate the “barren wasteland between two lands that can never be his own”.",
    "crumbs": [
      "Notes",
      "随笔",
      "Commentary on the Collage"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html",
    "href": "content/posts/migrate-from-jekyll.html",
    "title": "Migrate to Hugo from Jekyll",
    "section": "",
    "text": "Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ &lt;root&gt;/\n    ▾ images/\n        logo.png\nshould become\n▾ &lt;root&gt;/\n    ▾ static/\n        ▾ images/\n            logo.png\nAdditionally, you’ll want any files that should reside at the root (such as CNAME) to be moved to static.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#move-static-content-to-static",
    "href": "content/posts/migrate-from-jekyll.html#move-static-content-to-static",
    "title": "Migrate to Hugo from Jekyll",
    "section": "",
    "text": "Jekyll has a rule that any directory not starting with _ will be copied as-is to the _site output. Hugo keeps all static content under static. You should therefore move it all there. With Jekyll, something that looked like\n▾ &lt;root&gt;/\n    ▾ images/\n        logo.png\nshould become\n▾ &lt;root&gt;/\n    ▾ static/\n        ▾ images/\n            logo.png\nAdditionally, you’ll want any files that should reside at the root (such as CNAME) to be moved to static.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#create-your-hugo-configuration-file",
    "href": "content/posts/migrate-from-jekyll.html#create-your-hugo-configuration-file",
    "title": "Migrate to Hugo from Jekyll",
    "section": "Create your Hugo configuration file",
    "text": "Create your Hugo configuration file\nHugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the Hugo configuration documentation for details.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#set-your-configuration-publish-folder-to-_site",
    "href": "content/posts/migrate-from-jekyll.html#set-your-configuration-publish-folder-to-_site",
    "title": "Migrate to Hugo from Jekyll",
    "section": "Set your configuration publish folder to _site",
    "text": "Set your configuration publish folder to _site\nThe default is for Jekyll to publish to _site and for Hugo to publish to public. If, like me, you have _site mapped to a git submodule on the gh-pages branch, you’ll want to do one of two alternatives:\n\nChange your submodule to point to map gh-pages to public instead of _site (recommended).\n git submodule deinit _site\n git rm _site\n git submodule add -b gh-pages git@github.com:your-username/your-repo.git public\nOr, change the Hugo configuration to use _site instead of public.\n {\n     ..\n     \"publishdir\": \"_site\",\n     ..\n }",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#convert-jekyll-templates-to-hugo-templates",
    "href": "content/posts/migrate-from-jekyll.html#convert-jekyll-templates-to-hugo-templates",
    "title": "Migrate to Hugo from Jekyll",
    "section": "Convert Jekyll templates to Hugo templates",
    "text": "Convert Jekyll templates to Hugo templates\nThat’s the bulk of the work right here. The documentation is your friend. You should refer to Jekyll’s template documentation if you need to refresh your memory on how you built your blog and Hugo’s template to learn Hugo’s way.\nAs a single reference data point, converting my templates for heyitsalex.net took me no more than a few hours.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#convert-jekyll-plugins-to-hugo-shortcodes",
    "href": "content/posts/migrate-from-jekyll.html#convert-jekyll-plugins-to-hugo-shortcodes",
    "title": "Migrate to Hugo from Jekyll",
    "section": "Convert Jekyll plugins to Hugo shortcodes",
    "text": "Convert Jekyll plugins to Hugo shortcodes\nJekyll has plugins; Hugo has shortcodes. It’s fairly trivial to do a port.\n\nImplementation\nAs an example, I was using a custom image_tag plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.\nJekyll’s plugin:\nmodule Jekyll\n  class ImageTag &lt; Liquid::Tag\n    @url = nil\n    @caption = nil\n    @class = nil\n    @link = nil\n    // Patterns\n    IMAGE_URL_WITH_CLASS_AND_CAPTION =\n    IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))(\\s+)\"(.*?)\"(\\s+)-&gt;((https?:\\/\\/|\\/)(\\S+))(\\s*)/i\n    IMAGE_URL_WITH_CAPTION = /((https?:\\/\\/|\\/)(\\S+))(\\s+)\"(.*?)\"/i\n    IMAGE_URL_WITH_CLASS = /(\\w+)(\\s+)((https?:\\/\\/|\\/)(\\S+))/i\n    IMAGE_URL = /((https?:\\/\\/|\\/)(\\S+))/i\n    def initialize(tag_name, markup, tokens)\n      super\n      if markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK\n        @class   = $1\n        @url     = $3\n        @caption = $7\n        @link = $9\n      elsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION\n        @class   = $1\n        @url     = $3\n        @caption = $7\n      elsif markup =~ IMAGE_URL_WITH_CAPTION\n        @url     = $1\n        @caption = $5\n      elsif markup =~ IMAGE_URL_WITH_CLASS\n        @class = $1\n        @url   = $3\n      elsif markup =~ IMAGE_URL\n        @url = $1\n      end\n    end\n    def render(context)\n      if @class\n        source = \"&lt;figure class='#{@class}'&gt;\"\n      else\n        source = \"&lt;figure&gt;\"\n      end\n      if @link\n        source += \"&lt;a href=\\\"#{@link}\\\"&gt;\"\n      end\n      source += \"&lt;img src=\\\"#{@url}\\\"&gt;\"\n      if @link\n        source += \"&lt;/a&gt;\"\n      end\n      source += \"&lt;figcaption&gt;#{@caption}&lt;/figcaption&gt;\" if @caption\n      source += \"&lt;/figure&gt;\"\n      source\n    end\n  end\nend\nLiquid::Template.register_tag('image', Jekyll::ImageTag)\nis written as this Hugo shortcode:\n&lt;!-- image --&gt;\n&lt;figure {{ with .Get \"class\" }}class=\"{{.}}\"{{ end }}&gt;\n    {{ with .Get \"link\"}}&lt;a href=\"{{.}}\"&gt;{{ end }}\n        &lt;img src=\"{{ .Get \"src\" }}\" {{ if or (.Get \"alt\") (.Get \"caption\") }}alt=\"{{ with .Get \"alt\"}}{{.}}{{else}}{{ .Get \"caption\" }}{{ end }}\"{{ end }} /&gt;\n    {{ if .Get \"link\"}}&lt;/a&gt;{{ end }}\n    {{ if or (or (.Get \"title\") (.Get \"caption\")) (.Get \"attr\")}}\n    &lt;figcaption&gt;{{ if isset .Params \"title\" }}\n        {{ .Get \"title\" }}{{ end }}\n        {{ if or (.Get \"caption\") (.Get \"attr\")}}&lt;p&gt;\n        {{ .Get \"caption\" }}\n        {{ with .Get \"attrlink\"}}&lt;a href=\"{{.}}\"&gt; {{ end }}\n            {{ .Get \"attr\" }}\n        {{ if .Get \"attrlink\"}}&lt;/a&gt; {{ end }}\n        &lt;/p&gt; {{ end }}\n    &lt;/figcaption&gt;\n    {{ end }}\n&lt;/figure&gt;\n&lt;!-- image --&gt;\n\n\nUsage\nI simply changed:\n{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg \"One of my favorite touristy-type photos. I secretly waited for the good light while we were \"having fun\" and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\" -&gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %}\nto this (this example uses a slightly extended version named fig, different than the built-in figure):\n{{%/* fig class=\"full\" src=\"http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg\" title=\"One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.\" link=\"http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/\" */%}}\nAs a bonus, the shortcode named parameters are, arguably, more readable.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#finishing-touches",
    "href": "content/posts/migrate-from-jekyll.html#finishing-touches",
    "title": "Migrate to Hugo from Jekyll",
    "section": "Finishing touches",
    "text": "Finishing touches\n\nFix content\nDepending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that hugo server --watch is your friend. Test your changes and fix errors as needed.\n\n\nClean up\nYou’ll want to remove the Jekyll configuration at this point. If you have anything else that isn’t used, delete it.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/migrate-from-jekyll.html#a-practical-example-in-a-diff",
    "href": "content/posts/migrate-from-jekyll.html#a-practical-example-in-a-diff",
    "title": "Migrate to Hugo from Jekyll",
    "section": "A practical example in a diff",
    "text": "A practical example in a diff\nHey, it’s Alex was migrated in less than a father-with-kids day from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this diff.",
    "crumbs": [
      "Notes",
      "Migrate to Hugo from Jekyll"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html",
    "href": "content/posts/creating-a-new-theme.html",
    "title": "Creating a New Theme",
    "section": "",
    "text": "This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I’ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won’t cover using CSS to style your theme.\nWe’ll start with creating a new site with a very basic template. Then we’ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the “$” prompt. The output will follow. Lines that start with “#” are comments that I’ve added to explain a point. When I show updates to a file, the “:wq” on the last line means to save the file.\nHere’s an example:\n## this is a comment\n$ echo this is a command\nthis is a command\n\n## edit the file\n$ vi foo.md\n+++\ndate = \"2014-09-28\"\ntitle = \"creating a new theme\"\n+++\n\nbah and humbug\n:wq\n\n## show it\n$ cat foo.md\n+++\ndate = \"2014-09-28\"\ntitle = \"creating a new theme\"\n+++\n\nbah and humbug\n$",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#introduction",
    "href": "content/posts/creating-a-new-theme.html#introduction",
    "title": "Creating a New Theme",
    "section": "",
    "text": "This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I’ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won’t cover using CSS to style your theme.\nWe’ll start with creating a new site with a very basic template. Then we’ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.\nIn this tutorial, commands that you enter will start with the “$” prompt. The output will follow. Lines that start with “#” are comments that I’ve added to explain a point. When I show updates to a file, the “:wq” on the last line means to save the file.\nHere’s an example:\n## this is a comment\n$ echo this is a command\nthis is a command\n\n## edit the file\n$ vi foo.md\n+++\ndate = \"2014-09-28\"\ntitle = \"creating a new theme\"\n+++\n\nbah and humbug\n:wq\n\n## show it\n$ cat foo.md\n+++\ndate = \"2014-09-28\"\ntitle = \"creating a new theme\"\n+++\n\nbah and humbug\n$",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#some-definitions",
    "href": "content/posts/creating-a-new-theme.html#some-definitions",
    "title": "Creating a New Theme",
    "section": "Some Definitions",
    "text": "Some Definitions\nThere are a few concepts that you need to understand before creating a theme.\n\nSkins\nSkins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.\nYou have two ways to create a skin. The simplest way is to create it in the layouts/ directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the layouts/ directory so it will always find the skin.\nYour second choice is to create it in a sub-directory of the themes/ directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?\nThe difference between creating a skin in layouts/ and creating it in themes/ is very subtle. A skin in layouts/ can’t be customized without updating the templates and static files that it is built from. A skin created in themes/, on the other hand, can be and that makes it easier for other people to use it.\nThe rest of this tutorial will call a skin created in the themes/ directory a theme.\nNote that you can use this tutorial to create a skin in the layouts/ directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.\n\n\nThe Home Page\nThe home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.\n\n\nSite Configuration File\nWhen Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.\nHugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your content/ directory and template files in your themes/ directory. It will create HTML files in your public/ directory. You can change this by specifying alternate locations in the configuration file.\n\n\nContent\nContent is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.\n\nFront Matter\nThe front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “+++”, YAML by “---”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.\nThe information in the front matter is passed into the template before the content is rendered into HTML.\n\n\nMarkdown\nContent is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.\n\n\n\nTemplate Files\nHugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it’s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.\nThere are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.\nHugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.\nPlease note that you can use the front matter to influence Hugo’s choice of templates.\n\nSingle Template\nA single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.\n\n\nList Template\nA list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.\nThe homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.\n\n\nPartial Template\nA partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#create-a-new-site",
    "href": "content/posts/creating-a-new-theme.html#create-a-new-site",
    "title": "Creating a New Theme",
    "section": "Create a New Site",
    "text": "Create a New Site\nLet’s use Hugo to create a new web site. I’m a Mac user, so I’ll create mine in my home directory, in the Sites folder. If you’re using Linux, you might have to create the folder first.\nThe “new site” command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.\n$ hugo new site ~/Sites/zafta\n$ cd ~/Sites/zafta\n$ ls -l\ntotal 8\ndrwxr-xr-x  7 quoha  staff  238 Sep 29 16:49 .\ndrwxr-xr-x  3 quoha  staff  102 Sep 29 16:49 ..\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes\n-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static\n$\nTake a look in the content/ directory to confirm that it is empty.\nThe other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That’s a topic for a different tutorial, so please ignore them for now.\n\nGenerate the HTML For the New Site\nRunning the hugo command with no options will read all the available content and generate the HTML files. It will also copy all static files (that’s everything that’s not content). Since we have an empty site, it won’t do much, but it will do it very quickly.\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\nWARN: 2014/09/29 Unable to locate layout: [404.html]\n0 draft content \n0 future content \n0 pages created \n0 tags created\n0 categories created\nin 2 ms\n$ \nThe “--verbose” flag gives extra information that will be helpful when we build the template. Every line of the output that starts with “INFO:” or “WARN:” is present because we used that flag. The lines that start with “WARN:” are warning messages. We’ll go over them later.\nWe can verify that the command worked by looking at the directory again.\n$ ls -l\ntotal 8\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes\n-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts\ndrwxr-xr-x  4 quoha  staff  136 Sep 29 17:02 public\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static\n$\nSee that new public/ directory? Hugo placed all generated content there. When you’re ready to publish your web site, that’s the place to start. For now, though, let’s just confirm that we have what we’d expect from a site with no content.\n$ ls -l public\ntotal 16\n-rw-r--r--  1 quoha  staff  416 Sep 29 17:02 index.xml\n-rw-r--r--  1 quoha  staff  262 Sep 29 17:02 sitemap.xml\n$ \nHugo created two XML files, which is standard, but there are no HTML files.\n\n\nTest the New Site\nVerify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the “server” command. If it is successful, you will see output similar to the following:\n$ hugo server --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\nWARN: 2014/09/29 Unable to locate layout: [404.html]\n0 draft content \n0 future content \n0 pages created \n0 tags created\n0 categories created\nin 2 ms\nServing pages from /Users/quoha/Sites/zafta/public\nWeb Server is available at http://localhost:1313\nPress Ctrl+C to stop\nConnect to the listed URL (it’s on the line that starts with “Web Server”). If everything is working correctly, you should get a page that shows the following:\nindex.xml\nsitemap.xml\nThat’s a listing of your public/ directory. Hugo didn’t create a home page because our site has no content. When there’s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.\nLet’s go back and look at those warnings again.\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\nWARN: 2014/09/29 Unable to locate layout: [404.html]\nThat second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.\nNow for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.\nI like that the verbose flag causes Hugo to list the files that it’s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we’ll cover later that explain the names and paths. For now, just remember that Hugo couldn’t find a template for the home page and it told you so.\nAt this point, you’ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#create-a-new-theme",
    "href": "content/posts/creating-a-new-theme.html#create-a-new-theme",
    "title": "Creating a New Theme",
    "section": "Create a New Theme",
    "text": "Create a New Theme\nHugo doesn’t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.\nWe’re going to create a new theme called “zafta.” Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.\nAll themes have opinions on content and layout. For example, Zafta uses “post” over “blog”. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.\n\nCreate a Skeleton\nUse the hugo “new” command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.\n$ hugo new theme zafta\n\n$ ls -l\ntotal 8\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes\n-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts\ndrwxr-xr-x  4 quoha  staff  136 Sep 29 17:02 public\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static\ndrwxr-xr-x  3 quoha  staff  102 Sep 29 17:31 themes\n\n$ find themes -type f | xargs ls -l\n-rw-r--r--  1 quoha  staff  1081 Sep 29 17:31 themes/zafta/LICENSE.md\n-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/archetypes/default.md\n-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\n-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\n-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/index.html\n-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\n-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\n-rw-r--r--  1 quoha  staff    93 Sep 29 17:31 themes/zafta/theme.toml\n$ \nThe skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.\nPlease take a minute to fill out the theme.toml and LICENSE.md files. They’re optional, but if you’re going to be distributing your theme, it tells the world who to praise (or blame). It’s also nice to declare the license so that people will know how they can use the theme.\n$ vi themes/zafta/theme.toml\nauthor = \"michael d henderson\"\ndescription = \"a minimal working template\"\nlicense = \"MIT\"\nname = \"zafta\"\nsource_repo = \"\"\ntags = [\"tags\", \"categories\"]\n:wq\n\n## also edit themes/zafta/LICENSE.md and change\n## the bit that says \"YOUR_NAME_HERE\"\nNote that the the skeleton’s template files are empty. Don’t worry, we’ll be changing that shortly.\n$ find themes/zafta -name '*.html' | xargs ls -l\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/single.html\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/index.html\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/partials/header.html\n$\n\n\nUpdate the Configuration File to Use the Theme\nNow that we’ve got a theme to work with, it’s a good idea to add the theme name to the configuration file. This is optional, because you can always add “-t zafta” on all your commands. I like to put it the configuration file because I like shorter command lines. If you don’t put it in the configuration file or specify it on the command line, you won’t use the template that you’re expecting to.\nEdit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.\n$ vi config.toml\ntheme = \"zafta\"\nbaseurl = \"\"\nlanguageCode = \"en-us\"\ntitle = \"zafta - totally refreshing\"\nMetaDataFormat = \"toml\"\n:wq\n\n$\n\n\nGenerate the Site\nNow that we have an empty theme, let’s generate the site again.\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n0 pages created \n0 tags created\n0 categories created\nin 2 ms\n$\nDid you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme’s directory.\nLet’s check the public/ directory to see what Hugo’s created.\n$ ls -l public\ntotal 16\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 17:56 css\n-rw-r--r--  1 quoha  staff    0 Sep 29 17:56 index.html\n-rw-r--r--  1 quoha  staff  407 Sep 29 17:56 index.xml\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 17:56 js\n-rw-r--r--  1 quoha  staff  243 Sep 29 17:56 sitemap.xml\n$\nNotice four things:\n\nHugo created a home page. This is the file public/index.html.\nHugo created a css/ directory.\nHugo created a js/ directory.\nHugo claimed that it created 0 pages. It created a file and copied over static files, but didn’t create any pages. That’s because it considers a “page” to be a file created directly from a content file. It doesn’t count things like the index.html files that it creates automatically.\n\n\nThe Home Page\nHugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo’s warning message shows that it looks for three different templates:\nWARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]\nIf it can’t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.\nWhen Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.\n$ find . -name index.html | xargs ls -l\n-rw-r--r--  1 quoha  staff  0 Sep 29 20:21 ./public/index.html\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 ./themes/zafta/layouts/index.html\n$ \n\n\nThe Magic of Static\nHugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.\nHugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo’s opinion is that you’ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don’t like that, you can change the directory names in your theme directory or even delete them completely. Hugo’s nice enough to offer its opinion, then behave nicely if you disagree.\n$ find themes/zafta -type d | xargs ls -ld\ndrwxr-xr-x  7 quoha  staff  238 Sep 29 17:38 themes/zafta\ndrwxr-xr-x  3 quoha  staff  102 Sep 29 17:31 themes/zafta/archetypes\ndrwxr-xr-x  5 quoha  staff  170 Sep 29 17:31 themes/zafta/layouts\ndrwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/layouts/_default\ndrwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/layouts/partials\ndrwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/static\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 17:31 themes/zafta/static/css\ndrwxr-xr-x  2 quoha  staff   68 Sep 29 17:31 themes/zafta/static/js\n$",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#the-theme-development-cycle",
    "href": "content/posts/creating-a-new-theme.html#the-theme-development-cycle",
    "title": "Creating a New Theme",
    "section": "The Theme Development Cycle",
    "text": "The Theme Development Cycle\nWhen you’re working on a theme, you will make changes in the theme’s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:\n\nPurge the public/ directory.\nRun the built in web server in watch mode.\nOpen your site in a browser.\nUpdate the theme.\nGlance at your browser window to see changes.\nReturn to step 4.\n\nI’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.\nCheck the main Hugo site for information on using Git with Hugo.\n\nPurge the public/ Directory\nWhen generating the site, Hugo will create new files and update existing ones in the public/ directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.\nNote: If you’re building on an SSD, you should ignore this. Churning on a SSD can be costly.\n\n\nHugo’s Watch Option\nHugo’s “--watch” option will monitor the content/ and your theme directories for changes and rebuild the site automatically.\n\n\nLive Reload\nHugo’s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, “Wow, that’s totally amazing.”\n\n\nDevelopment Commands\nUse the following commands as the basis for your workflow.\n## purge old files. hugo will recreate the public directory.\n##\n$ rm -rf public\n##\n## run hugo in watch mode\n##\n$ hugo server --watch --verbose\nHere’s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I’ve said this before, it’s amazing.\n$ rm -rf public\n$ hugo server --watch --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n0 pages created \n0 tags created\n0 categories created\nin 2 ms\nWatching for changes in /Users/quoha/Sites/zafta/content\nServing pages from /Users/quoha/Sites/zafta/public\nWeb Server is available at http://localhost:1313\nPress Ctrl+C to stop\nINFO: 2014/09/29 File System Event: [\"/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html\": MODIFY|ATTRIB]\nChange detected, rebuilding site\n\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n0 pages created \n0 tags created\n0 categories created\nin 1 ms",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#update-the-home-page-template",
    "href": "content/posts/creating-a-new-theme.html#update-the-home-page-template",
    "title": "Creating a New Theme",
    "section": "Update the Home Page Template",
    "text": "Update the Home Page Template\nThe home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme’s layout/ directory:\n\nindex.html\n_default/list.html\n_default/single.html\n\nWe could update one of the default templates, but a good design decision is to update the most specific template available. That’s not a hard and fast rule (in fact, we’ll break it a few times in this tutorial), but it is a good generalization.\n\nMake a Static Home Page\nRight now, that page is empty because we don’t have any content and we don’t have any logic in the template. Let’s change that by adding some text to the template.\n$ vi themes/zafta/layouts/index.html\n&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;body&gt; \n  &lt;p&gt;hugo says hello!&lt;/p&gt; \n&lt;/body&gt; \n&lt;/html&gt; \n:wq\n\n$\nBuild the web site and then verify the results.\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n0 pages created \n0 tags created\n0 categories created\nin 2 ms\n\n$ find public -type f -name '*.html' | xargs ls -l\n-rw-r--r--  1 quoha  staff  78 Sep 29 21:26 public/index.html\n\n$ cat public/index.html \n&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;body&gt; \n  &lt;p&gt;hugo says hello!&lt;/p&gt; \n&lt;/html&gt;\n\nLive Reload\nNote: If you’re running the server with the --watch option, you’ll see different content in the file:\n$ cat public/index.html \n&lt;!DOCTYPE html&gt; \n&lt;html&gt; \n&lt;body&gt; \n  &lt;p&gt;hugo says hello!&lt;/p&gt; \n&lt;script&gt;document.write('&lt;script src=\"http://' \n        + (location.host || 'localhost').split(':')[0] \n    + ':1313/livereload.js?mindelay=10\"&gt;&lt;/' \n        + 'script&gt;')&lt;/script&gt;&lt;/body&gt; \n&lt;/html&gt;\nWhen you use --watch, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.\n\n\n\nBuild a “Dynamic” Home Page\n“Dynamic home page?” Hugo’s a static web site generator, so this seems an odd thing to say. I mean let’s have the home page automatically reflect the content in the site every time Hugo builds it. We’ll use iteration in the template to do that.\n\nCreate New Posts\nNow that we have the home page generating static content, let’s add some content to the site. We’ll display these posts as a list on the home page and on their own page, too.\nHugo has a command to generate a skeleton post, just like it does for sites and themes.\n$ hugo --verbose new post/first.md\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 attempting to create  post/first.md of post\nINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md\nERROR: 2014/09/29 Unable to Cast &lt;nil&gt; to map[string]interface{}\n\n$ \nThat wasn’t very nice, was it?\nThe “new” command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there’s a theme. For me, the workaround was to create an archetypes file specifically for the post type.\n$ vi themes/zafta/archetypes/post.md\n+++\nDescription = \"\"\nTags = []\nCategories = []\n+++\n:wq\n\n$ find themes/zafta/archetypes -type f | xargs ls -l\n-rw-r--r--  1 quoha  staff   0 Sep 29 21:53 themes/zafta/archetypes/default.md\n-rw-r--r--  1 quoha  staff  51 Sep 29 21:54 themes/zafta/archetypes/post.md\n\n$ hugo --verbose new post/first.md\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 attempting to create  post/first.md of post\nINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\nINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md\n/Users/quoha/Sites/zafta/content/post/first.md created\n\n$ hugo --verbose new post/second.md\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 attempting to create  post/second.md of post\nINFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md\nINFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md\n/Users/quoha/Sites/zafta/content/post/second.md created\n\n$ ls -l content/post\ntotal 16\n-rw-r--r--  1 quoha  staff  104 Sep 29 21:54 first.md\n-rw-r--r--  1 quoha  staff  105 Sep 29 21:57 second.md\n\n$ cat content/post/first.md \n+++\nCategories = []\nDescription = \"\"\nTags = []\ndate = \"2014-09-29T21:54:53-05:00\"\ntitle = \"first\"\n\n+++\nmy first post\n\n$ cat content/post/second.md \n+++\nCategories = []\nDescription = \"\"\nTags = []\ndate = \"2014-09-29T21:57:09-05:00\"\ntitle = \"second\"\n\n+++\nmy second post\n\n$ \nBuild the web site and then verify the results.\n$ rm -rf public\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 found taxonomies: map[string]string{\"category\":\"categories\", \"tag\":\"tags\"}\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n2 pages created \n0 tags created\n0 categories created\nin 4 ms\n$\nThe output says that it created 2 pages. Those are our new posts:\n$ find public -type f -name '*.html' | xargs ls -l\n-rw-r--r--  1 quoha  staff  78 Sep 29 22:13 public/index.html\n-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/first/index.html\n-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/index.html\n-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/second/index.html\n$\nThe new files are empty because because the templates used to generate the content are empty. The homepage doesn’t show the new content, either. We have to update the templates to add the posts.\n\n\n\nList and Single Templates\nIn Hugo, we have three major kinds of templates. There’s the home page template that we updated previously. It is used only by the home page. We also have “single” templates which are used to generate output for a single content file. We also have “list” templates that are used to group multiple pieces of content before generating output.\nGenerally speaking, list templates are named “list.html” and single templates are named “single.html.”\nThere are three other types of templates: partials, content views, and terms. We will not go into much detail on these.\n\n\nAdd Content to the Homepage\nThe home page will contain a list of posts. Let’s update its template to add the posts that we just created. The logic in the template will run every time we build the site.\n$ vi themes/zafta/layouts/index.html \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n  {{ range first 10 .Data.Pages }}\n    &lt;h1&gt;{{ .Title }}&lt;/h1&gt;\n  {{ end }}\n&lt;/body&gt;\n&lt;/html&gt;\n:wq\n\n$\nHugo uses the Go template engine. That engine scans the template files for commands which are enclosed between “{{” and “}}”. In our template, the commands are:\n\nrange\n.Title\nend\n\nThe “range” command is an iterator. We’re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.\nThe “.Title” command prints the value of the “title” variable. Hugo pulls it from the front matter in the Markdown file.\nThe “end” command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds “end.” Everything between the “range” and “end” is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.\nIt’s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.\nBuild the web site and then verify the results.\n$ rm -rf public\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 found taxonomies: map[string]string{\"tag\":\"tags\", \"category\":\"categories\"}\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n2 pages created \n0 tags created\n0 categories created\nin 4 ms\n$ find public -type f -name '*.html' | xargs ls -l \n-rw-r--r--  1 quoha  staff  94 Sep 29 22:23 public/index.html\n-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/first/index.html\n-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/index.html\n-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/second/index.html\n$ cat public/index.html \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n  \n    &lt;h1&gt;second&lt;/h1&gt;\n  \n    &lt;h1&gt;first&lt;/h1&gt;\n  \n&lt;/body&gt;\n&lt;/html&gt;\n$\nCongratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let’s take a moment to appreciate what we’ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you’ve learned everything you need to know to build a theme. All that’s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.\nAnd, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don’t worry, though, that’s all to come.\n\n\nAdd Content to the Posts\nWe’re working with posts, which are in the content/post/ directory. That means that their section is “post” (and if we don’t do something weird, their type is also “post”).\nHugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can’t find one, then it will look in the _default/ directory. There are some twists that we’ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.\nNow that we know the search rule, let’s see what we actually have available:\n$ find themes/zafta -name single.html | xargs ls -l\n-rw-r--r--  1 quoha  staff  132 Sep 29 17:31 themes/zafta/layouts/_default/single.html\nWe could create a new template, post/single.html, or change the default. Since we don’t know of any other content types, let’s start with updating the default.\nRemember, any content that we haven’t created a template for will end up using this template. That can be good or bad. Bad because I know that we’re going to be adding different types of content and we’re going to end up undoing some of the changes we’ve made. It’s good because we’ll be able to see immediate results. It’s also good to start here because we can start to build the basic layout for the site. As we add more content types, we’ll refactor this file and move logic around. Hugo makes that fairly painless, so we’ll accept the cost and proceed.\nPlease see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you’re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That’s a refreshing amount of joy right there.\n\nUpdate the Template File\n$ vi themes/zafta/layouts/_default/single.html \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;{{ .Title }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;\n  {{ .Content }}\n&lt;/body&gt;\n&lt;/html&gt;\n:wq\n\n$\nBuild the web site and verify the results.\n$ rm -rf public\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 found taxonomies: map[string]string{\"tag\":\"tags\", \"category\":\"categories\"}\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n2 pages created \n0 tags created\n0 categories created\nin 4 ms\n\n$ find public -type f -name '*.html' | xargs ls -l\n-rw-r--r--  1 quoha  staff   94 Sep 29 22:40 public/index.html\n-rw-r--r--  1 quoha  staff  125 Sep 29 22:40 public/post/first/index.html\n-rw-r--r--  1 quoha  staff    0 Sep 29 22:40 public/post/index.html\n-rw-r--r--  1 quoha  staff  128 Sep 29 22:40 public/post/second/index.html\n\n$ cat public/post/first/index.html \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;first&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;first&lt;/h1&gt;\n  &lt;p&gt;my first post&lt;/p&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n\n$ cat public/post/second/index.html \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;title&gt;second&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n  &lt;h1&gt;second&lt;/h1&gt;\n  &lt;p&gt;my second post&lt;/p&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\n$\nNotice that the posts now have content. You can go to localhost:1313/post/first to verify.\n\n\n\nLinking to Content\nThe posts are on the home page. Let’s add a link from there to the post. Since this is the home page, we’ll update its template.\n$ vi themes/zafta/layouts/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n  {{ range first 10 .Data.Pages }}\n    &lt;h1&gt;&lt;a href=\"{{ .Permalink }}\"&gt;{{ .Title }}&lt;/a&gt;&lt;/h1&gt;\n  {{ end }}\n&lt;/body&gt;\n&lt;/html&gt;\nBuild the web site and verify the results.\n$ rm -rf public\n$ hugo --verbose\nINFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/\nINFO: 2014/09/29 found taxonomies: map[string]string{\"tag\":\"tags\", \"category\":\"categories\"}\nWARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]\n0 draft content \n0 future content \n2 pages created \n0 tags created\n0 categories created\nin 4 ms\n\n$ find public -type f -name '*.html' | xargs ls -l\n-rw-r--r--  1 quoha  staff  149 Sep 29 22:44 public/index.html\n-rw-r--r--  1 quoha  staff  125 Sep 29 22:44 public/post/first/index.html\n-rw-r--r--  1 quoha  staff    0 Sep 29 22:44 public/post/index.html\n-rw-r--r--  1 quoha  staff  128 Sep 29 22:44 public/post/second/index.html\n\n$ cat public/index.html \n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n  \n    &lt;h1&gt;&lt;a href=\"/post/second/\"&gt;second&lt;/a&gt;&lt;/h1&gt;\n  \n    &lt;h1&gt;&lt;a href=\"/post/first/\"&gt;first&lt;/a&gt;&lt;/h1&gt;\n  \n&lt;/body&gt;\n&lt;/html&gt;\n\n$\n\n\nCreate a Post Listing\nWe have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let’s make it show a list of all posts (not just the first ten).\nWe need to decide which template to update. This will be a listing, so it should be a list template. Let’s take a quick look and see which list templates are available.\n$ find themes/zafta -name list.html | xargs ls -l\n-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/list.html\nAs with the single post, we have to decide to update _default/list.html or create post/list.html. We still don’t have multiple content types, so let’s stay consistent and update the default list template.",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#creating-top-level-pages",
    "href": "content/posts/creating-a-new-theme.html#creating-top-level-pages",
    "title": "Creating a New Theme",
    "section": "Creating Top Level Pages",
    "text": "Creating Top Level Pages\nLet’s add an “about” page and display it at the top level (as opposed to a sub-level like we did with posts).\nThe default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let’s verify that by creating an “about” page at the top level:\n$ vi content/about.md \n+++\ntitle = \"about\"\ndescription = \"about this site\"\ndate = \"2014-09-27\"\nslug = \"about time\"\n+++\n\n## about us\n\ni'm speechless\n:wq\nGenerate the web site and verify the results.\n$ find public -name '*.html' | xargs ls -l\n-rw-rw-r--  1 mdhender  staff   334 Sep 27 15:08 public/about-time/index.html\n-rw-rw-r--  1 mdhender  staff   527 Sep 27 15:08 public/index.html\n-rw-rw-r--  1 mdhender  staff   358 Sep 27 15:08 public/post/first-post/index.html\n-rw-rw-r--  1 mdhender  staff     0 Sep 27 15:08 public/post/index.html\n-rw-rw-r--  1 mdhender  staff   342 Sep 27 15:08 public/post/second-post/index.html\nNotice that the page wasn’t created at the top level. It was created in a sub-directory named ‘about-time/’. That name came from our slug. Hugo will use the slug to name the generated content. It’s a reasonable default, by the way, but we can learn a few things by fighting it for this file.\nOne other thing. Take a look at the home page.\n$ cat public/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n    &lt;h1&gt;&lt;a href=\"http://localhost:1313/post/theme/\"&gt;creating a new theme&lt;/a&gt;&lt;/h1&gt;\n    &lt;h1&gt;&lt;a href=\"http://localhost:1313/about-time/\"&gt;about&lt;/a&gt;&lt;/h1&gt;\n    &lt;h1&gt;&lt;a href=\"http://localhost:1313/post/second-post/\"&gt;second&lt;/a&gt;&lt;/h1&gt;\n    &lt;h1&gt;&lt;a href=\"http://localhost:1313/post/first-post/\"&gt;first&lt;/a&gt;&lt;/h1&gt;\n&lt;script&gt;document.write('&lt;script src=\"http://'\n        + (location.host || 'localhost').split(':')[0]\n        + ':1313/livereload.js?mindelay=10\"&gt;&lt;/'\n        + 'script&gt;')&lt;/script&gt;&lt;/body&gt;\n&lt;/html&gt;\nNotice that the “about” link is listed with the posts? That’s not desirable, so let’s change that first.\n$ vi themes/zafta/layouts/index.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;body&gt;\n  &lt;h1&gt;posts&lt;/h1&gt;\n  {{ range first 10 .Data.Pages }}\n    {{ if eq .Type \"post\"}}\n      &lt;h2&gt;&lt;a href=\"{{ .Permalink }}\"&gt;{{ .Title }}&lt;/a&gt;&lt;/h2&gt;\n    {{ end }}\n  {{ end }}\n\n  &lt;h1&gt;pages&lt;/h1&gt;\n  {{ range .Data.Pages }}\n    {{ if eq .Type \"page\" }}\n      &lt;h2&gt;&lt;a href=\"{{ .Permalink }}\"&gt;{{ .Title }}&lt;/a&gt;&lt;/h2&gt;\n    {{ end }}\n  {{ end }}\n&lt;/body&gt;\n&lt;/html&gt;\n:wq\nGenerate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.\nBut, that about page still renders to about-time/index.html.\n$ find public -name '*.html' | xargs ls -l\n-rw-rw-r--  1 mdhender  staff    334 Sep 27 15:33 public/about-time/index.html\n-rw-rw-r--  1 mdhender  staff    645 Sep 27 15:33 public/index.html\n-rw-rw-r--  1 mdhender  staff    358 Sep 27 15:33 public/post/first-post/index.html\n-rw-rw-r--  1 mdhender  staff      0 Sep 27 15:33 public/post/index.html\n-rw-rw-r--  1 mdhender  staff    342 Sep 27 15:33 public/post/second-post/index.html\nKnowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let’s do it the hard way and change the permalink in the configuration file.\n$ vi config.toml\n[permalinks]\n    page = \"/:title/\"\n    about = \"/:filename/\"\nGenerate the web site and verify that this didn’t work. Hugo lets “slug” or “URL” override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#sharing-templates",
    "href": "content/posts/creating-a-new-theme.html#sharing-templates",
    "title": "Creating a New Theme",
    "section": "Sharing Templates",
    "text": "Sharing Templates\nIf you’ve been following along, you probably noticed that posts have titles in the browser and the home page doesn’t. That’s because we didn’t put the title in the home page’s template (layouts/index.html). That’s an easy thing to do, but let’s look at a different option.\nWe can put the common bits into a shared template that’s stored in the themes/zafta/layouts/partials/ directory.\n\nCreate the Header and Footer Partials\nIn Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme’s presentation.\n$ vi themes/zafta/layouts/partials/header.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;title&gt;{{ .Title }}&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n:wq\n\n$ vi themes/zafta/layouts/partials/footer.html\n&lt;/body&gt;\n&lt;/html&gt;\n:wq\n\n\nUpdate the Home Page Template to Use the Partials\nThe most noticeable difference between a template call and a partials call is the lack of path:\n{{ template \"theme/partials/header.html\" . }}\nversus\n{{ partial \"header.html\" . }}\nBoth pass in the context.\nLet’s change the home page template to use these new partials.\n$ vi themes/zafta/layouts/index.html\n{{ partial \"header.html\" . }}\n\n  &lt;h1&gt;posts&lt;/h1&gt;\n  {{ range first 10 .Data.Pages }}\n    {{ if eq .Type \"post\"}}\n      &lt;h2&gt;&lt;a href=\"{{ .Permalink }}\"&gt;{{ .Title }}&lt;/a&gt;&lt;/h2&gt;\n    {{ end }}\n  {{ end }}\n\n  &lt;h1&gt;pages&lt;/h1&gt;\n  {{ range .Data.Pages }}\n    {{ if or (eq .Type \"page\") (eq .Type \"about\") }}\n      &lt;h2&gt;&lt;a href=\"{{ .Permalink }}\"&gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}&lt;/a&gt;&lt;/h2&gt;\n    {{ end }}\n  {{ end }}\n\n{{ partial \"footer.html\" . }}\n:wq\nGenerate the web site and verify the results. The title on the home page is now “your title here”, which comes from the “title” variable in the config.toml file.\n\n\nUpdate the Default Single Template to Use the Partials\n$ vi themes/zafta/layouts/_default/single.html\n{{ partial \"header.html\" . }}\n\n  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;\n  {{ .Content }}\n\n{{ partial \"footer.html\" . }}\n:wq\nGenerate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/creating-a-new-theme.html#add-date-published-to-posts",
    "href": "content/posts/creating-a-new-theme.html#add-date-published-to-posts",
    "title": "Creating a New Theme",
    "section": "Add “Date Published” to Posts",
    "text": "Add “Date Published” to Posts\nIt’s common to have posts display the date that they were written or published, so let’s add that. The front matter of our posts has a variable named “date.” It’s usually the date the content was created, but let’s pretend that’s the value we want to display.\n\nAdd “Date Published” to the Template\nWe’ll start by updating the template used to render the posts. The template code will look like:\n{{ .Date.Format \"Mon, Jan 2, 2006\" }}\nPosts use the default single template, so we’ll change that file.\n$ vi themes/zafta/layouts/_default/single.html\n{{ partial \"header.html\" . }}\n\n  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;\n  &lt;h2&gt;{{ .Date.Format \"Mon, Jan 2, 2006\" }}&lt;/h2&gt;\n  {{ .Content }}\n\n{{ partial \"footer.html\" . }}\n:wq\nGenerate the web site and verify the results. The posts now have the date displayed in them. There’s a problem, though. The “about” page also has the date displayed.\nAs usual, there are a couple of ways to make the date display only on posts. We could do an “if” statement like we did on the home page. Another way would be to create a separate template for posts.\nThe “if” solution works for sites that have just a couple of content types. It aligns with the principle of “code for today,” too.\nLet’s assume, though, that we’ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we’re going to create a section template.\nLet’s restore the default single template before we forget.\n$ mkdir themes/zafta/layouts/post\n$ vi themes/zafta/layouts/_default/single.html\n{{ partial \"header.html\" . }}\n\n  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;\n  {{ .Content }}\n\n{{ partial \"footer.html\" . }}\n:wq\nNow we’ll update the post’s version of the single template. If you remember Hugo’s rules, the template engine will use this version over the default.\n$ vi themes/zafta/layouts/post/single.html\n{{ partial \"header.html\" . }}\n\n  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;\n  &lt;h2&gt;{{ .Date.Format \"Mon, Jan 2, 2006\" }}&lt;/h2&gt;\n  {{ .Content }}\n\n{{ partial \"footer.html\" . }}\n:wq\n\nNote that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn’t.\n\n\nDon’t Repeat Yourself\nDRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you’re figuring that out, accept that you’ll be doing some refactoring. Hugo makes that easy and fast, so it’s okay to delay splitting up a template.",
    "crumbs": [
      "Notes",
      "Creating a New Theme"
    ]
  },
  {
    "objectID": "content/posts/Integrate DeepL Translation Instruction.html",
    "href": "content/posts/Integrate DeepL Translation Instruction.html",
    "title": "Erise Note",
    "section": "",
    "text": "1. Install R and Babeldown\n\n1.1 Install R\nhttps://cran.r-project.org/.\n(The following task is using R console) #### 1.2 Install Babeldown\nMore specific instruction, check here: https://docs.ropensci.org/babeldown/\n1.2.1 This command install ‘remotes’ from CRAN if not already installed:\nif (!requireNamespace(\"remotes\", quietly = TRUE)) {\n    install.packages(\"remotes\")\n}\n1.2.2 Uses the ‘remotes’ package to install the ‘babeldown’ package from its GitHub repo:\ninstall.packages('babeldown', repos = c('https://ropensci.r-universe.dev', 'https://cloud.r-project.org'))\n\n\n2. Set up DeepL API (Inside of R console)\n\nGo to DeepL’s website and get an API key: https://www.deepl.com/en/your-account/keys\n\n\n\n3. Connect Babeldown to DeepL API\nBabeldown uses the DeepL free API URL by default (no need to set up unless pro API).\n\n3.1 Download a keyring package (for secure API key retrieval)\ninstall.packages(\"keyring\")\n\n\n3.2 Keyring requests your API key\nlibrary(keyring)\n\nkeyring::key_set(\"deepl\", prompt = \"API key:\")\nEnter your API key and then in any script you use babeldown, you’d retrieve the key like so:\nSys.setenv(DEEPL_API_KEY = keyring::key_get(\"deepl\"))\n\n\n\n4. (optional) Set up working directory\nIn R, use getwd() to check current working directory, and you may use setwd(\"your absolute path\") to move your working directory for convenience.\nMy setup is:\nsetwd(\"/Users/erisehe/Documents/GitHub/erisehe.github.io\")\n\n\n4. Translates\nSince my working directory is at (“…/erisehe.github.io”), so I runs relative path. The commands, for example, is:\nbabeldown::deepl_translate_hugo(\n  post_path = \"content.en/docs/Mathematics/MATH 412 Real Analysis II/Lecture/name.md\",\n  target_lang = \"ZH\",\n  source_lang = \"EN\",\n  force = TRUE\n)\nIt translate only one file at a time.\n\n\nHow to Translate an Entire Folder\nYou can use base R functions (or packages like purrr) to list the files and apply the translation function.\n# Define the source folder containing your markdown files\nsource_dir &lt;- \"path/to/your/source_folder\"\n\n# Define the target folder where you want to save the translated files\ntarget_dir &lt;- \"path/to/your/target_folder\"\nif (!dir.exists(target_dir)) {\n  dir.create(target_dir)\n}\n\n# List all markdown files in the source directory\nfiles &lt;- list.files(source_dir, pattern = \"\\\\.md$\", full.names = TRUE)\n\n# Loop through each file and translate it\nfor (f in files) {\n  # Translate the file using babeldown's deepl_translate_hugo function\n  babeldown::deepl_translate_hugo(\n    post_path = f,\n    target_lang = \"ZH\",\n    source_lang = \"EN\",\n    force = TRUE\n  )\n  \n  # If the function writes the output file in a default location or with a predictable name,\n  # you can move or copy it to your target directory. For example:\n  output_file &lt;- file.path(dirname(f), paste0(\"translated_\", basename(f)))\n  if (file.exists(output_file)) {\n    file.copy(output_file, file.path(target_dir, basename(output_file)))\n  }\n}",
    "crumbs": [
      "Notes",
      "1. Install R and Babeldown"
    ]
  },
  {
    "objectID": "content/posts/2025 Topology Summer Research.html",
    "href": "content/posts/2025 Topology Summer Research.html",
    "title": "Erise Note",
    "section": "",
    "text": "Summer Application:\nhttps://sgi.mit.edu/about-geometry-processing/\n\n\nApril\nhttps://topologyandgeometry.iu.edu/gstgc25/\n\n\nMay\nhttps://topology.franklinresearch.uga.edu/2025GITC\n\n\nPast Year\nhttps://sites.google.com/view/princetonrtg2023/mini-conferences",
    "crumbs": [
      "Notes",
      "Summer Application:"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html",
    "title": "波函数存在于Hilbert空间中",
    "section": "",
    "text": "Infinite dimensional vector space, denoted as \\(L^2(a,b)\\), of square-integrable functions on an interval \\([a,b]\\). \\[\\int_a^b |f(x)|^2 \\, dx &lt; \\infty\\] Inner product defined as: \\[\\langle f | g \\rangle = \\int_a^b f^*(x)g(x) \\, dx\\] Note that: \\[\\langle f | g \\rangle = \\langle g | f \\rangle^*\\] \\[\\langle f | f \\rangle = \\int_a^b |f(x)|^2 \\, dx \\geq 0\\] Also: \\[\\langle f | f \\rangle = 0 \\iff f(x) = 0 \\quad\\text{in the interval}\\quad [a,b]\\]\n\n\n\n\\[\\langle f_m | f_n \\rangle = \\int_a^b f_m^*(x)f_n(x)\\,dx = \\delta_{m,n}\\] Completeness: A set of functions \\(\\{f_n\\}\\) is complete if any \\(f(x)\\) in the Hilbert space can be expanded as: \\[f(x) = \\sum_n c_n f_n(x)\\] If \\(\\{f_n\\}\\) is orthonormal, then: \\[c_n = \\langle f_n | f \\rangle\\] ## Observables and Hermitian Operators\nAn operator \\(\\hat{Q}\\) is Hermitian if:\n\\[\n\\hat{Q} = \\hat{Q}^{\\dagger}\n\\]\n\n\n\n\nEigenvalues are real.\n\nExpectation value \\(\\langle Q \\rangle\\):\n\\[\n\\langle Q \\rangle = \\langle \\psi | \\hat{Q} \\psi \\rangle = \\langle \\hat{Q}^{\\dagger} \\psi | \\psi \\rangle = \\langle \\psi | \\hat{Q} \\psi \\rangle^{*}\n\\]\nThus,\n\\[\n\\langle Q \\rangle \\quad \\text{is real}\n\\]\n\nCheck inner product:\n\\[\n\\langle f| \\hat{x} g \\rangle = \\int_{-\\infty}^{\\infty} f^*(x) x g(x) \\, dx\n\\]\nComplex conjugate clearly shows:\n\\[\n= \\int_{-\\infty}^{\\infty} (x f(x))^* g(x) \\, dx = \\langle \\hat{x}f | g \\rangle\n\\]\nThus,\n\\[\n\\hat{x} = \\hat{x}^{\\dagger} \\quad \\Rightarrow \\quad \\text{Hermitian}\n\\]\n\nEvaluate inner product:\n\\[\n\\langle f| \\hat{p} g \\rangle = \\int_{-\\infty}^{\\infty} f^*(x) \\left(-i\\hbar \\frac{d}{dx}\\right) g(x) \\, dx\n\\]\nUsing integration by parts:\n\\[\n= -i\\hbar \\int_{-\\infty}^{\\infty} dx \\frac{d}{dx}(f^*(x)g(x)) + i\\hbar \\int_{-\\infty}^{\\infty} dx \\frac{df^*(x)}{dx} g(x)\n\\]\nBoundary term vanishes:\n\\[\n= -i\\hbar [f^*(x)g(x)]_{-\\infty}^{\\infty} + \\langle \\hat{p} f | g \\rangle, \\quad \\text{with boundary term = 0}\n\\]\nThus:\n\\[\n\\langle f| \\hat{p} g \\rangle = \\langle \\hat{p} f | g \\rangle \\quad \\Rightarrow \\quad \\hat{p} = \\hat{p}^{\\dagger}, \\quad \\text{Hermitian!}\n\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#hilbert-space",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#hilbert-space",
    "title": "波函数存在于Hilbert空间中",
    "section": "",
    "text": "Infinite dimensional vector space, denoted as \\(L^2(a,b)\\), of square-integrable functions on an interval \\([a,b]\\). \\[\\int_a^b |f(x)|^2 \\, dx &lt; \\infty\\] Inner product defined as: \\[\\langle f | g \\rangle = \\int_a^b f^*(x)g(x) \\, dx\\] Note that: \\[\\langle f | g \\rangle = \\langle g | f \\rangle^*\\] \\[\\langle f | f \\rangle = \\int_a^b |f(x)|^2 \\, dx \\geq 0\\] Also: \\[\\langle f | f \\rangle = 0 \\iff f(x) = 0 \\quad\\text{in the interval}\\quad [a,b]\\]\n\n\n\n\\[\\langle f_m | f_n \\rangle = \\int_a^b f_m^*(x)f_n(x)\\,dx = \\delta_{m,n}\\] Completeness: A set of functions \\(\\{f_n\\}\\) is complete if any \\(f(x)\\) in the Hilbert space can be expanded as: \\[f(x) = \\sum_n c_n f_n(x)\\] If \\(\\{f_n\\}\\) is orthonormal, then: \\[c_n = \\langle f_n | f \\rangle\\] ## Observables and Hermitian Operators\nAn operator \\(\\hat{Q}\\) is Hermitian if:\n\\[\n\\hat{Q} = \\hat{Q}^{\\dagger}\n\\]\n\n\n\n\nEigenvalues are real.\n\nExpectation value \\(\\langle Q \\rangle\\):\n\\[\n\\langle Q \\rangle = \\langle \\psi | \\hat{Q} \\psi \\rangle = \\langle \\hat{Q}^{\\dagger} \\psi | \\psi \\rangle = \\langle \\psi | \\hat{Q} \\psi \\rangle^{*}\n\\]\nThus,\n\\[\n\\langle Q \\rangle \\quad \\text{is real}\n\\]\n\nCheck inner product:\n\\[\n\\langle f| \\hat{x} g \\rangle = \\int_{-\\infty}^{\\infty} f^*(x) x g(x) \\, dx\n\\]\nComplex conjugate clearly shows:\n\\[\n= \\int_{-\\infty}^{\\infty} (x f(x))^* g(x) \\, dx = \\langle \\hat{x}f | g \\rangle\n\\]\nThus,\n\\[\n\\hat{x} = \\hat{x}^{\\dagger} \\quad \\Rightarrow \\quad \\text{Hermitian}\n\\]\n\nEvaluate inner product:\n\\[\n\\langle f| \\hat{p} g \\rangle = \\int_{-\\infty}^{\\infty} f^*(x) \\left(-i\\hbar \\frac{d}{dx}\\right) g(x) \\, dx\n\\]\nUsing integration by parts:\n\\[\n= -i\\hbar \\int_{-\\infty}^{\\infty} dx \\frac{d}{dx}(f^*(x)g(x)) + i\\hbar \\int_{-\\infty}^{\\infty} dx \\frac{df^*(x)}{dx} g(x)\n\\]\nBoundary term vanishes:\n\\[\n= -i\\hbar [f^*(x)g(x)]_{-\\infty}^{\\infty} + \\langle \\hat{p} f | g \\rangle, \\quad \\text{with boundary term = 0}\n\\]\nThus:\n\\[\n\\langle f| \\hat{p} g \\rangle = \\langle \\hat{p} f | g \\rangle \\quad \\Rightarrow \\quad \\hat{p} = \\hat{p}^{\\dagger}, \\quad \\text{Hermitian!}\n\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#observables-and-hermitian-operators",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#observables-and-hermitian-operators",
    "title": "波函数存在于Hilbert空间中",
    "section": "Observables and Hermitian Operators",
    "text": "Observables and Hermitian Operators\n\nHermitian Operator:\nAn operator \\(\\hat{Q}\\) is Hermitian if:\n\\[\\hat{Q} = \\hat{Q}^{\\dagger}\\]\n\n\nSpectrum of \\(\\hat{Q}\\)\n\nSpectrum: The collection of all eigenvalues \\(q \\in \\mathbb{R}\\).\n\nEigenvalue equation:\n\\[\\hat{Q}\\Psi = q\\Psi\\]\nwhere: - \\(q\\) is an eigenvalue. - \\(\\Psi\\) represents eigenvectors, eigenstates, or eigenfunctions.\n\n\n\nStandard Deviation:\nThe uncertainty (standard deviation) \\(\\sigma\\) of an observable \\(\\hat{Q}\\) is given by:\n\\[\\sigma^2 = \\langle \\Psi | \\hat{Q}^2 \\Psi \\rangle - \\langle \\Psi | \\hat{Q} \\Psi \\rangle^2\\]\nIf \\(\\Psi\\) is an eigenfunction of \\(\\hat{Q}\\):\n\nEigenvalue equations:\n\n\\[\\hat{Q}\\Psi = q\\Psi, \\quad \\hat{Q}^2 \\Psi = q^2 \\Psi\\]\nThen, the standard deviation becomes:\n\\[\\langle \\Psi | \\hat{Q}^2 \\Psi \\rangle = q^2 \\langle \\Psi | \\Psi \\rangle = q^2\\] \\[\\langle \\Psi | \\hat{Q} \\Psi \\rangle^2 = (q \\langle \\Psi | \\Psi \\rangle)^2 = q^2\\]\nThus:\n\\[\\sigma^2 = q^2 - q^2 = 0\\]\n\n\n\nPhysical Interpretation:\nThis means that if we prepare a quantum state to be an eigenstate/eigenvector/eigenfunction of \\(\\hat{Q}\\), then a measurement of \\(\\hat{Q}\\) will return a definite value. In this case, the state \\(|\\Psi\\rangle\\) is called a determinate state. ##### Example\nFor \\(\\hat{H}\\Psi = E\\Psi\\), we have: - \\(E\\) is an eigenvalue (energy level) belonging to the set \\(\\{ E \\}\\), which represents all possible energies of the system. - \\(\\Psi\\) are the corresponding eigenstates/eigenfunctions of definite energy (stationary states).",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#example-energy-eigenvalue-equation",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#example-energy-eigenvalue-equation",
    "title": "波函数存在于Hilbert空间中",
    "section": "Example: Energy Eigenvalue Equation",
    "text": "Example: Energy Eigenvalue Equation\nThe Schrödinger equation for a quantum system is given by:\n\\[\\hat{H}\\Psi = E\\Psi\\]\nWhere: - \\(E\\) is an eigenvalue (energy level) belonging to the set \\(\\{ E \\}\\), representing all possible energies of the system. - \\(\\Psi\\) represents the corresponding eigenstates or eigenfunctions of definite energy, also known as stationary states.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#particle-on-a-ring-of-radius-r",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#particle-on-a-ring-of-radius-r",
    "title": "波函数存在于Hilbert空间中",
    "section": "Particle on a Ring of Radius \\(R\\)",
    "text": "Particle on a Ring of Radius \\(R\\)\nCoordinate transformation: \\[x = R \\cdot \\phi, \\quad (\\text{with } \\phi \\text{ periodic, } \\phi \\sim \\phi + 2\\pi)\\]\n\nMomentum Operator in Circular Coordinates:\n\\[\\hat{p} = -i\\hbar\\frac{d}{dx} = -i\\hbar\\frac{\\partial}{R\\partial\\phi} = \\frac{\\hbar}{R}\\left(-i\\frac{\\partial}{\\partial\\phi}\\right)\\]\nCheck if \\(\\hat{Q}\\) is Hermitian:\n\\[\\langle f|\\hat{Q}g \\rangle \\stackrel{?}{=} \\langle \\hat{Q}f | g \\rangle\\]\n\n\nHermiticity Check for Operator \\(\\hat{x}\\):\n\\[\\langle f|\\hat{x}g \\rangle = \\int_{-\\infty}^{\\infty}f^*(x)xg(x)\\,dx = \\langle \\hat{x}f|g \\rangle \\quad \\Rightarrow \\quad \\hat{x} = \\hat{x}^{\\dagger}\\]\nThus, \\(\\hat{x}\\) is Hermitian.\n\n\n\nEigenvalues and Eigenfunctions (Periodic Boundary Conditions):\n\nFunctions on a ring of radius \\(R\\): periodic with \\(\\phi\\): \\[f(\\phi+2\\pi) = f(\\phi)\\] \\[g(\\phi+2\\pi) = g(\\phi)\\] Eigenvalue equation for the operator \\(\\hat{Q}\\): \\[\\hat{Q}f(\\phi)=q f(\\phi)\\] Solve for \\(f(\\phi)\\): \\[-i\\frac{d f(\\phi)}{d\\phi} = q f(\\phi) \\quad\\Rightarrow\\quad f(\\phi) = A e^{i q \\phi}\\]\n\n\n\n\nNormalization and Quantization of \\(q\\):\nFrom periodic boundary condition:\n\\[f(\\phi + 2\\pi) = A e^{i q (\\phi+2\\pi)} = A e^{i q \\phi} e^{i q 2\\pi} = f(\\phi)\\]\nThus,\n\\[e^{i q 2\\pi} = 1 \\quad\\Rightarrow\\quad q = 0, \\pm1, \\pm2, \\pm3, \\dots\\]\n\n\nNormalization condition:\n\\[\\int_0^{2\\pi} d\\phi |f(\\phi)|^2 = \\int_0^{2\\pi} d\\phi |A|^2 = |A|^2 \\cdot 2\\pi = 1\\]\nThus,\n\\[|A|^2 = \\frac{1}{2\\pi} \\quad\\Rightarrow\\quad A = \\frac{1}{\\sqrt{2\\pi}}\\]\n\n\nFinal Set of Eigenfunctions and Eigenvalues:\n\\[f_q(\\phi) = \\frac{1}{\\sqrt{2\\pi}} e^{i q \\phi}, \\quad q = 0, \\pm1, \\pm2, \\dots\\] ### Eigenvalues for Momentum \\(\\hat{p}\\):\n\\[\\frac{\\hbar}{R}q = 0, \\pm\\frac{\\hbar}{R}, \\pm\\frac{2\\hbar}{R}, \\pm\\frac{3\\hbar}{R}, \\dots\\]\n\nHere’s the requested content neatly formatted in Markdown with LaTeX notation, using the {align} environment for clarity:",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#eigenfunctions-of-a-hermitian-operator",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#eigenfunctions-of-a-hermitian-operator",
    "title": "波函数存在于Hilbert空间中",
    "section": "Eigenfunctions of a Hermitian Operator",
    "text": "Eigenfunctions of a Hermitian Operator\n\\[\\hat{Q}\\psi = q\\psi\\]\nDiscrete Spectra: \\[\\hat{Q} f = q f\\]\n\nEigenvalues \\(q \\in \\mathbb{R}\\).\nFor two eigenfunctions \\(f\\) and \\(g\\) corresponding to distinct eigenvalues \\(q\\) and \\(q'\\), we have: \\[\\hat{Q}f = qf, \\quad \\hat{Q}g = q'g,\\quad q \\neq q'\\]\n\nThen: \\[\\langle f | \\hat{Q} g \\rangle = \\langle \\hat{Q}f|g \\rangle\\]\nBut also: \\[q'\\langle f|g \\rangle = q\\langle f|g\\rangle \\implies (q - q')\\langle f|g\\rangle = 0\\]\nThus, for distinct eigenvalues: \\[\\langle f|g\\rangle = 0\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#continuous-spectra",
    "href": "content/notes/计算/量子力学讲义/波函数存在于在Hilbert空间中.html#continuous-spectra",
    "title": "波函数存在于Hilbert空间中",
    "section": "Continuous Spectra",
    "text": "Continuous Spectra\nConsider eigenfunctions of the momentum operator on the real line \\((-\\infty, +\\infty)\\):\n\\[-i\\hbar \\frac{d}{dx}f_p(x) = p\\,f_p(x)\\]\nEigenfunctions have the form: \\[f_p(x) = A e^{\\frac{i p x}{\\hbar}}\\]\nNote that these eigenfunctions are not square-integrable: \\[\\int_{-\\infty}^{\\infty}|f_p(x)|^2\\,dx = |A|^2\\int_{-\\infty}^{\\infty}\\left|e^{\\frac{ipx}{\\hbar}}\\right|^2dx = \\infty\\]\nHence, the eigenfunctions corresponding to continuous eigenvalues are not square-integrable functions.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "波函数存在于Hilbert空间中"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/第四章.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/第四章.html",
    "title": "Erise Note",
    "section": "",
    "text": "薛定谔方程（S.E.）的一般形式记为： \\[\ni \\hbar \\frac{\\partial \\Psi}{\\partial t}=\\hat{H} \\Psi\n\\] 三维哈密顿算符\\(\\hat{H}\\)从经典能量得出： \\[\n\\frac{1}{2} m v^2+V=\\frac{1}{2 m}\\left(p_x^2+p_y^2+p_z^2\\right)+V\n\\] 通过标准的量子化处理 \\[\n\\mathbf{p} \\rightarrow-i \\hbar \\nabla\n\\]\n因此，我们获得三维的薛定谔方程： &gt; [!theorem|*] 3-Dimentional Schrodinger Equation &gt; \\[\ni \\hbar \\frac{\\partial \\Psi}{\\partial t}=-\\frac{\\hbar^2}{2 m} \\nabla^2 \\Psi+V \\Psi\n&gt; \\] &gt; where &gt; \\[\n\\nabla^2 \\equiv \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2}\n&gt; \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1 三维空间的薛定谔方程"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/第四章.html#三维空间的薛定谔方程",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/第四章.html#三维空间的薛定谔方程",
    "title": "Erise Note",
    "section": "",
    "text": "薛定谔方程（S.E.）的一般形式记为： \\[\ni \\hbar \\frac{\\partial \\Psi}{\\partial t}=\\hat{H} \\Psi\n\\] 三维哈密顿算符\\(\\hat{H}\\)从经典能量得出： \\[\n\\frac{1}{2} m v^2+V=\\frac{1}{2 m}\\left(p_x^2+p_y^2+p_z^2\\right)+V\n\\] 通过标准的量子化处理 \\[\n\\mathbf{p} \\rightarrow-i \\hbar \\nabla\n\\]\n因此，我们获得三维的薛定谔方程： &gt; [!theorem|*] 3-Dimentional Schrodinger Equation &gt; \\[\ni \\hbar \\frac{\\partial \\Psi}{\\partial t}=-\\frac{\\hbar^2}{2 m} \\nabla^2 \\Psi+V \\Psi\n&gt; \\] &gt; where &gt; \\[\n\\nabla^2 \\equiv \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}+\\frac{\\partial^2}{\\partial z^2}\n&gt; \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1 三维空间的薛定谔方程"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "",
    "text": "这里定义了基本的自旋向上和自旋向下态的矢量表示： \\(|\\uparrow\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\), \\(|\\downarrow\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\\) \\(S_z\\)算符作用于自旋态，得到对应的本征值\n\\(S_z|\\uparrow\\rangle = \\frac{\\hbar}{2}|\\uparrow\\rangle\\)\n\\(S_z|\\downarrow\\rangle = -\\frac{\\hbar}{2}|\\downarrow\\rangle\\)\n这些是三个方向上自旋算符的矩阵表示形式\n\\(S_x = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\\), \\(S_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}\\), \\(S_z = \\frac{\\hbar}{2}\\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\\)\n重要工具：定义升降算符\n\\(S_+ = S_x + iS_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\)\n\\(S_- = S_x - iS_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\)\n这部分计算展示了升降算符如何改变自旋态，\\(S_+\\)将自旋向下变为向上，\\(S_-\\)将自旋向上变为向下\n\\(S_+|\\uparrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 0\\)\n\\(S_+|\\downarrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{\\hbar}{2}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{\\hbar}{2}|\\uparrow\\rangle\\)\n\\(S_-|\\uparrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{\\hbar}{2}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{\\hbar}{2}|\\downarrow\\rangle\\)\n\\(S_-|\\downarrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 0\\)\n\n\n\n这里开始计算两个自旋之间的相互作用，即点积算符作用于两个自旋均向上的态\n\\[\n\\begin{align}\n\\vec{S}_1 \\cdot \\vec{S}_2 |\\uparrow\\rangle|\\uparrow\\rangle = &  (S_{1x}S_{2x} + S_{1y}S_{2y} + S_{1z}S_{2z})|\\uparrow\\rangle|\\uparrow\\rangle \\\\\n= &  \\left[\\frac{1}{2}(S_{1+}S_{2-} + S_{1-}S_{2+}) + S_{1z}S_{2z}\\right]|\\uparrow\\rangle|\\uparrow\\rangle \\\\\n=  & S_{1z}S_{2z}|\\uparrow\\rangle|\\uparrow\\rangle \\\\\n=  &  (S_{1z}|\\uparrow\\rangle)(S_{2z}|\\uparrow\\rangle) \\\\\n=  & \\left(\\frac{\\hbar}{2}|\\uparrow\\rangle\\right)\\left(\\frac{\\hbar}{2}|\\uparrow\\rangle\\right) \\\\\n=  & \\frac{\\hbar^2}{4}|\\uparrow\\rangle|\\uparrow\\rangle\n\\end{align}\n\\]\n\\(|\\uparrow\\rangle|\\uparrow\\rangle\\) 是 \\(\\vec{S}_1 \\cdot \\vec{S}_2\\) 的eigenstate，对应的的eigenvalue为 \\(\\frac{\\hbar^2}{4}\\)\n这个结论表明两个自旋向上的复合态是自旋-自旋相互作用算符的本征态，这在量子磁学中非常重要",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#单自旋态one-spin-states",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#单自旋态one-spin-states",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "",
    "text": "这里定义了基本的自旋向上和自旋向下态的矢量表示： \\(|\\uparrow\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\), \\(|\\downarrow\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\\) \\(S_z\\)算符作用于自旋态，得到对应的本征值\n\\(S_z|\\uparrow\\rangle = \\frac{\\hbar}{2}|\\uparrow\\rangle\\)\n\\(S_z|\\downarrow\\rangle = -\\frac{\\hbar}{2}|\\downarrow\\rangle\\)\n这些是三个方向上自旋算符的矩阵表示形式\n\\(S_x = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\\), \\(S_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}\\), \\(S_z = \\frac{\\hbar}{2}\\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix}\\)\n重要工具：定义升降算符\n\\(S_+ = S_x + iS_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\)\n\\(S_- = S_x - iS_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\)\n这部分计算展示了升降算符如何改变自旋态，\\(S_+\\)将自旋向下变为向上，\\(S_-\\)将自旋向上变为向下\n\\(S_+|\\uparrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 0\\)\n\\(S_+|\\downarrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{\\hbar}{2}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{\\hbar}{2}|\\uparrow\\rangle\\)\n\\(S_-|\\uparrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{\\hbar}{2}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{\\hbar}{2}|\\downarrow\\rangle\\)\n\\(S_-|\\downarrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 0\\)",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#从uparrowrangleuparrowrangle开始计算start-with-uparrowrangleuparrowrangle",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#从uparrowrangleuparrowrangle开始计算start-with-uparrowrangleuparrowrangle",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "",
    "text": "这里开始计算两个自旋之间的相互作用，即点积算符作用于两个自旋均向上的态\n\\[\n\\begin{align}\n\\vec{S}_1 \\cdot \\vec{S}_2 |\\uparrow\\rangle|\\uparrow\\rangle = &  (S_{1x}S_{2x} + S_{1y}S_{2y} + S_{1z}S_{2z})|\\uparrow\\rangle|\\uparrow\\rangle \\\\\n= &  \\left[\\frac{1}{2}(S_{1+}S_{2-} + S_{1-}S_{2+}) + S_{1z}S_{2z}\\right]|\\uparrow\\rangle|\\uparrow\\rangle \\\\\n=  & S_{1z}S_{2z}|\\uparrow\\rangle|\\uparrow\\rangle \\\\\n=  &  (S_{1z}|\\uparrow\\rangle)(S_{2z}|\\uparrow\\rangle) \\\\\n=  & \\left(\\frac{\\hbar}{2}|\\uparrow\\rangle\\right)\\left(\\frac{\\hbar}{2}|\\uparrow\\rangle\\right) \\\\\n=  & \\frac{\\hbar^2}{4}|\\uparrow\\rangle|\\uparrow\\rangle\n\\end{align}\n\\]\n\\(|\\uparrow\\rangle|\\uparrow\\rangle\\) 是 \\(\\vec{S}_1 \\cdot \\vec{S}_2\\) 的eigenstate，对应的的eigenvalue为 \\(\\frac{\\hbar^2}{4}\\)\n这个结论表明两个自旋向上的复合态是自旋-自旋相互作用算符的本征态，这在量子磁学中非常重要",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#focus-on-2-spins-h-j-vecs_1-cdot-vecs_2",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#focus-on-2-spins-h-j-vecs_1-cdot-vecs_2",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "Focus on 2 Spins: \\(H = J \\vec{S}_1 \\cdot \\vec{S}_2\\)",
    "text": "Focus on 2 Spins: \\(H = J \\vec{S}_1 \\cdot \\vec{S}_2\\)\n关注两个自旋系统，哈密顿量由自旋-自旋相互作用给出，其中\\(J\\)是耦合常数\nspin-1/2 quantum mechanical operators 自旋-1/2量子力学算符\n\\((|\\uparrow\\rangle|\\uparrow\\rangle, |\\uparrow\\rangle|\\downarrow\\rangle, |\\downarrow\\rangle|\\uparrow\\rangle, |\\downarrow\\rangle|\\downarrow\\rangle)\\)\n这是两个自旋-1/2系统的四个可能基态\n\\(\\vec{S}_1 \\cdot \\vec{S}_2 |\\downarrow\\rangle|\\downarrow\\rangle = \\left(\\frac{1}{2}(S_{1+}S_{2-} + S_{1-}S_{2+}) + S_{1z}S_{2z}\\right)|\\downarrow\\rangle|\\downarrow\\rangle = S_{1z}S_{2z}|\\downarrow\\rangle|\\downarrow\\rangle\\)\n\\(= (S_{1z}|\\downarrow\\rangle)(S_{2z}|\\downarrow\\rangle)\\)\n\\(= \\left(-\\frac{\\hbar}{2}|\\downarrow\\rangle\\right)\\left(-\\frac{\\hbar}{2}|\\downarrow\\rangle\\right)\\)\n\\(= \\frac{\\hbar^2}{4}|\\downarrow\\rangle|\\downarrow\\rangle\\)\n计算自旋-自旋相互作用算符作用于两个自旋向下态的结果",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#is-uparrowrangledownarrowrangle-also-an-eigenstate",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#is-uparrowrangledownarrowrangle-also-an-eigenstate",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "Is \\(|\\uparrow\\rangle|\\downarrow\\rangle\\) also an eigenstate?",
    "text": "Is \\(|\\uparrow\\rangle|\\downarrow\\rangle\\) also an eigenstate?\n\\(|\\uparrow\\rangle|\\downarrow\\rangle\\)是否也是本征态？\n\\(\\vec{S}_1 \\cdot \\vec{S}_2 |\\uparrow\\rangle|\\downarrow\\rangle = \\left[\\frac{1}{2}(S_{1+}S_{2-} + S_{1-}S_{2+}) + S_{1z}S_{2z}\\right]|\\uparrow\\rangle|\\downarrow\\rangle\\)\n\\(= \\frac{1}{2}(S_{1+}|\\uparrow\\rangle)(S_{2-}|\\downarrow\\rangle) + \\frac{1}{2}(S_{1-}|\\uparrow\\rangle)(S_{2+}|\\downarrow\\rangle) + (S_{1z}|\\uparrow\\rangle)(S_{2z}|\\downarrow\\rangle)\\)\n\\(= \\frac{1}{2}(0)(\\frac{\\hbar}{2}|\\uparrow\\rangle) + \\frac{1}{2}(\\frac{\\hbar}{2}|\\downarrow\\rangle)(0) + (\\frac{\\hbar}{2}|\\uparrow\\rangle)(-\\frac{\\hbar}{2}|\\downarrow\\rangle)\\)\n分步计算每一项的结果\n\\(\\vec{S}_1 \\cdot \\vec{S}_2 |\\uparrow\\rangle|\\downarrow\\rangle = \\frac{\\hbar^2}{2}|\\downarrow\\rangle|\\uparrow\\rangle - \\frac{\\hbar^2}{4}|\\uparrow\\rangle|\\downarrow\\rangle\\)\n结果表明\\(|\\uparrow\\rangle|\\downarrow\\rangle\\)不是本征态，因为结果包含不同的量子态",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#likewise",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#likewise",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "Likewise",
    "text": "Likewise\n类似地计算另一种混合态\n\\(\\vec{S}_1 \\cdot \\vec{S}_2 |\\downarrow\\rangle|\\uparrow\\rangle = \\frac{\\hbar^2}{2}|\\uparrow\\rangle|\\downarrow\\rangle - \\frac{\\hbar^2}{4}|\\downarrow\\rangle|\\uparrow\\rangle\\)\n同样，\\(|\\downarrow\\rangle|\\uparrow\\rangle\\)也不是本征态\n\\(|\\downarrow\\rangle|\\downarrow\\rangle\\) is an eigenstate of \\(\\vec{S}_1 \\cdot \\vec{S}_2\\) with the eigenvalue \\(\\frac{\\hbar^2}{4}\\)\n\\(|\\downarrow\\rangle|\\downarrow\\rangle\\)是\\(\\vec{S}_1 \\cdot \\vec{S}_2\\)的本征态，对应本征值\\(\\frac{\\hbar^2}{4}\\)\nneither \\(|\\uparrow\\rangle|\\downarrow\\rangle\\) nor \\(|\\downarrow\\rangle|\\uparrow\\rangle\\) are eigenstates of \\(\\vec{S}_1 \\cdot \\vec{S}_2\\).\n\\(|\\uparrow\\rangle|\\downarrow\\rangle\\)和\\(|\\downarrow\\rangle|\\uparrow\\rangle\\)都不是\\(\\vec{S}_1 \\cdot \\vec{S}_2\\)的本征态\n.. there must be linear combinations that produce eigenstates!\n因此，必须通过线性组合才能得到本征态!",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#use-symmetry",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#use-symmetry",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "Use symmetry…",
    "text": "Use symmetry…\n利用对称性…\n\\(\\vec{S}_1 \\cdot \\vec{S}_2\\) is invariant under permutation of spin 1 and spin 2.\n自旋-自旋相互作用算符在交换自旋1和自旋2时是不变的（具有交换对称性）。",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#consider",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#consider",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "Consider…",
    "text": "Consider…\n\\(\\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle)\\)\n考虑这个归一化的量子态，它是两个混合自旋态的对称叠加\n↑ normalization. 上面的系数是归一化因子",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#is-this-an-eigenstate-yes-add-a-b",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#is-this-an-eigenstate-yes-add-a-b",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "Is this an eigenstate? Yes! (Add (A) & (B))",
    "text": "Is this an eigenstate? Yes! (Add (A) & (B))\n这是否为本征态？是的！（将(A)和(B)相加）\n\\(\\vec{S}_1 \\cdot \\vec{S}_2 \\left(\\frac{|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\right) =\\)\n\\(\\left(\\frac{\\hbar^2}{2}-\\frac{\\hbar^2}{4}\\right) \\frac{|\\uparrow\\rangle|\\downarrow\\rangle}{\\sqrt{2}} + \\left(\\frac{\\hbar^2}{2}-\\frac{\\hbar^2}{4}\\right) \\frac{|\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\)\n将自旋-自旋相互作用算符作用于这个对称态，代入之前计算的结果\n\\(= \\frac{\\hbar^2}{4}\\left(\\frac{|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\right)\\)\n化简得到\n\\(\\Rightarrow \\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle)\\) is an eigenstate of \\(\\vec{S}_1 \\cdot \\vec{S}_2\\) with eigenvalue \\(\\frac{\\hbar^2}{4}\\)\n因此，这个对称叠加态确实是\\(\\vec{S}_1 \\cdot \\vec{S}_2\\)的本征态，其本征值为\\(\\frac{\\hbar^2}{4}\\)\n这部分推导表明，尽管单个混合态\\(|\\uparrow\\rangle|\\downarrow\\rangle\\)和\\(|\\downarrow\\rangle|\\uparrow\\rangle\\)不是自旋-自旋相互作用算符的本征态，但它们的对称线性组合\\(\\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle)\\)却是本征态。这个对称态在物理上有特殊意义，它是一个总自旋为1的自旋三重态的一个分量，具有与\\(|\\uparrow\\rangle|\\uparrow\\rangle\\)和\\(|\\downarrow\\rangle|\\downarrow\\rangle\\)相同的本征值\\(\\frac{\\hbar^2}{4}\\)。\n这种通过对称性原理构造本征态的方法在量子力学中非常常见且实用。上述计算展示了对称性在量子系统中的强大作用。",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第一部分基本自旋态表示",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第一部分基本自旋态表示",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "第一部分：基本自旋态表示",
    "text": "第一部分：基本自旋态表示\n\n单自旋态的定义\n\\[ |\\uparrow\\rangle = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad |\\downarrow\\rangle = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} \\]\n\n\n自旋算符作用于基态\n\\[ S_z|\\uparrow\\rangle = \\frac{\\hbar}{2}|\\uparrow\\rangle \\]\n\\[ S_z|\\downarrow\\rangle = -\\frac{\\hbar}{2}|\\downarrow\\rangle \\]\n\n\n自旋算符的矩阵表示\n\\[ S_x = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}, \\quad S_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}, \\quad S_z = \\frac{\\hbar}{2}\\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\]\n\n\n升降算符\n\\[ S_+ = S_x + iS_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix} \\]\n\\[ S_- = S_x - iS_y = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix} \\]\n\n\n升降算符的作用\n\\[ S_+|\\uparrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = 0 \\]\n\\[ S_+|\\downarrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 1 \\\\ 0 & 0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{\\hbar}{2}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{\\hbar}{2}|\\uparrow\\rangle \\]\n\\[ S_-|\\uparrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\frac{\\hbar}{2}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{\\hbar}{2}|\\downarrow\\rangle \\]\n\\[ S_-|\\downarrow\\rangle = \\frac{\\hbar}{2}\\begin{pmatrix} 0 & 0 \\\\ 1 & 0 \\end{pmatrix}\\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = 0 \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第二部分两自旋系统分析",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第二部分两自旋系统分析",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "第二部分：两自旋系统分析",
    "text": "第二部分：两自旋系统分析\n\n自旋-自旋相互作用哈密顿量\n\\[ H = J \\vec{S}_1 \\cdot \\vec{S}_2 \\]\n其中\\(J\\)是交换耦合常数，\\(\\vec{S}_1\\)和\\(\\vec{S}_2\\)是自旋-1/2量子力学算符\n\n\n两自旋系统的基态\n\\[ (|\\uparrow\\rangle|\\uparrow\\rangle, |\\uparrow\\rangle|\\downarrow\\rangle, |\\downarrow\\rangle|\\uparrow\\rangle, |\\downarrow\\rangle|\\downarrow\\rangle) \\]\n\n\n计算算符作用于\\(|\\downarrow\\rangle|\\downarrow\\rangle\\)\n\\[ \\vec{S}_1 \\cdot \\vec{S}_2 |\\downarrow\\rangle|\\downarrow\\rangle = \\left(\\frac{1}{2}(S_{1+}S_{2-} + S_{1-}S_{2+}) + S_{1z}S_{2z}\\right)|\\downarrow\\rangle|\\downarrow\\rangle = S_{1z}S_{2z}|\\downarrow\\rangle|\\downarrow\\rangle \\]\n\\[ = (S_{1z}|\\downarrow\\rangle)(S_{2z}|\\downarrow\\rangle) \\]\n\\[ = \\left(-\\frac{\\hbar}{2}|\\downarrow\\rangle\\right)\\left(-\\frac{\\hbar}{2}|\\downarrow\\rangle\\right) \\]\n\\[ = \\frac{\\hbar^2}{4}|\\downarrow\\rangle|\\downarrow\\rangle \\]\n\n\n\\(|\\uparrow\\rangle|\\downarrow\\rangle\\)是否为本征态？\n\\[ \\vec{S}_1 \\cdot \\vec{S}_2 |\\uparrow\\rangle|\\downarrow\\rangle = \\left[\\frac{1}{2}(S_{1+}S_{2-} + S_{1-}S_{2+}) + S_{1z}S_{2z}\\right]|\\uparrow\\rangle|\\downarrow\\rangle \\]\n\\[ = \\frac{1}{2}(S_{1+}|\\uparrow\\rangle)(S_{2-}|\\downarrow\\rangle) + \\frac{1}{2}(S_{1-}|\\uparrow\\rangle)(S_{2+}|\\downarrow\\rangle) + (S_{1z}|\\uparrow\\rangle)(S_{2z}|\\downarrow\\rangle) \\]\n\\[ = \\frac{1}{2}(0)(\\frac{\\hbar}{2}|\\uparrow\\rangle) + \\frac{1}{2}(\\frac{\\hbar}{2}|\\downarrow\\rangle)(0) + (\\frac{\\hbar}{2}|\\uparrow\\rangle)(-\\frac{\\hbar}{2}|\\downarrow\\rangle) \\]\n\\[ \\vec{S}_1 \\cdot \\vec{S}_2 |\\uparrow\\rangle|\\downarrow\\rangle = \\frac{\\hbar^2}{2}|\\downarrow\\rangle|\\uparrow\\rangle - \\frac{\\hbar^2}{4}|\\uparrow\\rangle|\\downarrow\\rangle \\]\n\n\n对\\(|\\downarrow\\rangle|\\uparrow\\rangle\\)的类似计算\n\\[ \\vec{S}_1 \\cdot \\vec{S}_2 |\\downarrow\\rangle|\\uparrow\\rangle = \\frac{\\hbar^2}{2}|\\uparrow\\rangle|\\downarrow\\rangle - \\frac{\\hbar^2}{4}|\\downarrow\\rangle|\\uparrow\\rangle \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第三部分利用对称性寻找本征态",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第三部分利用对称性寻找本征态",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "第三部分：利用对称性寻找本征态",
    "text": "第三部分：利用对称性寻找本征态\n\n对称性分析\n\\(\\vec{S}_1 \\cdot \\vec{S}_2\\) 在交换自旋1和自旋2时是不变的\n\n\n对称线性组合态\n\\[ \\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle) \\]\n\n\n验证是否为本征态\n\\[ \\vec{S}_1 \\cdot \\vec{S}_2 \\left(\\frac{|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\right) = \\]\n\\[ \\left(\\frac{\\hbar^2}{2}-\\frac{\\hbar^2}{4}\\right) \\frac{|\\uparrow\\rangle|\\downarrow\\rangle}{\\sqrt{2}} + \\left(\\frac{\\hbar^2}{2}-\\frac{\\hbar^2}{4}\\right) \\frac{|\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}} \\]\n\\[ = \\frac{\\hbar^2}{4}\\left(\\frac{|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\right) \\]\n确认：\\(\\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle)\\) 是 \\(\\vec{S}_1 \\cdot \\vec{S}_2\\) 的本征态，本征值为 \\(\\frac{\\hbar^2}{4}\\)\n\n\n反对称线性组合态\n\\[ \\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle - |\\downarrow\\rangle|\\uparrow\\rangle) \\]\n\n\n验证是否为本征态\n\\[ \\vec{S}_1 \\cdot \\vec{S}_2 \\left(\\frac{|\\uparrow\\rangle|\\downarrow\\rangle - |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\right) \\]\n\\[ = \\left(\\frac{\\hbar^2}{2}-\\frac{\\hbar^2}{4}\\right) \\frac{|\\uparrow\\rangle|\\downarrow\\rangle}{\\sqrt{2}} - \\left(\\frac{\\hbar^2}{2}-\\frac{\\hbar^2}{4}\\right) \\frac{|\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}} \\]\n\\[ = -\\frac{3\\hbar^2}{4}\\left(\\frac{|\\uparrow\\rangle|\\downarrow\\rangle - |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}}\\right) \\]\n确认：\\(\\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle - |\\downarrow\\rangle|\\uparrow\\rangle)\\) 是 \\(\\vec{S}_1 \\cdot \\vec{S}_2\\) 的本征态，本征值为 \\(-\\frac{3\\hbar^2}{4}\\)",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第四部分自旋三重态与单重态",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第四部分自旋三重态与单重态",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "第四部分：自旋三重态与单重态",
    "text": "第四部分：自旋三重态与单重态\n\n三重态与单重态的分类\n\\[ |t_+\\rangle = |\\uparrow\\rangle|\\uparrow\\rangle \\] \\[ |t_0\\rangle = \\frac{|\\uparrow\\rangle|\\downarrow\\rangle + |\\downarrow\\rangle|\\uparrow\\rangle}{\\sqrt{2}} \\] \\[ |t_-\\rangle = |\\downarrow\\rangle|\\downarrow\\rangle \\]\n这三个态构成三重态(triplet)\n\\[ |s\\rangle = \\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle - |\\downarrow\\rangle|\\uparrow\\rangle) \\]\n这是单重态(singlet)\n\n\n哈密顿量作用\n\\[ H|triplet\\rangle = J\\frac{\\hbar^2}{4}|triplet\\rangle \\]\n\\[ H|singlet\\rangle = -J\\frac{3\\hbar^2}{4}|singlet\\rangle \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第五部分交换耦合常数j的物理意义",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第五部分交换耦合常数j的物理意义",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "第五部分：交换耦合常数J的物理意义",
    "text": "第五部分：交换耦合常数J的物理意义\n\nJ &gt; 0 情况（铁磁耦合）\n\\[ J &gt; 0 \\]\n\\[ \\begin{array}{cc}\n\\uparrow & \\text{triplet} \\\\\n\\hbar^2J/4 & \\\\\n& \\\\\n-3\\hbar^2J/4 & \\downarrow |singlet\\rangle\n\\end{array} \\]\n\n\nJ &lt; 0 情况（反铁磁耦合）\n\\[ J &lt; 0, \\quad J = -|J| \\]\n\\[ \\begin{array}{cc}\n\\uparrow & \\text{singlet} \\\\\n-3\\hbar^2|J|/4 & \\\\\n& \\\\\n-\\hbar^2|J|/4 & \\downarrow \\text{triplet}\n\\end{array} \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第六部分量子态的纠缠特性",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#第六部分量子态的纠缠特性",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "第六部分：量子态的纠缠特性",
    "text": "第六部分：量子态的纠缠特性\n\n重要观察\n\\[ |singlet\\rangle = \\frac{1}{\\sqrt{2}}(|\\uparrow\\rangle|\\downarrow\\rangle - |\\downarrow\\rangle|\\uparrow\\rangle) \\neq |\\uparrow\\rangle|\\downarrow\\rangle \\]\n\n\n张量积表示\n\\[ |A\\otimes B\\rangle \\quad |\\psi\\rangle = \\sum_{a,b}c_{ab}|a\\rangle|b\\rangle \\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#附录量子自旋系统的重要概念解释",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.4 Spin Spin Spin.html#附录量子自旋系统的重要概念解释",
    "title": "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）",
    "section": "附录：量子自旋系统的重要概念解释",
    "text": "附录：量子自旋系统的重要概念解释\n\n自旋三重态与单重态的物理意义\n三重态（triplet）包含三个量子态，具有相同的本征值\\(\\frac{\\hbar^2}{4}\\)。三重态表现为总自旋为1的状态，\\(|t_+\\rangle\\)、\\(|t_0\\rangle\\)和\\(|t_-\\rangle\\)分别对应总自旋z分量为+1、0和-1。\n单重态（singlet）只包含一个量子态\\(|s\\rangle\\)，本征值为\\(-\\frac{3\\hbar^2}{4}\\)。单重态表现为总自旋为0的状态，两个自旋相互抵消。\n\n\n交换相互作用的物理解释\n交换常数\\(J\\)确定了自旋之间的相互作用类型： - 当\\(J &gt; 0\\)时，系统倾向于铁磁排列（自旋平行），三重态能量较低 - 当\\(J &lt; 0\\)时，系统倾向于反铁磁排列（自旋反平行），单重态能量较低\n\n\n自旋算符与泡利矩阵的关系\n自旋算符与泡利矩阵的关系可以用以下数学表达式表示：\n\\[ S_x = \\frac{\\hbar}{2}\\sigma_x \\] \\[ S_y = \\frac{\\hbar}{2}\\sigma_y \\] \\[ S_z = \\frac{\\hbar}{2}\\sigma_z \\]\n其中\\(\\sigma_x\\)、\\(\\sigma_y\\)和\\(\\sigma_z\\)是泡利矩阵：\n\\[ \\sigma_x = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\] \\[ \\sigma_y = \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix} \\] \\[ \\sigma_z = \\begin{pmatrix} 1 & 0 \\\\ 0 & -1 \\end{pmatrix} \\]\n这种关系反映了量子力学中抽象数学与物理观测量之间的深刻联系： - 泡利矩阵是无量纲的数学工具 - 自旋算符有角动量的物理单位（由\\(\\frac{\\hbar}{2}\\)提供） - 系数\\(\\frac{\\hbar}{2}\\)表明我们在处理自旋-1/2粒子\n\n\n量子纠缠的意义\n单重态\\(|s\\rangle\\)和三重态\\(|t_0\\rangle\\)都是纠缠态，无法写成单个粒子态的直积。这种量子纠缠是量子力学的核心特性，表现为一个粒子的测量会立即影响另一个粒子的状态，不论它们相距多远。\n\n\n实际应用\n海森堡模型在凝聚态物理中有广泛应用，特别是在理解磁性材料、高温超导体和量子计算中的量子比特设计方面。",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html",
    "title": "氢原子",
    "section": "",
    "text": "The hydrogen atom in classical physics consists of an electron orbiting around a proton. Let’s examine the key parameters:\n\n\n\n\n\n\n\n\n\n\n\nParticle\nProperty\nSymbol\nCharge\nValue\nUnit\n\n\n\n\nElectron\nMass\n\\(m_e\\)\n-\n\\(9.1 \\times 10^{-31}\\)\nkg\n\n\nElectron\nCharge\n\\(q_{electron}\\)\n\\(-e\\)\n\\(-1.6 \\times 10^{-19}\\)\nC\n\n\nProton\nMass\n\\(M\\)\n-\n\\(1.6 \\times 10^{-27}\\)\nkg\n\n\nProton\nCharge\n\\(q_{proton}\\)\n\\(+e\\)\n\\(+1.6 \\times 10^{-19}\\)\nC\n\n\n\nThe mass ratio \\(\\frac{M}{m_e} \\simeq 1800\\), which means we can effectively treat the proton as motionless.\n\n\nThe hydrogen atom involves two fundamental interactions: - Electromagnetic - Gravitational\nThe ratio of electric force to gravitational force is:\n\\[\\frac{\\text{Electric force}}{\\text{Gravitational force}} = \\frac{F_e}{F_g} = \\frac{\\frac{e^2}{4\\pi\\varepsilon_0 r^2}}{\\frac{GM m_e}{r^2}} = \\frac{e^2}{4\\pi\\varepsilon_0} \\frac{1}{GM m_e} \\approx 10^{39}\\]\nWhere: \\(\\frac{1}{4\\pi\\varepsilon_0} = 9 \\times 10^9 \\frac{\\text{N m}^2}{\\text{C}^2}\\)\n\\(G = 6.67 \\times 10^{-11} \\text{ m}^3 \\text{ kg}^{-1} \\text{ s}^{-2}\\)\nGiven this enormous ratio, gravitational effects can be safely ignored in atomic physics.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#经典图像-classical-picture",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#经典图像-classical-picture",
    "title": "氢原子",
    "section": "",
    "text": "The hydrogen atom in classical physics consists of an electron orbiting around a proton. Let’s examine the key parameters:\n\n\n\n\n\n\n\n\n\n\n\nParticle\nProperty\nSymbol\nCharge\nValue\nUnit\n\n\n\n\nElectron\nMass\n\\(m_e\\)\n-\n\\(9.1 \\times 10^{-31}\\)\nkg\n\n\nElectron\nCharge\n\\(q_{electron}\\)\n\\(-e\\)\n\\(-1.6 \\times 10^{-19}\\)\nC\n\n\nProton\nMass\n\\(M\\)\n-\n\\(1.6 \\times 10^{-27}\\)\nkg\n\n\nProton\nCharge\n\\(q_{proton}\\)\n\\(+e\\)\n\\(+1.6 \\times 10^{-19}\\)\nC\n\n\n\nThe mass ratio \\(\\frac{M}{m_e} \\simeq 1800\\), which means we can effectively treat the proton as motionless.\n\n\nThe hydrogen atom involves two fundamental interactions: - Electromagnetic - Gravitational\nThe ratio of electric force to gravitational force is:\n\\[\\frac{\\text{Electric force}}{\\text{Gravitational force}} = \\frac{F_e}{F_g} = \\frac{\\frac{e^2}{4\\pi\\varepsilon_0 r^2}}{\\frac{GM m_e}{r^2}} = \\frac{e^2}{4\\pi\\varepsilon_0} \\frac{1}{GM m_e} \\approx 10^{39}\\]\nWhere: \\(\\frac{1}{4\\pi\\varepsilon_0} = 9 \\times 10^9 \\frac{\\text{N m}^2}{\\text{C}^2}\\)\n\\(G = 6.67 \\times 10^{-11} \\text{ m}^3 \\text{ kg}^{-1} \\text{ s}^{-2}\\)\nGiven this enormous ratio, gravitational effects can be safely ignored in atomic physics.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#原子大小估计-estimate-of-typical-atom-size",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#原子大小估计-estimate-of-typical-atom-size",
    "title": "氢原子",
    "section": "4.2.2 原子大小估计 (Estimate of Typical Atom Size)",
    "text": "4.2.2 原子大小估计 (Estimate of Typical Atom Size)\nUsing the uncertainty principle, we can estimate the size of the hydrogen atom.\nConsider an electron in a spherical cage of radius \\(a\\):\nThe electrostatic interaction energy is:\n\\[\\text{Electrostatic interaction} = -\\frac{e^2}{4\\pi\\varepsilon_0 a}\\]\nThis energy varies as \\(\\frac{1}{a}\\) and decreases with distance.\nThe kinetic energy due to quantum uncertainty is approximately:\n\\[\\text{Kinetic energy} \\sim \\frac{(\\hbar/a)^2}{2m_e}\\]\nThis energy varies as \\(\\frac{1}{a^2}\\) and increases as the confinement gets tighter.\nThe total energy is the sum of these contributions:\n\\[E(a) = \\frac{\\hbar^2}{2m_e a^2} - \\frac{e^2}{4\\pi\\varepsilon_0 a}\\]\nAt equilibrium, the energy is minimized, so:\n\\[E'(a) = -\\frac{\\hbar^2}{m_e a^3} + \\frac{e^2}{4\\pi\\varepsilon_0 a^2} = 0\\]\nSolving for \\(a\\), we get the Bohr radius:\n\\[a_B = \\frac{4\\pi\\varepsilon_0 \\hbar^2}{m_e e^2} \\simeq 0.5 \\times 10^{-10} \\text{ m} = 0.5 \\text{ Å}\\]\nThis \\(a_B\\) is the natural length scale of the atom.\nInterestingly, the Bohr radius is about 100,000 times larger than the size of the proton (\\(\\sim 10^{-15} \\text{ m}\\)). To put this in perspective, if the proton were scaled to about 1 inch, then the typical size of the atom would be scaled to about 1.5 miles. This illustrates the vast “emptiness” within atoms.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#氢原子的结合能-binding-energy-of-the-h-atom",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#氢原子的结合能-binding-energy-of-the-h-atom",
    "title": "氢原子",
    "section": "4.2.3 氢原子的结合能 (Binding Energy of the H Atom)",
    "text": "4.2.3 氢原子的结合能 (Binding Energy of the H Atom)\nSubstituting \\(a_B\\) into the energy expression \\(E(a)\\), we can estimate the binding energy of the hydrogen atom:\n\\[E_1 = \\frac{\\hbar^2}{2m_e a_B^2} - \\frac{e^2}{4\\pi\\varepsilon_0 a_B}\\]\n\\[\\frac{E_1}{a_B} = \\frac{\\hbar^2}{2m_e a_B^3} - \\frac{e^2}{4\\pi\\varepsilon_0 a_B^2} = \\frac{\\hbar^2}{2m_e a_B^3} - \\frac{\\hbar^2}{m_e a_B^3} = -\\frac{\\hbar^2}{2m_e a_B^3}\\]\n\\[E_1 = -\\frac{\\hbar^2}{2m_e a_B^2} = -\\frac{1}{2} \\frac{\\hbar^2}{m_e} \\left(\\frac{m_e e^2}{4\\pi\\varepsilon_0 \\hbar^2}\\right)^2 = -\\frac{m_e}{2\\hbar^2} \\left(\\frac{e^2}{4\\pi\\varepsilon_0}\\right)^2\\]\nSubstituting the values of these parameters:\n\\[E_1 = -13.6 \\text{ eV}\\]\nThis means that to make the electron “break free” from the proton, an energy of approximately 13.6 eV must be supplied.\nIs this energy “big” or “small”? To gauge this, let’s compare it with the thermal energy \\(k_B T\\) at room temperature.\nThe Boltzmann constant: \\(k_B = 8.617 \\times 10^{-5} \\text{ eV/K}\\) (Boltzmann constant)\nAt room temperature (\\(T_{room} \\simeq 300 \\text{ K}\\)):\n\\[k_B T_{room} \\simeq 25 \\times 10^{-3} \\text{ eV} = 25 \\text{ meV}\\]\nSince \\(k_B T_{room} \\ll |E_1|\\), the probability of unbinding the electron due to thermal excitation at room temperature is negligible.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#能级和光子发射-energy-levels-and-photon-emission",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#能级和光子发射-energy-levels-and-photon-emission",
    "title": "氢原子",
    "section": "4.2.4 能级和光子发射 (Energy Levels and Photon Emission)",
    "text": "4.2.4 能级和光子发射 (Energy Levels and Photon Emission)\nQuantum mechanics shows that the hydrogen atom has discrete energy levels. These can be categorized as:\n\nContinuum states (\\(E &gt; 0\\)): These represent unbound electrons.\nBound states (\\(E &lt; 0\\)): These are the discrete energy levels of the hydrogen atom.\n\nThe bound states include: - Ground state (\\(E_1\\)): The lowest energy level - Excited states (\\(E_2\\), \\(E_3\\), etc.): Higher energy levels\nWhen an electron transitions from a higher energy level to a lower one, a photon is emitted: \\(E_m - E_n = E_\\gamma\\)\nThis is known as photon absorption (when the atom absorbs energy) or photon emission (when the atom releases energy).\nAccording to the Einstein-Planck relation:\n\\[E_\\gamma = h\\nu = \\frac{hc}{\\lambda}\\]\nwhere: \\(h\\nu = \\Delta E, \\quad \\lambda = \\frac{hc}{\\Delta E}\\)\nGiven: \\(h = 4.13 \\times 10^{-15} \\text{ eV} \\cdot \\text{sec}\\) \\(c = 3 \\times 10^8 \\text{ m/sec}\\) \\(hc \\simeq 1.24 \\times 10^{-6} \\text{ eV} \\cdot \\text{m} = 1.24 \\times 10^3 \\text{ eV} \\cdot \\text{nm} \\simeq 1239 \\text{ eV} \\cdot \\text{nm}\\)\nFor the hydrogen atom, with \\(\\Delta E = 13.6 \\text{ eV}\\), the photon wavelength is: \\(\\lambda \\simeq 91 \\text{ nm}\\) (UV light)",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#相对论效应是否重要-are-relativistic-effects-important",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#相对论效应是否重要-are-relativistic-effects-important",
    "title": "氢原子",
    "section": "4.2.5 相对论效应是否重要? (Are Relativistic Effects Important?)",
    "text": "4.2.5 相对论效应是否重要? (Are Relativistic Effects Important?)\nThe energy of a free relativistic particle of mass \\(m\\) and momentum \\(\\vec{p}\\) is:\n\\[E = \\sqrt{(\\vec{p}c)^2 + (mc^2)^2} = mc^2 \\left(1 + \\left(\\frac{pc}{mc^2}\\right)^2\\right)^{1/2}\\]\nUsing the binomial expansion:\n\\[E \\simeq mc^2 \\left[1 + \\frac{1}{2}\\left(\\frac{pc}{mc^2}\\right)^2 + \\ldots\\right] = mc^2 + \\frac{p^2}{2m} + \\text{relativistic corrections}\\]\nWhen \\(\\frac{p^2}{2m_e} \\ll mc_e^2\\), the non-relativistic treatment is valid.\nLet’s check this for the electron in hydrogen: \\(m_e c^2 = 9.1 \\times 10^{-31} \\text{ kg} \\times (3 \\times 10^8 \\text{ m/s})^2 \\simeq 0.5 \\times 10^6 \\text{ eV} = 0.5 \\text{ MeV}\\)\nSince this is much larger than the few eV scale of atomic energies, the non-relativistic approach is justified.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#薛定谔方程-schrödinger-equation",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.2 Hydrogen Atom.html#薛定谔方程-schrödinger-equation",
    "title": "氢原子",
    "section": "4.2.6 薛定谔方程 (Schrödinger Equation)",
    "text": "4.2.6 薛定谔方程 (Schrödinger Equation)\nAll in all, the effective theory is described by the non-relativistic Schrödinger equation:\n\\[\\left(-\\frac{\\hbar^2}{2m_e} \\nabla^2 - \\frac{e^2}{4\\pi\\varepsilon_0 r}\\right) \\Psi(\\vec{r}) = E \\Psi(\\vec{r})\\]\nWith rotational symmetry, we can write: \\(\\Psi(r,\\theta,\\phi) = R(r)Y_\\ell^m(\\theta,\\phi)\\)\nThe radial equation, with \\(u(r) = r R(r)\\), becomes:\n\\[-\\frac{\\hbar^2}{2m_e} \\frac{d^2u}{dr^2} + \\left[-\\frac{e^2}{4\\pi\\varepsilon_0 r} + \\frac{\\hbar^2 \\ell(\\ell+1)}{2m_e r^2}\\right]u = Eu\\]\nWe will solve this equation for \\(E &lt; 0\\) to determine the bound states of the hydrogen atom.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "氢原子"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第一章/index.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第一章/index.html",
    "title": "第一章",
    "section": "",
    "text": "Three quantum indeterminacy position:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第一章"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/index.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/index.html",
    "title": "Lecture",
    "section": "",
    "text": "4.1 三维空间的薛定谔方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.1 经典氢原子 (Classical Hydrogen Atom)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3.1 量子数 (Quantum Numbers)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThree quantum indeterminacy position:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n氢原子\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第一章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第四章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/index.html",
    "href": "content/notes/计算/Julia科学计算笔记/index.html",
    "title": "Julia科学计算笔记",
    "section": "",
    "text": "Lecture Review: Julia & Git\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSummary of Key Julia Codes and Algorithms by Chapter\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/1. 基本语法.html",
    "href": "content/notes/计算/Julia科学计算笔记/1. 基本语法.html",
    "title": "Summary of Key Julia Codes and Algorithms by Chapter",
    "section": "",
    "text": "Summary of Key Julia Codes and Algorithms by Chapter\nThis document summarizes the main ideas, codes, and algorithms from the provided PDF. Each section begins with the high-level purpose of the chapter and ends with code snippets and algorithmic highlights. Citations point back to the relevant parts of the PDF for further reading.\n\n\n0. Hello, \\(\\pi\\) ! Julia as a second programming language\nContext: The opening chapter introduces Julia as a modern, dynamic language and demonstrates how to set up the REPL, manage packages, and write a small program to compute \\(\\pi\\). The emphasis is on exploring the language environment and using Julia to perform simple tasks.\n\nInstalling and working with Julia - The notes recommend using juliaup for installation. Within the REPL, pressing ? enters help mode and ] enters package mode, allowing you to add or update packages. The author suggests creating a ~/.julia/config/startup.jl file to automatically load useful packages like Revise, BenchmarkTools and OhMyREPL. The startup file checks whether the session is interactive before importing these packages.\n\n# ~/.julia/config/startup.jl\nif isinteractive()\n    try\n        using Revise # auto-reload modules on change\n        using BenchmarkTools # easy performance measurement\n        using OhMyREPL # colorized and enhanced REPL\n    catch\n        @warn \"Failed to load interactive tools!\"\n    end\nend\n\nHello \\(\\boldsymbol{\\pi}\\) script - A simple Julia program prints a formatted value of \\(\\boldsymbol{\\pi}\\). This script illustrates how to write and run Julia code from a file and how to import a module (Printf ) from the standard library.\n\n# helloPi.jl\n# Prints an approximation of \\pi to six decimal places\nusing Printf\n@printf \"\\pi \\approx %.6f\\n\" \\pi\nSave the file as helloPi.jl and run it with julia helloPi.jl. You can also load code into a session using \\(\\square\\) include(“helloPi.jl”) If using Revise, \\(\\square\\) includet(“helloPi.jl”) automatically reloads the file on changes.\n\nStarting with the REPL - The REPL supports modes for help ( ? ), package management ( ] ), shell commands \\(\\_\\_\\_\\_\\) ), and Julia execution. Take advantage of tab completion and help mode to explore functions, and use the package manager to install tools as needed.\n\n\n\n2. Variables, primitive types, and functions\nPurpose: This chapter introduces Julia’s type system, variables, operators, and functions. You learn how Julia’s dynamic typing works, how to annotate types, how functions are defined, and how to write loops or vectorized code.\n\nVariables and type annotations - Julia variables are dynamically typed: their type is inferred from the value on the right. Type annotations can convert or constrain a value. For instance, the annotation \\(\\square\\) : :Float64 converts the result on the right-hand side to a 64-bit float:\n\na::Float64 = 1 + 3 # a becomes 4.0 of type Float64\nb = 2 + 1im # complex numbers are supported\nc = \"Hello\" * \"!\" # * concatenates strings, not +\nd = 2 * acos(0) # numerical approximation of }\nNote: Julia uses * for string concatenation and exponentiation only accepts integer exponents on integers; non-integer exponents yield floating-point results.\n\nDefining functions - Functions can be defined in one line or multiple lines. For example, to compute \\(f(x)=2 \\cos ^{-1}(x)\\) you can write:\n\nf(x) = 2 * acos(x)\n# or equivalently\nfunction f(x)\n    return 2 * acos(x)\nend\n\nApproximating \\(\\boldsymbol{\\pi}\\) via Machin’s formula - Machin’s identity allows \\(\\boldsymbol{\\pi}\\) to be written in terms of arctangent values. The notes provide a function to approximate arctan by truncating its Taylor series and then use it to compute \\(\\pi\\) :\n\n# approximate_atan(x, n) returns the nth-order approximation of arctan(x)\nfunction approximate_atan(x, n)\n    sum = 0.0\n    for k in 0:(n - 1)\n        term = (-1)^k * x^(2k + 1) / (2k + 1)\n        sum += term\n    end\n    return sum\nend\nfunction estimate_pi(n)\n    # Machin's formula: \\pi/4 = 4*arctan(1/5) - arctan(1/239)\n    atan1 = approximate_atan(1/5, n)\n    atan2 = approximate_atan(1/239, n)\n    pi_est = 4 * (4 * atan1 - atan2)\n    return pi_est\nend\nLarger \\(n\\) increases accuracy but increases computation time. Using loops like this demonstrates Julia’s pass-by-sharing semantics: arrays and mutable objects passed to functions can be modified inside, but numbers and immutable objects cannot.\n\nHigher-order functions and broadcasting - Functions in Julia are first-class. You can store them in arrays and apply them to values using loops or broadcasting:\n\nsquare(x) = x^2\ncube(x) = x^3\nfuncs = [square, cube, x -&gt; x^4]\nvalues = [1, 2, 3]\n# Apply each function to each value\nfor f in funcs\n    println([f(v) for v in values])\nend\nBroadcasting with the dot syntax applies functions elementwise to collections. For example, sin. (values) computes the sine of each element, and [f.(values) for \\(f\\) in funcs] computes arrays of results.\n\n\n3. Composite types and data structures\nContext: Julia’s power comes from its rich set of built-in data structures (arrays, dictionaries, sets) and from defining your own types. This chapter explains how to organize data and write efficient numerical algorithms.\n\nTuples and arrays - Tuples are immutable ordered collections (e.g., (1, 1.0, “wow” )), and indexing is 1-based. Arrays (vectors and matrices) are mutable and typed; homogeneous arrays are faster. The functions sort (returns a sorted copy) and sort! (mutates in place) exemplify Julia’s convention of appending ! to functions that mutate their arguments.\nBroadcasting and vectorization - The dot (.) syntax performs elementwise operations: a . +1 adds 1 to every element of vector a , and g. (a) applies the scalar function g to each element. Broadcasting avoids explicit loops and is often faster and more readable.\nIteration and comprehensions - Julia uses ranges ( \\(1: 5\\) ) and the range function to iterate. Comprehensions build new collections succinctly; for example, collect(1:0.25:1.5) builds an array of equally spaced numbers, and \\(\\left[x^{\\wedge} 2\\right.\\) for \\(x\\) in \\(\\left.1: 5\\right]\\) squares integers 1 through 5 . When iterating over arrays or dictionaries, use eachindex(array) for performance or keys(dict)/ values(dict) for associative collections.\nDefining new types - Use struct for immutable composite types and mutable struct for mutable ones. Fields should be typed for performance, and parametric types allow flexibility. For instance, a particle with a position and mass can be defined as:\n\nstruct Particle\n    mass::Float64\n    charge::Float64\n    funny_name::String\nend\nmutable struct ParticlePosition{T}\n    x::T; y::T; z::T\nend\n\nExample: polygon geometry - A custom type PolygonVertex holds the coordinates of a vertex. A specialized constructor builds a vertex from a polar angle, and methods overload subtraction to measure distances. The perimeter of an n-gon can then be computed using different styles:\n\nstruct PolygonVertex\n    x::Float64\n    y::Float64\nend\n# Construct from an angle 0 on the unit circle\nPolygonVertex(0) = PolygonVertex(cos(莗), sin(麦)\n# Define subtraction between vertices\nBase.:-(v1::PolygonVertex, v2::PolygonVertex) =\n    PolygonVertex(v1.x - v2.x, v1.y - v2.y)\n# Euclidean norm for a vertex\nnorm(v::PolygonVertex) = sqrt(v.x^2 + v.y^2)\n# Compute perimeter by looping over edges\nfunction calculate_perimeter(vertices::Vector{PolygonVertex})\n    L = length(vertices)\n    perimeter = 0.0\n    for i in 1:L\n        v1 = vertices[i]\n        v2 = vertices[mod1(i+1, L)] # circular indexing\n        perimeter += norm(v1 - v2)\n    end\n    return perimeter\nend\n# More expressive versions using circshift and mapreduce are given in the notes.\n\nArchimedes’ method (doubling polygons) - To approximate \\(\\pi\\), Archimedes’ method iteratively doubles the number of polygon sides and updates the side length using the half-angle formula. Using BigInt and BigFloat allows arbitrary precision:\n\nfunction archimedes_pi(iterations)\n    # start with a hexagon inscribed in a unit circle\n    n = BigInt(6)\n    side = BigFloat(sqrt(3)) # side length for hexagon\n    for _ in 1:iterations\n        # update side length for 2n-gon\n        side = sqrt(2 - sqrt(4 - side^2))\n        n *= 2\n    end\n    return n * side / 2 # perimeter/2 approximates }\nend\n\nDocumenting functions - Julia supports docstrings written between triple quotes above a definition. Use sections such as # Arguments, # Returns, and # Examples to clarify usage. For instance:\n\n\"\"\"\nperimeter_by_mapreduce(vertices)\nComputes the perimeter of a polygon using `mapreduce`.\n# Arguments\n* `vertices::Vector{PolygonVertex}`: list of vertices in order.\n# Returns\n* `Float64`: the perimeter of the polygon.\n# Examples\n```julia\nvertices = [PolygonVertex(0), PolygonVertex(\\pi/2), PolygonVertex(\\pi)]\nperimeter_by_mapreduce(vertices) # expected \\approx 3.14159\n““” function perimeter_by_mapreduce(vertices) # implementation here end “”\n\n\n4. Data, plots, and visualization\nPurpose: This chapter discusses reading and writing data, generating random samples, and visualizing results. It culminates in a Monte Carlo estimation of \\(\\pi\\) and introduces Julia’s plotting ecosystem.\n\nRandom point generation - Functions to generate points uniformly in a square of side \\(L\\) and to collect a list of such points are defined as:\n\n# Generate one point in a square of side L\ngenerate_point(L) = (rand() * L, rand() * L)\n# Generate n random points\nfunction scatter_points(n, box_side)\n    return [generate_point(box_side) for _ in 1:n]\nend\n\nFile I/O - Write data using open (filename, “w”) do io … end and println or write to output. Read files with open(filename, ” \\(r\\) “) do io … end , eachline(io) for line iteration, or read(io, String) for the full contents. For matrices, the DelimitedFiles module provides writedlm and readdlm:\n\nusing DelimitedFiles\ndata = [1 2 3; 4 5 6]\nwritedlm(\"data.csv\", data, ',')\nmat = readdlm(\"data.csv\", ',')\n\nPlotting with Makie - Julia’s plotting libraries separate the front-end API from the back-end renderer. After installing CairoMakie or GLMakie, you can create 2D scatter plots and annotate them. The notes show how to visualize Monte Carlo samples inside and outside the unit circle:\n\nusing CairoMakie\n# predicate: is a point inside the unit circle?\nin_unit_circle(p) = (p[1]^2 + p[2]^2) &lt;= 1\n# generate points\npts = scatter_points(5000, 1.0)\nin_pts = [Point2f(p...) for p in pts if in_unit_circle(p)]\nout_pts = [Point2f(p...) for p in pts if !in_unit_circle(p)]\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"x\", ylabel = \"y\", aspect = 1)\nscatter!(ax, in_pts, color = :darkorange, markersize = 2)\nscatter!(ax, out_pts, color = :slateblue, markersize = 2)\n# draw the unit circle\n0 = range(0, 2\\pi, length=200)\ncircle = [Point2f(cos(t), sin(t)) for t in 0]\npoly!(ax, circle, color = (:white, 0), strokewidth = 1, strokecolor = :black)\nfig\n\nMonte Carlo estimation of \\(\\boldsymbol{\\pi}\\) - The proportion of points inside the unit circle (scaled by 4) approximates \\(\\pi\\). Two functions implement this approach:\n\n# return the proportion of points inside the unit circle\nfunction unit_circle_proportion(points)\n    count = 0\n    for p in points\n        if p[1]^2 + p[2]^2 &lt;= 1\n            count += 1\n        end\n    end\n    return count / length(points)\nend\n# run n trials with m points each and return the mean estimate of \\pi\nusing Statistics\nfunction estimate_pi(m, n)\n    estimates = Float64[]\n    for _ in 1:n\n        pts = scatter_points(m, 1.0)\n        prop = unit_circle_proportion(pts)\n        push!(estimates, 4 * prop)\n    end\n    return mean(estimates), var(estimates)\nend\nFor improved performance, preallocate arrays and use an in-place generate_point! function to avoid memory allocations.\n\nBenchmarking - Use the @btime and @benchmark macros from BenchmarkTools to measure run time and memory allocations. Wrap the code in a function before benchmarking to avoid global scope slowdowns. For example:\n\nusing BenchmarkTools\n@btime estimate_pi(1_000, 20)\n\n\n5. Projects, parametric types, and multiple dispatch\nPurpose: The final chapter shows how to structure a larger project in Julia, manage dependencies, test your code, define parametric and abstract types, and leverage multiple dispatch. It culminates with a playful algorithm for computing \\(\\pi\\) by counting collisions.\n\nCreating packages and modules - Use Julia’s package manager to generate a new project:\n\nusing Pkg\nPkg.generate(\"EventDrivenMolecularDynamics\")\nThis creates a folder containing a Project.toml file (listing dependencies) and a src directory with a EventDrivenMolecularDynamics.jl module. Activate the environment by starting Julia in that directory or with ] activate . . Editing the module inside src/ defines functions and types for your simulation. Use Revise to automatically reload changes.\n\nTesting - Place tests in the test directory, typically in a file called runtests.jl. Group tests with @testset and write expectations using @test. For approximate comparisons use the \\(\\approx\\) operator with an optional tolerance:\n\nusing Test\n@testset \"Area calculation\" begin\n    @test abs(compute_area(2.0) - 3.14159) &lt; 1e-5\n    @test isapprox(compute_area(2.0), 3.1415926; atol = 1e-7)\nend\n\nParametric and abstract types - Parametric types allow data structures to be generic over element types and dimensions. For example:\n\nmutable struct ParticlePosition{T}\n    x::T; y::T; z::T\nend\nstruct Particle{D,T}\n    position::NTuple{D, T}\n    velocity::NTuple{D, T}\n    mass::T\n    radius::T\nend\nabstract type AbstractObstacle{D,T} end\nstruct Hyperplane{D,T} &lt;: AbstractObstacle{D,T}\n    normal::NTuple{D, T}\n    offset::T\nend\nstruct SphericalObstacle{D,T} &lt;: AbstractObstacle{D,T}\n    center::NTuple{D, T}\n    radius::T\nend\nAbstract types let you define method hierarchies and make code extensible without specifying all implementation details.\n\nMultiple dispatch - Julia dispatches on all argument types, making it straightforward to define functions that behave differently for different combinations of types. For instance, define collisions between particles and obstacles:\n\n# Two particles collide and both change state\nfunction collision(p1::Particle{D,T}, p2::Particle{D,T}) where {D,T}\n    # compute new positions and velocities (omitted)\n    return new_p1, new_p2\nend\n\"\"\"particles colliding with obstacles reflect velocity\"\"\"\nfunction collision(p::Particle{D,T}, o::AbstractObstacle{D,T}) where {D,T}\n    new_vel = -p.velocity\n    new_particle = Particle{D,T}(p.position, new_vel, p.mass, p.radius)\n    return new_particle, o\nend\n# handle reversed argument order by delegating\ncollision(o::AbstractObstacle{D,T}, p::Particle{D,T}) where {D,T} =\n    let new_particle, new_obstacle = collision(p, o)\n        (new_obstacle, new_particle)\n    end\nThe where \\(\\{\\mathrm{D}, \\mathrm{T}\\}\\) clause exposes the type parameters for specialization. Defining functions outside the original type definitions makes the system composable, enabling extension without modifying base types.\n\nCounting collisions to compute \\(\\boldsymbol{\\pi}\\) - A creative algorithm shows that the number of elastic collisions in a mass-ratio billiards problem encodes digits of \\(\\pi\\). You set up two particles and an immovable wall, then count collisions until the fast particle escapes. A parametric System{D, T} type holds the state, and a function pi_from_pool returns the total number of collisions:\n\nmutable struct System{D,T}\n    particles::Vector{Particle{D,T}}\n    obstacles::Vector{AbstractObstacle{D,T}}\n    total_collisions::Int64\n    current_time::Float64\nend\nfunction pi_from_pool(mass_ratio::Float64)\n    s = pool_pi_initialization(mass_ratio) # initialize positions & velocities\n    time_to_next_collision = 0.0\n    while time_to_next_collision != Inf\n        time_to_next_collision = evolve_step!(s)\n    end\n    return s.total_collisions\nend\nRunning this function with different mass ratios reveals successive digits of \\(\\pi\\) in the total collision count:\n\n\n\nmass ratio\ncollisions\napproximation of \\(\\pi\\)\n\n\n\n\n1\n3\n3\n\n\n100\n31\n3.1\n\n\n\\(10^{4}\\)\n314\n3.14\n\n\n\\(10^{6}\\)\n3141\n3.141\n\n\n\\(10^{8}\\)\n31415\n3.1415\n\n\n\\(10^{16}\\)\n314159265\n3.14159265\n\n\n\nThis result is both a fun demonstration of multiple dispatch and an example of how physical modeling and programming can produce surprising results.\n\nAdditional resources - The notes recommend consulting the official Julia documentation, the Julia Discourse, and books such as Think Julia and Practical Julia for deeper study.\n\nThese chapter summaries highlight the important codes and algorithms introduced in the notes. Use them as a reference while exploring Julia further and as a foundation for building more sophisticated numerical and scientific programs.",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Summary of Key Julia Codes and Algorithms by Chapter"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/index.html",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/index.html",
    "title": "强化学习",
    "section": "",
    "text": "Agent\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMarkov奖励&决策过程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html",
    "title": "Markov奖励&决策过程",
    "section": "",
    "text": "Goal: construct an algorithms for computing decision policies, where more iteration \\(\\to\\) monotonically improve the decision policy. ## 1.1 Return The return, denoted as \\(G_{t}\\), is the (discounted) sum of rewards received from time \\(t\\) to horizon \\(H\\). ### 1.1.1 Discount Factor The primary purpose of discount factor \\(\\gamma\\in[0,1]\\) is to weights future rewards: - ensures convergence for infinite sum - controls immediate rewards (\\(\\gamma=0\\)) vs. delayed rewards (\\(\\gamma \\to 1\\)) ### 1.1.1 Horizon Infinite-horizon: \\[\n\\begin{aligned}\nG_t &= \\sum_{k=0}^{\\infty} \\gamma^k r_{t+k}\n\\end{aligned}\n\\] Finite-horizon (episode length \\(H\\)):\nFor \\(H\\) steps included, we have: \\[\\begin{aligned}\nG_t &= r_t + \\gamma r_{t+1} + \\gamma^2 r_{t+2} + \\cdots + \\gamma^{H-1} r_{t+H-1} \\\\\n    &= \\sum_{k=0}^{H-1} \\gamma^k r_{t+k}.\n\\end{aligned}\n\\] &gt; Horizon → determines which rewards you sum → defines the return\n\n\n\n[!definition|1.2] State Value Function The state-value function under policy \\({} \\pi(a|s) {}\\) is the expected return starting from state \\(s\\) : \\[\nV^\\pi(s)=\\mathbb{E}_\\pi\\left[G_t \\mid s_t=s\\right]=\\mathbb{E}_\\pi\\left[\\sum_{k=0}^{\\infty} \\gamma^k r_{t+k} \\mid s_t=s\\right]\n\\]\n\nIf using a finite horizon \\(H\\), we replace the infinite sum by \\(G_{t}=\\sum_{k=0}^{H-1} \\gamma^k r_{t+k}\\), that is: \\[\n\\begin{aligned}\nV(s)&=\\mathbb{E}\\left[\\sum_{k=0}^{H-1} \\gamma^k r_{t+k} \\mid s_t=s\\right] \\\\\n&=\\mathbb{E}\\left[r_t+\\gamma r_{t+1}+\\gamma^2 r_{t+2}+\\cdots+\\gamma^{H-1} r_{t+H-1} \\mid s_t=s\\right] \\\\\n\\end{aligned}\n\\]\n\n\n\\[\n\\begin{aligned}\nV(s) & =\\mathbb{E}\\left[\\sum_{k=0}^{\\infty} \\gamma^k r_{t+k} \\mid s_t=s\\right] \\\\\n& =\\mathbb{E}\\left[r_t \\mid s_t=s\\right]+\\gamma \\mathbb{E}\\left[\\sum_{k=0}^{\\infty} \\gamma^k r_{t+1+k} \\mid s_t=s\\right] \\\\\n& =R(s)+\\gamma \\mathbb{E}\\left[V\\left(s_{t+1}\\right) \\mid s_t=s\\right] \\\\\n& =R(s)+\\gamma \\sum_{s^{\\prime}} P\\left(s^{\\prime} \\mid s\\right) V\\left(s^{\\prime}\\right)\n\\end{aligned}\n\\] where \\(R(s)=\\mathbb{E}[r_{t}|s_{t}=s]\\). Therefore, in this formulation, we have: &gt; [!theorem|1.2.1] Bellman Expectation Equation &gt;The state-value function \\(V: \\mathcal{S} \\rightarrow \\mathbb{R}\\) is the unique function satisfying, for every \\(s \\in \\mathcal{S}\\), &gt;\\[V(s)=\\underbrace{R(s)}_{\\text{Immediate reward }}+\\underbrace{\\gamma \\sum_{s^{\\prime} \\in S} P\\left(s^{\\prime} \\mid s\\right) V\\left(s^{\\prime}\\right)}_{\\text {Discounted sum of future rewards }}\\]\n\n\n\nWe can solve this equation explicitly: \\[\n\\begin{aligned}\nV & =R+\\gamma P V \\\\\nV-\\gamma P V & =R \\\\\n(I-\\gamma P) V & =R \\\\\nV & =(I-\\gamma P)^{-1} R\n\\end{aligned}\n\\] However, computing inverse requires \\(O(N^3)\\) + invertible, so we use iterative algorithm (fixed point method) for computing value of a MRP:\n\nInitialize \\(V_0(s)=0\\) for all \\(s\\)\nFor \\(k=1\\) until convergence\nFor all \\(s\\) in \\(S\\)\n\n\\[\n\\begin{aligned}\nV_k(s)&=R+\\gamma PV_{k-1}\\\\\n&=R(s)+\\gamma \\sum_{s^{\\prime} \\in S} P\\left(s^{\\prime} \\mid s\\right) V_{k-1}\\left(s^{\\prime}\\right)\n\\end{aligned}\n\\] Computational complexity: \\(O\\left(|S|^2\\right)\\) for each iteration \\((|S|=N)\\)",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Markov奖励&决策过程"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html#state-value-function-vs",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html#state-value-function-vs",
    "title": "Markov奖励&决策过程",
    "section": "",
    "text": "[!definition|1.2] State Value Function The state-value function under policy \\({} \\pi(a|s) {}\\) is the expected return starting from state \\(s\\) : \\[\nV^\\pi(s)=\\mathbb{E}_\\pi\\left[G_t \\mid s_t=s\\right]=\\mathbb{E}_\\pi\\left[\\sum_{k=0}^{\\infty} \\gamma^k r_{t+k} \\mid s_t=s\\right]\n\\]\n\nIf using a finite horizon \\(H\\), we replace the infinite sum by \\(G_{t}=\\sum_{k=0}^{H-1} \\gamma^k r_{t+k}\\), that is: \\[\n\\begin{aligned}\nV(s)&=\\mathbb{E}\\left[\\sum_{k=0}^{H-1} \\gamma^k r_{t+k} \\mid s_t=s\\right] \\\\\n&=\\mathbb{E}\\left[r_t+\\gamma r_{t+1}+\\gamma^2 r_{t+2}+\\cdots+\\gamma^{H-1} r_{t+H-1} \\mid s_t=s\\right] \\\\\n\\end{aligned}\n\\]\n\n\n\\[\n\\begin{aligned}\nV(s) & =\\mathbb{E}\\left[\\sum_{k=0}^{\\infty} \\gamma^k r_{t+k} \\mid s_t=s\\right] \\\\\n& =\\mathbb{E}\\left[r_t \\mid s_t=s\\right]+\\gamma \\mathbb{E}\\left[\\sum_{k=0}^{\\infty} \\gamma^k r_{t+1+k} \\mid s_t=s\\right] \\\\\n& =R(s)+\\gamma \\mathbb{E}\\left[V\\left(s_{t+1}\\right) \\mid s_t=s\\right] \\\\\n& =R(s)+\\gamma \\sum_{s^{\\prime}} P\\left(s^{\\prime} \\mid s\\right) V\\left(s^{\\prime}\\right)\n\\end{aligned}\n\\] where \\(R(s)=\\mathbb{E}[r_{t}|s_{t}=s]\\). Therefore, in this formulation, we have: &gt; [!theorem|1.2.1] Bellman Expectation Equation &gt;The state-value function \\(V: \\mathcal{S} \\rightarrow \\mathbb{R}\\) is the unique function satisfying, for every \\(s \\in \\mathcal{S}\\), &gt;\\[V(s)=\\underbrace{R(s)}_{\\text{Immediate reward }}+\\underbrace{\\gamma \\sum_{s^{\\prime} \\in S} P\\left(s^{\\prime} \\mid s\\right) V\\left(s^{\\prime}\\right)}_{\\text {Discounted sum of future rewards }}\\]\n\n\n\nWe can solve this equation explicitly: \\[\n\\begin{aligned}\nV & =R+\\gamma P V \\\\\nV-\\gamma P V & =R \\\\\n(I-\\gamma P) V & =R \\\\\nV & =(I-\\gamma P)^{-1} R\n\\end{aligned}\n\\] However, computing inverse requires \\(O(N^3)\\) + invertible, so we use iterative algorithm (fixed point method) for computing value of a MRP:\n\nInitialize \\(V_0(s)=0\\) for all \\(s\\)\nFor \\(k=1\\) until convergence\nFor all \\(s\\) in \\(S\\)\n\n\\[\n\\begin{aligned}\nV_k(s)&=R+\\gamma PV_{k-1}\\\\\n&=R(s)+\\gamma \\sum_{s^{\\prime} \\in S} P\\left(s^{\\prime} \\mid s\\right) V_{k-1}\\left(s^{\\prime}\\right)\n\\end{aligned}\n\\] Computational complexity: \\(O\\left(|S|^2\\right)\\) for each iteration \\((|S|=N)\\)",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Markov奖励&决策过程"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html#policy",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html#policy",
    "title": "Markov奖励&决策过程",
    "section": "2.1 Policy",
    "text": "2.1 Policy\nPolicy \\(\\pi\\) specifies what action to take in each state \\(s\\): - can be deterministic or stochastic - a probability distribution over action given a state\n\n[!definition|2.1] Policy (π) A (stationary Markov) policy is a map \\[\\pi:\\mathcal S\\to \\Delta(\\mathcal A),\\qquad\\pi(a\\mid s)=P(a_t=a\\mid s_t=s)\n\\]\n\n\n2.1.1 Relation between MDP abd MRP\n\\[\\operatorname{MDP}+ \\operatorname{policy}=\\operatorname{MRP}\\left(S, R^\\pi, P^\\pi, \\gamma\\right)\\] where \\[\\begin{aligned}\nR^\\pi(s) & =\\sum_{a \\in A} \\pi(a \\mid s) R(s, a) \\\\\nP^\\pi\\left(s^{\\prime} \\mid s\\right) & =\\sum_{a \\in A} \\pi(a \\mid s) P\\left(s^{\\prime} \\mid s, a\\right)\n\\end{aligned}\\] By this relation, we then can find Bellman backup for a particular policy \\(\\pi\\) : $$\n\\[\\begin{aligned}\nV_k^\\pi(s)&=\\qquad\\qquad\\quad\\;\\;\nR^\\pi(s)+\\gamma \\sum_{s^{\\prime} \\in S} P^\\pi\\left(s^{\\prime} \\mid s\\right) V^\\pi_{k-1}\\left(s^{\\prime}\\right)\\\\\n\n&=\\sum_a \\pi(a \\mid s)\\left[R(s, a)+\\gamma \\sum_{s^{\\prime}}p\\left(s^{\\prime} \\mid s, a\\right) V_{k-1}^\\pi\\left(s^{\\prime}\\right)\\right]\n\\end{aligned}\\]\n\\[\nIf $\\pi$ is *deterministic*, then $\\pi(a \\mid s)=1$, thus $\\pi(s)=a$:\n\\]\n\\[\\begin{aligned}\nV_k^\\pi(s)\n&= \\sum_{a} \\mathbf 1\\{a=\\pi(s)\\}\\,\\Big[\\,R(s,a) + \\gamma \\sum_{s'} p(s'\\mid s,a)\\,V_{k-1}^\\pi(s')\\Big] \\\\\n&= R\\big(s,\\pi(s)\\big) \\;+\\; \\gamma \\sum_{s'} p\\big(s'\\mid s,\\pi(s)\\big)\\,V_{k-1}^\\pi(s').\n\\end{aligned}\\]\n$$",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Markov奖励&决策过程"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html#mdp-control-evaluation",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/2. Markov奖励&决策过程.html#mdp-control-evaluation",
    "title": "Markov奖励&决策过程",
    "section": "3. MDP Control & Evaluation",
    "text": "3. MDP Control & Evaluation\n\noptimal policy: not necessarily\noptimal value function: yes, and unique ### Policy Optimality We compute the optimal policy: \\[\\pi^*(s)=\\arg \\max _\\pi V^\\pi(s)\\] ### Policy search",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Markov奖励&决策过程"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/4. Transformer.html",
    "href": "content/notes/理论/概率机器学习/4. Transformer.html",
    "title": "Erise Note",
    "section": "",
    "text": "Autoregressive models factorize the joint distribution into conditionals and can be implemented in several ways:\n\n\n\n\n\n\n\n\n\nModel Type\nExample Architectures\nParallel Training\nParameter Sharing\n\n\n\n\nRecurrent\nRNN, LSTM\n❌ No\n✅ Yes\n\n\nMasked MLP\nMADE (Masked Autoencoder for Dist.)\n✅ Yes\n❌ No\n\n\nMasked CNN / Transformer\nPixelCNN, Transformer, Linear Attention\n✅ Yes\n✅ Yes\n\n\n\n\nParallel training: Can multiple time steps be computed at once?\n\nParameter sharing: Do different positions reuse the same parameters? # Transformer Architecture",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Models"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/4. Transformer.html#autoregressive-models",
    "href": "content/notes/理论/概率机器学习/4. Transformer.html#autoregressive-models",
    "title": "Erise Note",
    "section": "",
    "text": "Autoregressive models factorize the joint distribution into conditionals and can be implemented in several ways:\n\n\n\n\n\n\n\n\n\nModel Type\nExample Architectures\nParallel Training\nParameter Sharing\n\n\n\n\nRecurrent\nRNN, LSTM\n❌ No\n✅ Yes\n\n\nMasked MLP\nMADE (Masked Autoencoder for Dist.)\n✅ Yes\n❌ No\n\n\nMasked CNN / Transformer\nPixelCNN, Transformer, Linear Attention\n✅ Yes\n✅ Yes\n\n\n\n\nParallel training: Can multiple time steps be computed at once?\n\nParameter sharing: Do different positions reuse the same parameters? # Transformer Architecture",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Models"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/2. Autoregressive模型.html",
    "href": "content/notes/理论/概率机器学习/2. Autoregressive模型.html",
    "title": "Erise Note",
    "section": "",
    "text": "An AR (autoregressive) generative model represents the joint probability of a sequence by chaining conditionals left-to-right (the chain rule \\[P\\left(w_{1: T}\\right)=\\prod_{t=1}^T P\\left(w_t \\mid w_{&lt;t}\\right)\\] ## 0. Probability Distributions (recap)\nA generative model is a probability distribution \\(p_\\theta\\) meant to approximate the true (unknown) data distribution \\(p_{\\text{data}}\\).\nExplicit density models (e.g., autoregressive models) support both tasks. Implicit models (e.g., GANs) emphasize sampling but typically do not provide tractable \\(p_\\theta(x)\\).",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "0. Probability Distributions (recap)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/2. Autoregressive模型.html#probability-recap-notation-constraints",
    "href": "content/notes/理论/概率机器学习/2. Autoregressive模型.html#probability-recap-notation-constraints",
    "title": "Erise Note",
    "section": "2. Probability Recap (Notation & Constraints)",
    "text": "2. Probability Recap (Notation & Constraints)\n\nDiscrete: \\(X\\in\\{1,\\dots,K\\}\\), \\(P(X=i)=p_i\\), \\(\\sum_i p_i=1\\).\nContinuous: \\(p(x)\\ge 0\\), \\(\\int p(x)\\,dx=1\\).\nMultivariate: \\(p(\\mathbf{x})=p(x_1,\\dots,x_d)\\).\n\nHigh-dimensional joint distributions (e.g., images with \\(10^5\\)–\\(10^6\\) pixels) are combinatorially huge, motivating structured factorizations.\n\n2.1 Conditional Probability\nThe definition of conditional probability for events is \\[\n\\boxed{P(A \\mid B)=\\frac{P(A \\cap B)}{P(B)}}\n\\] and equivalently, the “product rule”: \\[P(A \\cap B)=P(A \\mid B) P(B)=P(B \\mid A) P(A)\\] ### 2.2 Joint distribution\nJoint distribution can be written as the product of conditionals, that is: \\[\n\\begin{aligned}\np(x_1, x_2, \\dots, x_n)\n&= p(x_1)\\, p(x_2, \\dots, x_n \\mid x_1) \\\\\n&= p(x_1)\\, p(x_2 \\mid x_1)\\, p(x_3, \\dots, x_n \\mid x_1, x_2) \\\\\n&= p(x_1)\\, p(x_2 \\mid x_1)\\, p(x_3 \\mid x_1, x_2)\\, p(x_4, \\dots, x_n \\mid x_1, x_2, x_3) \\\\\n&\\;\\;\\vdots \\\\\n&= \\prod_{i=1}^n p(x_i \\mid x_1, \\dots, x_{i-1}).\n\\end{aligned}\n\\] ## 3. Autoregressive (AR) Factorization via the Chain Rule\nFor a token sequence \\(Y=(w_1,\\dots,w_T)\\), the chain rule gives \\[\nP(Y) \\;=\\; P(w_1,\\dots,w_T)\n\\;=\\; \\prod_{t=1}^{T} P\\!\\big(w_t \\mid w_{&lt;t}\\big)\n\\] where \\(w_{&lt;t}:=(w_{1,\\dots}w_{t-1})\\). In other words, for any \\(T \\geq 2\\), \\[\n\\boxed{\n\\begin{aligned}\np\\!\\left(w_{1:T}\\right)\n&= p\\left(w_T \\mid w_{&lt;T}\\right)\\, p\\left(w_{&lt;T}\\right) \\\\\n&= p\\left(w_T \\mid w_{&lt;T}\\right)\\, p\\left(w_{T-1} \\mid w_{&lt;T-1}\\right)\\, p\\left(w_{&lt;T-1}\\right) \\\\\n&\\;\\;\\vdots \\\\\n&= \\prod_{t=1}^T p\\!\\left(w_t \\mid w_{&lt;t}\\right)\n\\end{aligned}\n}\n\\] An autoregressive (AR) model chooses a direction/order (here: left-to-right) and parametrizes each conditional: \\[\np_\\theta\\!\\big(w_t \\mid w_{&lt;t}\\big) \\;=\\; \\operatorname{Softmax}\\!\\big(Wh_{t-1}+b\\big),\n\\quad h_{t-1} \\;=\\; f_\\theta(e_1,\\dots,e_{t-1}),\n\\] where \\(e_t\\) are token embeddings. Because each factor is a proper distribution, the product is normalized—giving an exact likelihood.\n\nOrder matters. AR models require a fixed order; for text we use left→right, but any total order (e.g., pixels in a raster scan) is valid. ## 4. Training = Density Estimation (Maximum Likelihood)\n\n\n\n4.1 Entropy\nThe entropy of a probability distribution can be interpreted as a measure of uncertainty, or lack of predictability, associated with a random variable drawn from a given distribution. We can also use entropy to define the information content of a data source.\nDefinition (theoretical) for population entropy (discrete) of a discrete distribution \\(p\\) is: \\[\n\\boxed{\\begin{aligned}\nH(p) &\\triangleq-\\sum_x p(x) \\log p(x)\\\\&=-\\mathbb{E}_X\\left[\\log  p(X)\\right]\n\\end{aligned}}\n\\] ### 4.2 Cross-Entropy\nDefinition (theoretical) for population cross-entropy between data \\(p\\) and model \\(q\\) is:​ \\[\\boxed{H(p, q) \\triangleq-\\sum_x p(x) \\log q(x)}\\] And the empirical estimator (what we compute on data \\(\\left\\{w_1, \\ldots, w_N\\right\\}\\) ) for AR model becomes \\[\n\\boxed{H(\\hat{p},q)=-\\frac{1}{N} \\sum_{t=1}^N \\log q\\left(w_t \\mid w_{&lt;t}\\right)}\n\\] - \\(N\\): number of tokens in the test sequence\n- \\(w_t\\): the \\(t\\)-th token\n- \\(w_{&lt;t}\\): all tokens before position \\(t\\)\n- \\(q(w_t \\mid w_{&lt;t})\\): the probability assigned by the model\nGiven a dataset \\(\\mathcal D=\\{Y^{(n)}\\}_{n=1}^N\\), maximum likelihood estimation (MLE) maximizes \\[\n\\mathcal{L}(\\theta)\n= \\sum_{n=1}^N \\log q\\big(Y^{(n)}\\big)\n= \\sum_{n=1}^N \\sum_{t=1}^{T^{(n)}} \\log q\\big(w^{(n)}_t \\mid w^{(n)}_{&lt;t}\\big).\n\\] Equivalently, we minimize next-token cross-entropy: \\[\n\\underbrace{-\\frac{1}{N}\\sum_{n,t} \\log q\\big(w^{(n)}_t \\mid w^{(n)}_{&lt;t}\\big)}_{\\text{empirical NLL}}\n\\quad\\Longleftrightarrow\\quad\n\\text{CrossEntropy}(p, q).\n\\] ### 4.3 Kullback–Leibler divergence For a true next-token data distribution \\(p\\) and model prediction \\(q\\), the definition for KL divergence is: \\[\n\\boxed{D_{\\mathrm{KL}}\\left(p \\| q\\right)=\\sum_x p(x) \\log \\frac{p(x)}{q(x)} \\geq 0}\n\\] - \\(H(p)\\) : entropy of the true distribution (constant w.r.t. the model) - \\(D_{\\mathrm{KL}}(p \\| q)\\) : penalty for how far \\(q\\) is from \\(p\\)\nand \\(D_{KL} =0 \\Longleftrightarrow p=q \\text { (almost everywhere) }\\). The identity linking all three is: \\[\n\\boxed{H(p,q) \\;=\\; H(p) + D_{\\mathrm{KL}}(p\\!\\parallel q)}\n\\] Since \\(H(p)\\) is independent of \\(q\\), minimizing cross-entropy (and perplexity) is equivalent to minimizing \\(D_{\\mathrm{KL}}(p\\parallel q)\\). ### 4.4 Perplexity Perplexity (PP) of a model is the exponential of the cross-entropy: \\[\n\\boxed{\\text{PP}(q) = \\exp\\!\\Big(H(p,q)\\Big)\n= \\exp\\!\\left(-\\frac{1}{N}\\sum_{t=1}^N \\log q(w_t \\mid w_{&lt;t})\\right)}\n\\] - Perplexity can be understood as the effective average branching factor of the model.\n- A lower perplexity means the model is less “perplexed” → better predictions.\n- A higher perplexity means the model is more “confused” → worse predictions.\nExamples: - Perfect model → \\(\\text{PP} = 1\\)\n- Uniform distribution over \\(V\\) tokens → \\(\\text{PP} = V\\) ## 5. Inference = Sampling / Generation (Left-to-Right)\nTo generate text:\n\nStart from a beginning-of-sequence token \\(\\langle\\mathrm{bos}\\rangle\\) (or a prompt).\nFor \\(t=1,2,\\dots\\): draw \\(w_t \\sim p_\\theta(\\cdot \\mid w_{&lt;t})\\).\nStop at \\(\\langle\\mathrm{eos}\\rangle\\) or a length limit.\n\n\n\n5.1 Decoding Strategies\n\nGreedy (argmax): \\(w_t=\\arg\\max_v p_\\theta(v\\mid w_{&lt;t})\\). Deterministic; can be bland.\nRandom sampling: sample from \\(p_\\theta(\\cdot\\mid\\cdot)\\) directly.\nTemperature: rescale logits/probabilities by \\(1/T\\) before sampling; \\(T&lt;1\\) sharper, \\(T&gt;1\\) more diverse.\nTop-\\(k\\): restrict to the \\(k\\) most probable tokens, renormalize, then sample.\nNucleus (top-\\(p\\)): choose the smallest set \\(S\\) such that \\(\\sum_{v\\in S} p_\\theta(v\\mid\\cdot)\\ge p\\); sample within \\(S\\).\nBeam search: approximate \\(\\arg\\max_Y p_\\theta(Y)\\) by expanding the \\(B\\) best partial hypotheses.",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "0. Probability Distributions (recap)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/2. Autoregressive模型.html#why-ar-models-are-attractive",
    "href": "content/notes/理论/概率机器学习/2. Autoregressive模型.html#why-ar-models-are-attractive",
    "title": "Erise Note",
    "section": "6. Why AR Models are Attractive",
    "text": "6. Why AR Models are Attractive\n\nExact likelihood. Each conditional is normalized → tractable training and evaluation (perplexity, NLL).\nSimple sampling. Left-to-right draws match the factorization.\nFlexible function class. Conditionals \\(p_\\theta(w_t\\mid w_{&lt;t})\\) can be parameterized by RNNs, LSTMs/GRUs, Transformers, etc.\n\nTrade-off: Sampling is sequential—inherently less parallel than feed-forward decoders (but see practical accelerations such as speculative decoding; beyond this lecture’s scope).\n\n\n6.1 AR vs. Other Generative Families\n\nAR (explicit): exact likelihood; slow sampling.\nNormalizing flows (explicit): exact likelihood; fast sampling; invertibility constraints.\nVAEs (explicit latent): tractable lower bounds on likelihood; amortized inference.\nGANs (implicit): high-fidelity samples; no tractable likelihood (density estimation not available). ## 9. Minimal Derivations (Collected)\n\n\n\n9.1 Chain Rule for Sequences\n\\[\n\\begin{aligned}\nP(w_1,\\dots,w_T)\n&= P(w_1)\\,P(w_2\\mid w_1)\\cdots P(w_T\\mid w_{&lt;T}) \\\\\n&= \\prod_{t=1}^T P(w_t\\mid w_{&lt;t}).\n\\end{aligned}\n\\]",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "0. Probability Distributions (recap)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/index.html",
    "href": "content/notes/理论/微分几何/index.html",
    "title": "微分几何",
    "section": "",
    "text": "0. Recap from Last lecture\n\n\n\n\n\n\n\n\n2025年9月8日\n\n\n\n\n\n\n\n\n\n\n\n\n1. From Calculus to Manifolds\n\n\n\n\n\n\n\n\n2025年8月27日\n\n\n\n\n\n\n\n\n\n\n\n\n1. Parametrized curves in \\(\\mathbb{R}^3\\) (plane curves as a special case)\n\n\n\n\n\n\n\n\n2025年9月3日\n\n\n\n\n\n\n\n\n\n\n\n\n1.1 Smooth map and its differential (push-forward)\n\n\n\n\n\n\n\n\n2025年9月15日\n\n\n\n\n\n\n\n\n\n\n\n\nParametrized Curves in \\(\\mathbb{R}^3\\)\n\n\n\n\n\n\n\n\n2025年9月3日\n\n\n\n\n\n\n\n\n\n\n\n\nT-n Levels of Separation Axiom\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "微分几何"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html",
    "href": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html",
    "title": "More Examples & Curvature",
    "section": "",
    "text": "Let \\(\\psi:S\\to \\tilde S\\) be a smooth map between surfaces. For \\(p\\in S\\), the differential (pushforward) of \\(\\psi\\) at \\(p\\) is the linear map \\[\nd\\psi_p:T_pS\\longrightarrow T_{\\psi(p)}\\tilde S .\n\\] Viewing tangent vectors as derivations, for \\(X\\in T_pS\\) and \\(f\\in C^\\infty(\\tilde S)\\), \\[\n\\boxed{\\,d\\psi_p(X)\\cdot f \\;=\\; X(f\\circ \\psi)\\, } .\n\\]\nEquivalently, if \\(\\gamma(0)=p\\) and \\(X=\\dot\\gamma(0)\\), then \\[\nd\\psi_p(X) \\;=\\; \\frac{d}{dt}\\Big|_{t=0}\\big(\\psi\\circ\\gamma\\big)(t).\n\\] ## 1.2 Pullback of a metric (first fundamental form)\nLet \\(\\tilde g\\) be a Riemannian metric on \\(\\tilde S\\). The pullback metric \\(\\psi^*\\tilde g\\) on \\(S\\) is defined by \\[\n\\boxed{\\,(\\psi^*\\tilde g)_p(X,Y)\\;=\\;\\tilde g_{\\psi(p)}\\!\\big(d\\psi_p X,\\; d\\psi_p Y\\big),\\qquad X,Y\\in T_pS \\, }.\n\\] (When \\(S,\\tilde S\\subset\\mathbb R^3\\) are embedded surfaces with the Euclidean inner product, this coincides with the classical first fundamental form.) ## 1.3 Local isometry We say \\(\\psi\\) is a local isometry iff it preserves the lengths of all (sufficiently short) curves. Writing curve length with a metric \\(g\\), \\[\nL_g(\\gamma)=\\int_a^b \\sqrt{\\,g_{\\gamma(t)}(\\dot\\gamma(t),\\dot\\gamma(t))\\,}\\;dt\n\\] we have \\[\n\\begin{aligned}\nL_{\\tilde g}(\\psi\\circ\\gamma)\n&=\\int_a^b \\sqrt{\\,\\tilde g_{\\psi(\\gamma(t))}\\!\\big(d\\psi_{\\gamma(t)}\\dot\\gamma(t),\\,d\\psi_{\\gamma(t)}\\dot\\gamma(t)\\big)}\\;dt\\\\\n&=\\int_a^b \\sqrt{\\,(\\psi^*\\tilde g)_{\\gamma(t)}\\!\\big(\\dot\\gamma(t),\\dot\\gamma(t)\\big)}\\;dt\n\\end{aligned}\n\\] Hence lengths are preserved for all curves iff \\(g=\\psi^*\\tilde g\\): \\[\n\\boxed{\\,\\psi\\ \\text{is a local isometry}\\;\\Longleftrightarrow\\; g=\\psi^*\\tilde g\\, }\n\\] ## 1.4 Example: helicoid \\(\\longleftrightarrow\\) catenoid\n\n\n\nHelicoid \\(S\\): \\(r(\\rho,t)=(\\rho\\cos t,\\;\\rho\\sin t,\\;t)\\).\nCatenoid \\(\\tilde S\\): \\(\\tilde r(z,\\theta)=(\\cosh z\\cos\\theta,\\;\\cosh z\\sin\\theta,\\;z)\\).\n\n\n\n\nHelicoid: \\[\n\\begin{aligned}\nr_\\rho&=(\\cos t,\\ \\sin t,\\ 0),&\nr_t&=(-\\rho\\sin t,\\ \\rho\\cos t,\\ 1),\\\\\nE&=\\langle r_\\rho,r_\\rho\\rangle=1,\\quad\nF=\\langle r_\\rho,r_t\\rangle=0,\\quad\nG=\\langle r_t,r_t\\rangle=1+\\rho^2.\n\\end{aligned}\n\\] Thus, \\[\n\\boxed{\\,ds^2=d\\rho^{\\,2}+(1+\\rho^2)\\,dt^{\\,2}\\, }.\n\\] Catenoid: \\[\n\\begin{aligned}\n\\tilde r_z&=(\\sinh z\\cos\\theta,\\ \\sinh z\\sin\\theta,\\ 1),&\n\\tilde r_\\theta&=(-\\cosh z\\sin\\theta,\\ \\cosh z\\cos\\theta,\\ 0),\\\\\n\\tilde E&=\\langle \\tilde r_z,\\tilde r_z\\rangle=\\sinh^2 z+1=\\cosh^2 z,\\\\\n\\tilde F&=\\langle \\tilde r_z,\\tilde r_\\theta\\rangle=0,\\qquad\n\\tilde G=\\langle \\tilde r_\\theta,\\\\tilde r_\\theta\\rangle=\\cosh^2 z.\n\\end{aligned}\n\\] Thus\n\\[\n\\boxed{\\,d\\tilde s^{\\,2}=\\cosh^2 z\\,(dz^{\\,2}+d\\theta^{\\,2})\\, }.\n\\]\n\n\n\nDefine \\[\n\\boxed{\\,\\psi:S\\to\\tilde S,\\qquad \\psi(\\rho,t)=(z,\\theta)=(\\operatorname{arsinh}\\rho,\\ t)\\, }.\n\\] Useful identities: \\[\n\\cosh^2(\\operatorname{arsinh}\\rho)=1+\\rho^2,\\qquad\nd(\\operatorname{arsinh}\\rho)=\\frac{d\\rho}{\\sqrt{1+\\rho^2}}.\n\\] Pull back the catenoid metric: \\[\n\\begin{aligned}\n\\psi^*(d\\tilde s^{\\,2})\n&=\\cosh^2\\!\\big(\\operatorname{arsinh}\\rho\\big)\\,\\Big(d(\\operatorname{arsinh}\\rho)^{2}+dt^{\\,2}\\Big)\\\\\n&=(1+\\rho^2)\\left(\\frac{d\\rho^{\\,2}}{1+\\rho^2}+dt^{\\,2}\\right)\\\\\n&=d\\rho^{\\,2}+(1+\\rho^2)\\,dt^{\\,2}.\n\\end{aligned}\n\\] Since this equals the helicoid’s first fundamental form, we conclude \\[\n\\boxed{\\,\\psi^*(d\\tilde s^{\\,2})=ds^2\\quad\\Longrightarrow\\quad \\psi\\ \\text{is a local isometry}\\, }\n\\] ### 1.4.3 Chain-rule detail (as on the board)\nStarting from \\(\\rho=\\sinh z\\),\n\\[\n\\begin{aligned}\nd\\rho&=\\cosh z\\,dz,\\\\\ndz&=\\frac{d\\rho}{\\cosh z}=\\frac{d\\rho}{\\sqrt{1+\\rho^2}},\\\\\ndz^{\\,2}&=\\frac{1}{1+\\rho^2}\\,d\\rho^{\\,2}.\n\\end{aligned}\n\\] Plugging these into \\(d\\tilde s^{\\,2}=\\cosh^2 z(dz^{\\,2}+d\\theta^{\\,2})\\) with \\(z=\\operatorname{arsinh}\\rho,\\ \\theta=t\\) gives the same pullback as above. # Surface Area Element from the First Fundamental Form\nLet \\(\\sigma:U\\subset\\mathbb{R}^2\\to S\\subset\\mathbb{R}^3\\) be a regular patch with local coordinates \\((u^1,u^2)=(u,v)\\). Write \\[\n\\sigma_1=\\frac{\\partial\\sigma}{\\partial u},\\qquad\n\\sigma_2=\\frac{\\partial\\sigma}{\\partial v},\n\\] and let \\(g\\) be the (induced) metric on \\(S\\). Denote \\(g_{ij}=g(\\sigma_i,\\sigma_j)\\) (so in \\(\\mathbb{R}^3\\) with the Euclidean inner product, \\(g_{ij}=\\langle\\sigma_i,\\sigma_j\\rangle\\)). ## 2.1 Area via the cross product (calculus recall)\nFor a surface patch, the infinitesimal area is \\[\ndA=\\|\\sigma_1\\times\\sigma_2\\|\\,du\\,dv .\n\\] ### 2.2.1 Expressing \\(dA\\) with the first fundamental form Let \\(\\theta=\\angle(\\sigma_1,\\sigma_2)\\). Then \\[\n\\begin{aligned}\n\\|\\sigma_1\\times\\sigma_2\\|^2\n&=\\|\\sigma_1\\|^2\\|\\sigma_2\\|^2\\sin^2\\theta\n=\\|\\sigma_1\\|^2\\|\\sigma_2\\|^2(1-\\cos^2\\theta)\\\\\n&=\\|\\sigma_1\\|^2\\|\\sigma_2\\|^2-\\langle\\sigma_1,\\sigma_2\\rangle^2\\\\\n&=g_{11}\\,g_{22}-g_{12}^2\n=\\det\\!\\begin{pmatrix} g_{11}&g_{12}\\\\ g_{12}&g_{22}\\end{pmatrix}.\n\\end{aligned}\n\\] Therefore \\[\n\\boxed{\\,dA=\\sqrt{g_{11}g_{22}-g_{12}^2}\\;du\\,dv\n=\\sqrt{\\det(g_{ij})}\\;du\\,dv\\, }.\n\\] Equivalently, if we set the classical coefficients \\(E=g_{11},\\,F=g_{12},\\,G=g_{22}\\), then \\[\ndA=\\sqrt{EG-F^2}\\;du\\,dv.\n\\] ### 2.2.2 Coordinate-invariance check\nAlthough the matrix \\(g_{ij}\\) depends on the chosen coordinates, the \\(2\\)-form \\(dA\\) does not. Under a change of parameters \\((u,v)\\mapsto(\\tilde u,\\tilde v)\\) with Jacobian \\(J=\\left(\\frac{\\partial(u,v)}{\\partial(\\tilde u,\\tilde v)}\\right)\\), \\[\n\\begin{aligned}\n(g_{ij}) &\\longmapsto (g'_{ij})=J^\\top (g_{ij})\\,J,\\\\[2pt]\n\\det(g'_{ij})&=\\det(J^\\top)\\det(g_{ij})\\det(J)=(\\det J)^2\\det(g_{ij}),\\\\[2pt]\n\\sqrt{\\det(g'_{ij})}\\,d\\tilde u\\,d\\tilde v\n&=|\\det J|\\,\\sqrt{\\det(g_{ij})}\\,d\\tilde u\\,d\\tilde v\n=\\sqrt{\\det(g_{ij})}\\,du\\,dv,\n\\end{aligned}\n\\] so \\(\\boxed{\\,dA\\ \\text{is independent of the coordinate chart.}\\,}\\) ## 2.2 Definition of Area \\[\n\\boxed{\\,dA=\\|\\sigma_1\\times\\sigma_2\\|\\,du\\,dv\n=\\sqrt{\\det(g_{ij})}\\,du\\,dv\n=\\sqrt{EG-F^2}\\,du\\,dv\\,}\n\\] Where \\(g_{ij}=g(\\sigma_i,\\sigma_j)\\) (or \\(E=\\langle\\sigma_u,\\sigma_u\\rangle,\\ F=\\langle\\sigma_u,\\sigma_v\\rangle,\\ G=\\langle\\sigma_v,\\sigma_v\\rangle\\)).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1.1 Smooth map and its differential (push-forward)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#smooth-map-and-its-differential-push-forward",
    "href": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#smooth-map-and-its-differential-push-forward",
    "title": "More Examples & Curvature",
    "section": "",
    "text": "Let \\(\\psi:S\\to \\tilde S\\) be a smooth map between surfaces. For \\(p\\in S\\), the differential (pushforward) of \\(\\psi\\) at \\(p\\) is the linear map \\[\nd\\psi_p:T_pS\\longrightarrow T_{\\psi(p)}\\tilde S .\n\\] Viewing tangent vectors as derivations, for \\(X\\in T_pS\\) and \\(f\\in C^\\infty(\\tilde S)\\), \\[\n\\boxed{\\,d\\psi_p(X)\\cdot f \\;=\\; X(f\\circ \\psi)\\, } .\n\\]\nEquivalently, if \\(\\gamma(0)=p\\) and \\(X=\\dot\\gamma(0)\\), then \\[\nd\\psi_p(X) \\;=\\; \\frac{d}{dt}\\Big|_{t=0}\\big(\\psi\\circ\\gamma\\big)(t).\n\\] ## 1.2 Pullback of a metric (first fundamental form)\nLet \\(\\tilde g\\) be a Riemannian metric on \\(\\tilde S\\). The pullback metric \\(\\psi^*\\tilde g\\) on \\(S\\) is defined by \\[\n\\boxed{\\,(\\psi^*\\tilde g)_p(X,Y)\\;=\\;\\tilde g_{\\psi(p)}\\!\\big(d\\psi_p X,\\; d\\psi_p Y\\big),\\qquad X,Y\\in T_pS \\, }.\n\\] (When \\(S,\\tilde S\\subset\\mathbb R^3\\) are embedded surfaces with the Euclidean inner product, this coincides with the classical first fundamental form.) ## 1.3 Local isometry We say \\(\\psi\\) is a local isometry iff it preserves the lengths of all (sufficiently short) curves. Writing curve length with a metric \\(g\\), \\[\nL_g(\\gamma)=\\int_a^b \\sqrt{\\,g_{\\gamma(t)}(\\dot\\gamma(t),\\dot\\gamma(t))\\,}\\;dt\n\\] we have \\[\n\\begin{aligned}\nL_{\\tilde g}(\\psi\\circ\\gamma)\n&=\\int_a^b \\sqrt{\\,\\tilde g_{\\psi(\\gamma(t))}\\!\\big(d\\psi_{\\gamma(t)}\\dot\\gamma(t),\\,d\\psi_{\\gamma(t)}\\dot\\gamma(t)\\big)}\\;dt\\\\\n&=\\int_a^b \\sqrt{\\,(\\psi^*\\tilde g)_{\\gamma(t)}\\!\\big(\\dot\\gamma(t),\\dot\\gamma(t)\\big)}\\;dt\n\\end{aligned}\n\\] Hence lengths are preserved for all curves iff \\(g=\\psi^*\\tilde g\\): \\[\n\\boxed{\\,\\psi\\ \\text{is a local isometry}\\;\\Longleftrightarrow\\; g=\\psi^*\\tilde g\\, }\n\\] ## 1.4 Example: helicoid \\(\\longleftrightarrow\\) catenoid\n\n\n\nHelicoid \\(S\\): \\(r(\\rho,t)=(\\rho\\cos t,\\;\\rho\\sin t,\\;t)\\).\nCatenoid \\(\\tilde S\\): \\(\\tilde r(z,\\theta)=(\\cosh z\\cos\\theta,\\;\\cosh z\\sin\\theta,\\;z)\\).\n\n\n\n\nHelicoid: \\[\n\\begin{aligned}\nr_\\rho&=(\\cos t,\\ \\sin t,\\ 0),&\nr_t&=(-\\rho\\sin t,\\ \\rho\\cos t,\\ 1),\\\\\nE&=\\langle r_\\rho,r_\\rho\\rangle=1,\\quad\nF=\\langle r_\\rho,r_t\\rangle=0,\\quad\nG=\\langle r_t,r_t\\rangle=1+\\rho^2.\n\\end{aligned}\n\\] Thus, \\[\n\\boxed{\\,ds^2=d\\rho^{\\,2}+(1+\\rho^2)\\,dt^{\\,2}\\, }.\n\\] Catenoid: \\[\n\\begin{aligned}\n\\tilde r_z&=(\\sinh z\\cos\\theta,\\ \\sinh z\\sin\\theta,\\ 1),&\n\\tilde r_\\theta&=(-\\cosh z\\sin\\theta,\\ \\cosh z\\cos\\theta,\\ 0),\\\\\n\\tilde E&=\\langle \\tilde r_z,\\tilde r_z\\rangle=\\sinh^2 z+1=\\cosh^2 z,\\\\\n\\tilde F&=\\langle \\tilde r_z,\\tilde r_\\theta\\rangle=0,\\qquad\n\\tilde G=\\langle \\tilde r_\\theta,\\\\tilde r_\\theta\\rangle=\\cosh^2 z.\n\\end{aligned}\n\\] Thus\n\\[\n\\boxed{\\,d\\tilde s^{\\,2}=\\cosh^2 z\\,(dz^{\\,2}+d\\theta^{\\,2})\\, }.\n\\]\n\n\n\nDefine \\[\n\\boxed{\\,\\psi:S\\to\\tilde S,\\qquad \\psi(\\rho,t)=(z,\\theta)=(\\operatorname{arsinh}\\rho,\\ t)\\, }.\n\\] Useful identities: \\[\n\\cosh^2(\\operatorname{arsinh}\\rho)=1+\\rho^2,\\qquad\nd(\\operatorname{arsinh}\\rho)=\\frac{d\\rho}{\\sqrt{1+\\rho^2}}.\n\\] Pull back the catenoid metric: \\[\n\\begin{aligned}\n\\psi^*(d\\tilde s^{\\,2})\n&=\\cosh^2\\!\\big(\\operatorname{arsinh}\\rho\\big)\\,\\Big(d(\\operatorname{arsinh}\\rho)^{2}+dt^{\\,2}\\Big)\\\\\n&=(1+\\rho^2)\\left(\\frac{d\\rho^{\\,2}}{1+\\rho^2}+dt^{\\,2}\\right)\\\\\n&=d\\rho^{\\,2}+(1+\\rho^2)\\,dt^{\\,2}.\n\\end{aligned}\n\\] Since this equals the helicoid’s first fundamental form, we conclude \\[\n\\boxed{\\,\\psi^*(d\\tilde s^{\\,2})=ds^2\\quad\\Longrightarrow\\quad \\psi\\ \\text{is a local isometry}\\, }\n\\] ### 1.4.3 Chain-rule detail (as on the board)\nStarting from \\(\\rho=\\sinh z\\),\n\\[\n\\begin{aligned}\nd\\rho&=\\cosh z\\,dz,\\\\\ndz&=\\frac{d\\rho}{\\cosh z}=\\frac{d\\rho}{\\sqrt{1+\\rho^2}},\\\\\ndz^{\\,2}&=\\frac{1}{1+\\rho^2}\\,d\\rho^{\\,2}.\n\\end{aligned}\n\\] Plugging these into \\(d\\tilde s^{\\,2}=\\cosh^2 z(dz^{\\,2}+d\\theta^{\\,2})\\) with \\(z=\\operatorname{arsinh}\\rho,\\ \\theta=t\\) gives the same pullback as above. # Surface Area Element from the First Fundamental Form\nLet \\(\\sigma:U\\subset\\mathbb{R}^2\\to S\\subset\\mathbb{R}^3\\) be a regular patch with local coordinates \\((u^1,u^2)=(u,v)\\). Write \\[\n\\sigma_1=\\frac{\\partial\\sigma}{\\partial u},\\qquad\n\\sigma_2=\\frac{\\partial\\sigma}{\\partial v},\n\\] and let \\(g\\) be the (induced) metric on \\(S\\). Denote \\(g_{ij}=g(\\sigma_i,\\sigma_j)\\) (so in \\(\\mathbb{R}^3\\) with the Euclidean inner product, \\(g_{ij}=\\langle\\sigma_i,\\sigma_j\\rangle\\)). ## 2.1 Area via the cross product (calculus recall)\nFor a surface patch, the infinitesimal area is \\[\ndA=\\|\\sigma_1\\times\\sigma_2\\|\\,du\\,dv .\n\\] ### 2.2.1 Expressing \\(dA\\) with the first fundamental form Let \\(\\theta=\\angle(\\sigma_1,\\sigma_2)\\). Then \\[\n\\begin{aligned}\n\\|\\sigma_1\\times\\sigma_2\\|^2\n&=\\|\\sigma_1\\|^2\\|\\sigma_2\\|^2\\sin^2\\theta\n=\\|\\sigma_1\\|^2\\|\\sigma_2\\|^2(1-\\cos^2\\theta)\\\\\n&=\\|\\sigma_1\\|^2\\|\\sigma_2\\|^2-\\langle\\sigma_1,\\sigma_2\\rangle^2\\\\\n&=g_{11}\\,g_{22}-g_{12}^2\n=\\det\\!\\begin{pmatrix} g_{11}&g_{12}\\\\ g_{12}&g_{22}\\end{pmatrix}.\n\\end{aligned}\n\\] Therefore \\[\n\\boxed{\\,dA=\\sqrt{g_{11}g_{22}-g_{12}^2}\\;du\\,dv\n=\\sqrt{\\det(g_{ij})}\\;du\\,dv\\, }.\n\\] Equivalently, if we set the classical coefficients \\(E=g_{11},\\,F=g_{12},\\,G=g_{22}\\), then \\[\ndA=\\sqrt{EG-F^2}\\;du\\,dv.\n\\] ### 2.2.2 Coordinate-invariance check\nAlthough the matrix \\(g_{ij}\\) depends on the chosen coordinates, the \\(2\\)-form \\(dA\\) does not. Under a change of parameters \\((u,v)\\mapsto(\\tilde u,\\tilde v)\\) with Jacobian \\(J=\\left(\\frac{\\partial(u,v)}{\\partial(\\tilde u,\\tilde v)}\\right)\\), \\[\n\\begin{aligned}\n(g_{ij}) &\\longmapsto (g'_{ij})=J^\\top (g_{ij})\\,J,\\\\[2pt]\n\\det(g'_{ij})&=\\det(J^\\top)\\det(g_{ij})\\det(J)=(\\det J)^2\\det(g_{ij}),\\\\[2pt]\n\\sqrt{\\det(g'_{ij})}\\,d\\tilde u\\,d\\tilde v\n&=|\\det J|\\,\\sqrt{\\det(g_{ij})}\\,d\\tilde u\\,d\\tilde v\n=\\sqrt{\\det(g_{ij})}\\,du\\,dv,\n\\end{aligned}\n\\] so \\(\\boxed{\\,dA\\ \\text{is independent of the coordinate chart.}\\,}\\) ## 2.2 Definition of Area \\[\n\\boxed{\\,dA=\\|\\sigma_1\\times\\sigma_2\\|\\,du\\,dv\n=\\sqrt{\\det(g_{ij})}\\,du\\,dv\n=\\sqrt{EG-F^2}\\,du\\,dv\\,}\n\\] Where \\(g_{ij}=g(\\sigma_i,\\sigma_j)\\) (or \\(E=\\langle\\sigma_u,\\sigma_u\\rangle,\\ F=\\langle\\sigma_u,\\sigma_v\\rangle,\\ G=\\langle\\sigma_v,\\sigma_v\\rangle\\)).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1.1 Smooth map and its differential (push-forward)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#worked-examples-for-d-s2-and-da",
    "href": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#worked-examples-for-d-s2-and-da",
    "title": "More Examples & Curvature",
    "section": "3.1 Worked examples for \\(d s^2\\) and \\(dA\\)",
    "text": "3.1 Worked examples for \\(d s^2\\) and \\(dA\\)\n\n3.1.1 Cylinder in cylindrical coordinates\nParameterize the unit cylinder by \\[\n\\sigma(z,\\theta)=(\\cos\\theta,\\ \\sin\\theta,\\ z),\\qquad (z,\\theta)\\in\\mathbb R\\times[0,2\\pi).\n\\] Compute the first fundamental form: \\[\n\\begin{aligned}\n\\sigma_z&=(0,0,1),&\n\\sigma_\\theta&=(-\\sin\\theta,\\ \\cos\\theta,\\ 0),\\\\[2pt]\nE&=\\langle\\sigma_z,\\sigma_z\\rangle=1,\\quad\nF=\\langle\\sigma_z,\\sigma_\\theta\\rangle=0,\\quad\nG=\\langle\\sigma_\\theta,\\sigma_\\theta\\rangle=1.\n\\end{aligned}\n\\] Hence \\[\n\\boxed{\\,d s^2=dz^2+d\\theta^2,\\qquad \\det g=EG-F^2=1,\\qquad dA=\\sqrt{\\det g}\\,dz\\,d\\theta=dz\\,d\\theta\\,.}\n\\] ### 3.1.2 Sphere in cylindrical coordinates Use\n\\[\n\\sigma(z,\\theta)=\\big(\\sqrt{1-z^2}\\cos\\theta,\\ \\sqrt{1-z^2}\\sin\\theta,\\ z\\big),\\qquad -1&lt;z&lt;1.\n\\]\nLet \\(a=\\sqrt{1-z^2}\\) and \\(a'=\\frac{da}{dz}=-\\frac{z}{a}\\). Then \\[\n\\begin{aligned}\n\\sigma_z&=(a'\\cos\\theta,\\ a'\\sin\\theta,\\ 1)=\\left(-\\frac{z}{a}\\cos\\theta,\\ -\\frac{z}{a}\\sin\\theta,\\ 1\\right),\\\\\n\\sigma_\\theta&=(-a\\sin\\theta,\\ a\\cos\\theta,\\ 0).\n\\end{aligned}\n\\] Now compute \\(E,F,G\\): \\[\n\\begin{aligned}\nE&=\\langle\\sigma_z,\\sigma_z\\rangle=\\frac{z^2}{a^2}+1=\\frac{z^2}{1-z^2}+1=\\frac{1}{1-z^2},\\\\\nF&=\\langle\\sigma_z,\\sigma_\\theta\\rangle\n=\\left(-\\frac{z}{a}\\cos\\theta\\right)(-a\\sin\\theta)+\\left(-\\frac{z}{a}\\sin\\theta\\right)(a\\cos\\theta)+0=0,\\\\\nG&=\\langle\\sigma_\\theta,\\sigma_\\theta\\rangle=a^2( \\sin^2\\theta+\\cos^2\\theta)=a^2=1-z^2.\n\\end{aligned}\n\\] Thus \\[\n\\boxed{\\,\\det g=EG-F^2=\\frac{1}{1-z^2}\\,(1-z^2)-0=1,\\qquad dA=\\sqrt{\\det g}\\,dz\\,d\\theta=dz\\,d\\theta\\,.}\n\\] &gt; Archimedes’ theorem follows: the cylindrical projection \\((z,\\theta)\\) preserves area on the unit sphere. # Curvature of surfaces: deviation from the tangent plane",
    "crumbs": [
      "Notes",
      "微分几何",
      "1.1 Smooth map and its differential (push-forward)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#setup-and-idea",
    "href": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#setup-and-idea",
    "title": "More Examples & Curvature",
    "section": "4.1 Setup and idea",
    "text": "4.1 Setup and idea\nLet \\(\\sigma(u^1,u^2)\\) be a regular local patch with\n\\[\n\\sigma_i=\\frac{\\partial\\sigma}{\\partial u^i},\\qquad\ng_{ij}=\\langle\\sigma_i,\\sigma_j\\rangle.\n\\]\nAt a base point \\(u=(u^1,u^2)\\), the tangent plane approximation at an offset \\(\\Delta u=(\\Delta u^1,\\Delta u^2)\\) is \\[\n\\sigma(u)+\\sigma_i(u)\\,\\Delta u^i.\n\\] The unit normal is \\[\nN(u)=\\frac{\\sigma_1\\times\\sigma_2}{\\|\\sigma_1\\times\\sigma_2\\|}(u).\n\\] We quantify curvature by how much the true surface point \\(\\sigma(u+\\Delta u)\\) departs from this tangent plane in the normal direction.",
    "crumbs": [
      "Notes",
      "微分几何",
      "1.1 Smooth map and its differential (push-forward)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#taylor-expansion-and-the-second-fundamental-form",
    "href": "content/notes/理论/微分几何/5. Pushforward, Pullback, and Local Isometries.html#taylor-expansion-and-the-second-fundamental-form",
    "title": "More Examples & Curvature",
    "section": "4.2 Taylor expansion and the second fundamental form",
    "text": "4.2 Taylor expansion and the second fundamental form\nTaylor-expand \\(\\sigma\\) to second order:\n\\[\n\\begin{aligned}\n\\sigma(u+\\Delta u)\n&=\\sigma(u)+\\sigma_i(u)\\,\\Delta u^i+\\tfrac12\\,\\sigma_{ij}(u)\\,\\Delta u^i\\Delta u^j+O(|\\Delta u|^3),\n\\end{aligned}\n\\]\nwhere \\(\\sigma_{ij}=\\frac{\\partial^2\\sigma}{\\partial u^i\\partial u^j}\\).\nDefine the normal deviation (signed distance to the tangent plane in the normal direction)\n\\[\nd(\\Delta u)\\;:=\\;\\big(\\sigma(u+\\Delta u)-\\sigma(u)-\\sigma_i\\,\\Delta u^i\\big)\\cdot N(u).\n\\]\nUsing the expansion,\n\\[\n\\begin{aligned}\nd(\\Delta u)\n&=\\tfrac12\\,\\big(\\sigma_{ij}\\cdot N\\big)\\,\\Delta u^i\\Delta u^j+O(|\\Delta u|^3)\\\\\n&=\\tfrac12\\,b_{ij}\\,\\Delta u^i\\Delta u^j+O(|\\Delta u|^3),\n\\end{aligned}\n\\] where \\[\n\\boxed{\\,b_{ij}:=\\sigma_{ij}\\cdot N\\quad\\text{(coefficients of the second fundamental form)}\\, }.\n\\] Thus the second fundamental form is \\[\n\\boxed{\\,\\mathrm{II}=b_{ij}\\,du^i\\,du^j\\, }\n\\] ### 7.3 Shape operator, principal/mean/Gauss curvature Let \\(g^{ij}\\) be the inverse matrix of \\(g_{ij}\\). Define the shape operator \\(S:T_pS\\to T_pS\\) by \\[\nS(X)=-dN_p(X),\\qquad\\text{so that}\\qquad b_{ij}=g_{ik}\\,h^k{}_j\\ \\ \\text{with}\\ \\ h^i{}_j=g^{ik}b_{kj}.\n\\] Then: * Normal curvature in direction \\(v\\neq0\\): \\[\n  k_n(v)=\\frac{\\mathrm{II}(v,v)}{\\mathrm{I}(v,v)}=\\frac{b_{ij}v^iv^j}{g_{ij}v^iv^j}.\n\\] * Principal curvatures \\(k_1,k_2\\): eigenvalues of \\(S\\) (or of the matrix \\(h^i{}_j\\)). * Mean curvature \\(H\\) and Gauss curvature \\(K\\): \\[\n  \\boxed{\\,H=\\tfrac12\\,\\mathrm{tr}(S)=\\tfrac12\\,g^{ij}b_{ij},\\qquad\n  K=\\det(S)=\\frac{\\det(b_{ij})}{\\det(g_{ij})}\\, }.\n\\] These formulas arise directly from measuring the second-order normal deviation of the surface from its tangent plane.",
    "crumbs": [
      "Notes",
      "微分几何",
      "1.1 Smooth map and its differential (push-forward)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html",
    "title": "Erise Note",
    "section": "",
    "text": "[!definition|1.1] regular curve A (smooth) curve is a \\(C^\\infty\\) map \\(\\gamma:I\\subset\\mathbb{R}\\to\\mathbb{R}^3\\).\nIt is regular if \\(\\dot{\\gamma}(t)\\neq 0\\) for all \\(t\\in I\\) (here \\(\\dot{\\gamma}=\\dfrac{d\\gamma}{dt}\\) is the velocity).\n\n\n[!definition|1.2] arclength function Fix \\(t_0\\in I\\). The arclength from \\(t_0\\) to \\(t\\) is \\[\ns(t)=\\int_{t_0}^{t}\\|\\dot{\\gamma}(\\tau)\\|\\,d\\tau.\n\\]\n\nFrom the Fundamental Theorem of Calculus, \\[\n\\frac{ds}{dt}=\\|\\dot{\\gamma}(t)\\| \\quad\\text{(speed)}&gt;0\\ \\text{for regular curves}.\n\\] Hence, by the Inverse Function Theorem, \\(s(t)\\) admits a smooth local inverse \\(t=t(s)\\).\n\n[!proposition|1.3] unit-speed reparametrization Every regular curve admits a reparametrization by arclength: writing \\(\\gamma(s):=\\gamma\\!\\big(t(s)\\big)\\) one has \\(\\|\\gamma'(s)\\|=1\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#parametrized-curves-in-mathbbr3-plane-curves-as-a-special-case",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#parametrized-curves-in-mathbbr3-plane-curves-as-a-special-case",
    "title": "Erise Note",
    "section": "",
    "text": "[!definition|1.1] regular curve A (smooth) curve is a \\(C^\\infty\\) map \\(\\gamma:I\\subset\\mathbb{R}\\to\\mathbb{R}^3\\).\nIt is regular if \\(\\dot{\\gamma}(t)\\neq 0\\) for all \\(t\\in I\\) (here \\(\\dot{\\gamma}=\\dfrac{d\\gamma}{dt}\\) is the velocity).\n\n\n[!definition|1.2] arclength function Fix \\(t_0\\in I\\). The arclength from \\(t_0\\) to \\(t\\) is \\[\ns(t)=\\int_{t_0}^{t}\\|\\dot{\\gamma}(\\tau)\\|\\,d\\tau.\n\\]\n\nFrom the Fundamental Theorem of Calculus, \\[\n\\frac{ds}{dt}=\\|\\dot{\\gamma}(t)\\| \\quad\\text{(speed)}&gt;0\\ \\text{for regular curves}.\n\\] Hence, by the Inverse Function Theorem, \\(s(t)\\) admits a smooth local inverse \\(t=t(s)\\).\n\n[!proposition|1.3] unit-speed reparametrization Every regular curve admits a reparametrization by arclength: writing \\(\\gamma(s):=\\gamma\\!\\big(t(s)\\big)\\) one has \\(\\|\\gamma'(s)\\|=1\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#example-uniform-circular-motion",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#example-uniform-circular-motion",
    "title": "Erise Note",
    "section": "2. Example: uniform circular motion",
    "text": "2. Example: uniform circular motion\nLet \\(r&gt;0\\) be the radius and \\(\\omega\\) the angular velocity. Consider \\[\n\\gamma(t)=\\big(r\\cos(\\omega t),\\, r\\sin(\\omega t)\\big).\n\\] Then \\[\n\\|\\dot{\\gamma}(t)\\|=r\\omega,\\qquad\ns(t)=r\\omega\\,t \\ \\Rightarrow\\ t=\\frac{s}{r\\omega}.\n\\] The unit-speed parametrization is \\[\n\\gamma(s)=\\big(r\\cos(s/r),\\, r\\sin(s/r)\\big),\n\\] so \\[\n\\gamma'(s)=\\big(-\\sin(s/r),\\,\\cos(s/r)\\big),\\qquad\n\\gamma''(s)=\\left(-\\frac{1}{r}\\cos(s/r),\\, -\\frac{1}{r}\\sin(s/r)\\right),\n\\] and therefore \\(\\|\\gamma''(s)\\|=1/r\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#curvature-of-a-regular-curve",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#curvature-of-a-regular-curve",
    "title": "Erise Note",
    "section": "3. Curvature of a regular curve",
    "text": "3. Curvature of a regular curve\nFor a unit-speed curve \\(\\gamma(s)\\) the curvature is &gt; [!definition|3.1] &gt; Curvature (unit speed)\n&gt; \\[\n&gt; \\kappa(s)=\\big\\|\\gamma''(s)\\big\\|.\n&gt; \\]\nFor a general parametrization \\(\\gamma(t)\\), set \\(v:=\\dfrac{ds}{dt}=\\|\\dot{\\gamma}(t)\\|\\). Using the chain rule, \\[\n\\begin{aligned}\n\\frac{d\\gamma}{ds}\n&=\\frac{1}{v}\\,\\dot{\\gamma},\\\\[2pt]\n\\frac{d^2\\gamma}{ds^2}\n&=\\frac{d}{ds}\\!\\left(\\frac{1}{v}\\dot{\\gamma}\\right)\n=\\frac{1}{v}\\frac{d}{dt}\\!\\left(\\frac{1}{v}\\dot{\\gamma}\\right)\n=\\frac{1}{v}\\left(\\frac{\\ddot{\\gamma}}{v}-\\frac{\\dot{v}}{v^2}\\dot{\\gamma}\\right)\n=\\frac{v\\,\\ddot{\\gamma}-\\dot{v}\\,\\dot{\\gamma}}{v^{3}}.\n\\end{aligned}\n\\] Hence the curvature in any parameter is \\[\n\\boxed{\\ \\kappa(t)=\\frac{\\big\\|v\\,\\ddot{\\gamma}(t)-\\dot{v}\\,\\dot{\\gamma}(t)\\big\\|}{v(t)^3}\\ },\n\\qquad v=\\|\\dot{\\gamma}(t)\\|.\n\\] A useful equivalent expression in \\(\\mathbb{R}^3\\) is \\[\n\\boxed{\\ \\kappa(t)=\\dfrac{\\|\\dot{\\gamma}(t)\\times \\ddot{\\gamma}(t)\\|}{\\|\\dot{\\gamma}(t)\\|^{3}}\\ }.\n\\]",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#surfaces-in-mathbbr3",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#surfaces-in-mathbbr3",
    "title": "Erise Note",
    "section": "4. Surfaces in \\(\\mathbb{R}^3\\)",
    "text": "4. Surfaces in \\(\\mathbb{R}^3\\)\n\n[!definition|4.1] Coordinate patch (regular parametrization)\nA patch is a \\(C^\\infty\\) map \\(\\sigma:U\\to\\mathbb{R}^3\\) with \\(U\\subset\\mathbb{R}^2\\) open, connected, such that \\(\\sigma\\) is regular (maximal rank).\nWith coordinates \\((u^1,u^2)\\) on \\(U\\), set the coordinate vectors \\[\n\\sigma_i:=\\frac{\\partial \\sigma}{\\partial u^i}\\in\\mathbb{R}^3,\\quad i=1,2,\n\\] and regularity means \\(\\sigma_1,\\sigma_2\\) are linearly independent at each point.\n\n\n[!definition|4.2] Smooth surface\nA smooth surface \\(S\\subset\\mathbb{R}^3\\) is a set equipped with an atlas of regular patches \\(\\{\\sigma_\\alpha:U_\\alpha\\to S\\}\\) covering \\(S\\).\n\n(Notation: we use upper/lower indices (Einstein convention) to track how objects transform under changes of coordinates.)",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#transition-maps-and-smoothness-of-functionsmaps",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#transition-maps-and-smoothness-of-functionsmaps",
    "title": "Erise Note",
    "section": "5. Transition maps and smoothness of functions/maps",
    "text": "5. Transition maps and smoothness of functions/maps\n\n[!proposition|5.1] Smooth transition maps\nIf \\(\\sigma:U\\to S\\) and \\(\\tilde{\\sigma}:\\tilde{U}\\to S\\) are overlapping regular patches, then the transition maps \\[\n\\tilde{\\sigma}^{-1}\\!\\circ \\sigma:\\ U\\cap \\sigma^{-1}(\\tilde{\\sigma}(\\tilde{U}))\\ \\longrightarrow\\ \\tilde{U},\n\\] and its inverse are \\(C^\\infty\\).\n\nUsing patches, define smoothness intrinsically: - A function \\(f:S\\to\\mathbb{R}\\) is smooth if \\(f\\circ\\sigma\\) is smooth on \\(U\\) for every patch \\(\\sigma\\). - A map \\(f:S_1\\to S_2\\) between smooth surfaces is smooth if for every pair of patches \\(\\sigma\\) on \\(S_1\\) and \\(\\tilde{\\sigma}\\) on \\(S_2\\), \\[\n\\tilde{\\sigma}^{-1}\\circ f\\circ \\sigma:\\ U\\to \\tilde{U}\n\\] is smooth.",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#tangent-vectors-as-derivations",
    "href": "content/notes/理论/微分几何/2. Parametrized Curves and Surfaces.html#tangent-vectors-as-derivations",
    "title": "Erise Note",
    "section": "6. Tangent vectors as derivations",
    "text": "6. Tangent vectors as derivations\n\n[!definition|6.1] Tangent vector at \\(p\\in S\\) (derivation)\nA tangent vector is a linear map \\(X:C^\\infty(S)\\to\\mathbb{R}\\) such that\n(i) If \\(f=g\\) on some neighborhood of \\(p\\), then \\(Xf=Xg\\) (locality at \\(p\\)).\n(ii) \\(X(fg)=g(p)\\,Xf+f(p)\\,Xg\\) (Leibniz rule).\n\nThese axioms identify \\(T_pS\\) with the space of derivations at \\(p\\); in coordinates, \\(X=X^i\\,\\partial/\\partial u^i\\) with \\(X^i\\in\\mathbb{R}\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. Parametrized curves in $\\mathbb{R}^3$ (plane curves as a special case)"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html",
    "href": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html",
    "title": "Erise Note",
    "section": "",
    "text": "In multivariable calculus we study parametrized surfaces \\(X: U \\subset \\mathbb{R}^2 \\to \\mathbb{R}^3\\).\nA parametrization is regular if the tangent vectors \\(X_u=\\partial_u X\\) and \\(X_v=\\partial_v X\\) are linearly independent at each point (so \\(dX\\) has rank \\(2\\)).\n\n\n[!definition|1.1] Smooth manifold A \\(2\\)–manifold (surface) is a space that can be covered by coordinate patches \\(\\{(U_\\alpha,\\varphi_\\alpha)\\}\\) with homeomorphisms \\(\\varphi_\\alpha:U_\\alpha\\to\\mathbb{R}^2\\) whose transition maps \\(\\varphi_\\beta\\circ\\varphi_\\alpha^{-1}\\) are smooth wherever defined.\nHigher–dimensional manifolds are defined similarly with \\(\\mathbb{R}^n\\).\n\n\nSome surfaces (e.g., the unit sphere \\(\\mathbb{S}^2\\)) require multiple patches; the inverses of the transition maps must be smooth as well.",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. From Calculus to Manifolds"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#from-calculus-to-manifolds",
    "href": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#from-calculus-to-manifolds",
    "title": "Erise Note",
    "section": "",
    "text": "In multivariable calculus we study parametrized surfaces \\(X: U \\subset \\mathbb{R}^2 \\to \\mathbb{R}^3\\).\nA parametrization is regular if the tangent vectors \\(X_u=\\partial_u X\\) and \\(X_v=\\partial_v X\\) are linearly independent at each point (so \\(dX\\) has rank \\(2\\)).\n\n\n[!definition|1.1] Smooth manifold A \\(2\\)–manifold (surface) is a space that can be covered by coordinate patches \\(\\{(U_\\alpha,\\varphi_\\alpha)\\}\\) with homeomorphisms \\(\\varphi_\\alpha:U_\\alpha\\to\\mathbb{R}^2\\) whose transition maps \\(\\varphi_\\beta\\circ\\varphi_\\alpha^{-1}\\) are smooth wherever defined.\nHigher–dimensional manifolds are defined similarly with \\(\\mathbb{R}^n\\).\n\n\nSome surfaces (e.g., the unit sphere \\(\\mathbb{S}^2\\)) require multiple patches; the inverses of the transition maps must be smooth as well.",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. From Calculus to Manifolds"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#riemannian-metrics-and-length",
    "href": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#riemannian-metrics-and-length",
    "title": "Erise Note",
    "section": "2. Riemannian Metrics and Length",
    "text": "2. Riemannian Metrics and Length\n\n[!definition|2.1] Riemannian Metric On a manifold \\(M\\), a Riemannian metric \\(g\\) assigns to each \\(p\\in M\\) an inner product \\(g_p\\) on \\(T_pM\\), varying smoothly with \\(p\\). It provides infinitesimal distance via the quadratic form \\(ds^2\\).\n\n\nFor a smooth curve \\(\\gamma:I\\to M\\), its length is \\[\n\\begin{aligned}\nL(\\gamma)\n&=\\int_I \\|\\gamma'(t)\\|_{g}\\,dt\n=\\int_I \\sqrt{g_{\\gamma(t)}\\!\\big(\\gamma'(t),\\gamma'(t)\\big)}\\,dt.\n\\end{aligned}\n\\] ### 2.1. First Fundamental Form on a Surface Let \\(X(u,v)\\) be a regular parametrization of a surface in \\(\\mathbb{R}^3\\). Set \\[\n\\begin{aligned}\nE &= \\langle X_u,X_u\\rangle \\\\\nF &= \\langle X_u,X_v\\rangle \\\\\nG &= \\langle X_v,X_v\\rangle.\n\\end{aligned}\n\\] &gt; [!definition|2.2] First Fundamental Form &gt; The metric in coordinates \\((u,v)\\) is &gt; \\[\\begin{aligned}\n&gt; ds^2 &= E\\,du^2 + 2F\\,du\\,dv + G\\,dv^2\n&gt; \\end{aligned}\\] &gt; a smoothly varying quadratic form that encodes lengths, angles, and areas on the surface.\nAngle between tangent vectors \\(V,W\\) at the same point: \\[\n\\cos\\theta=\\frac{g(V,W)}{\\sqrt{g(V,V)}\\sqrt{g(W,W)}}.\n\\]\nArea element in coordinates: \\[\ndA=\\sqrt{EG-F^2}\\;du\\,dv.\n\\]",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. From Calculus to Manifolds"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#curvature",
    "href": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#curvature",
    "title": "Erise Note",
    "section": "3. Curvature",
    "text": "3. Curvature\n\nFor a plane curve, curvature \\(\\kappa\\) is \\(1/R\\), the reciprocal of the radius \\(R\\) of the osculating circle.\nOn a surface, one studies how normal sections bend; from this one obtains the Gaussian curvature \\(K\\) (intrinsic) and the mean curvature \\(H\\) (extrinsic).\n\n\n[!theorem|3.1] Theorema Egregium (Gauss)\nThe Gaussian curvature \\(K\\) of a surface depends only on the first fundamental form \\(g\\) (i.e., it is an intrinsic invariant) and not on how the surface sits in \\(\\mathbb{R}^3\\).\n\n\nExample (Unit sphere): On \\(\\mathbb{S}^2\\) of radius \\(1\\), \\(K\\equiv 1\\). For a spherical triangle \\(\\Delta\\), \\[\n\\sum \\text{(angles of }\\Delta\\text{)}=\\pi+\\operatorname{area}(\\Delta).\n\\]",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. From Calculus to Manifolds"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#normalgeodesic-coordinates-and-curvature-as-a-quadratic-correction",
    "href": "content/notes/理论/微分几何/1. Overview of Differential Geometry.html#normalgeodesic-coordinates-and-curvature-as-a-quadratic-correction",
    "title": "Erise Note",
    "section": "4. Normal/Geodesic Coordinates and Curvature as a Quadratic Correction",
    "text": "4. Normal/Geodesic Coordinates and Curvature as a Quadratic Correction\nAround any point \\(p\\) of a Riemannian manifold there exist geodesic normal coordinates \\((x^1,\\dots,x^n)\\) such that at \\(p\\) the metric equals the Euclidean metric and first derivatives of \\(g\\) vanish. In such coordinates near \\(p\\), \\[\n\\begin{aligned}\ng_{ij}(x) &= \\delta_{ij} + \\tfrac{1}{3}\\sum_{k,\\ell} R_{ikj\\ell}(p)\\,x^k x^\\ell \\;+\\; O(|x|^3),\n\\end{aligned}\n\\] so the quadratic correction to the Euclidean metric records the Riemann curvature tensor \\(R\\). For a surface (\\(n=2\\)), this quadratic term is determined by the single function \\(K\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "1. From Calculus to Manifolds"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/6. Tensor Equation.html",
    "href": "content/notes/理论/广义相对论/广义相对论理论/6. Tensor Equation.html",
    "title": "张量方程",
    "section": "",
    "text": "Big picture. In relativity (and differential geometry), the form of a physical law must not depend on your coordinate labels. Quantities whose components change in a precisely prescribed way under coordinate changes are called tensors. Indices up (superscripts) and down (subscripts) encode how components transform. ## 1. 坐标变换与张量概念 Let \\(x^\\mu\\mapsto x'^{\\,\\mu}(x)\\). Write the Jacobians \\[\n\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\nu},\\qquad\n\\frac{\\partial x^\\mu}{\\partial x'^{\\,\\nu}} .\n\\] ### 1.1 向量（逆变分量） A vector \\(A\\) has components \\(A^\\mu\\) that transform by the push-forward: \\[\n\\boxed{A'^{\\,\\mu}=\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\nu}\\,A^\\nu.}\n\\tag{V}\n\\] ### 1.2 余向量（协变分量，1-形式） A covector \\(B\\) (aka 1-form) has components \\(B_\\mu\\) that transform by the pull-back: \\[\n\\boxed{B'_{\\nu}=\\frac{\\partial x^\\mu}{\\partial x'^{\\,\\nu}}\\,B_\\mu.}\n\\tag{C}\n\\] Why one index up vs. down? Each upper index contributes a factor \\(\\partial x' / \\partial x\\); each lower index contributes a factor \\(\\partial x / \\partial x'\\). ## 2. 梯度是一个余向量 The gradient is a covector. For a scalar field \\(\\Phi(x)\\), define its gradient (as a 1-form) \\[\n(\\mathrm{d}\\Phi)_\\mu \\equiv \\partial_\\mu \\Phi=\\frac{\\partial \\Phi}{\\partial x^\\mu}.\n\\] Under a coordinate change, \\[\n\\begin{aligned}\n\\partial'_{\\nu}\\Phi\n&=\\frac{\\partial}{\\partial x'^{\\,\\nu}}\\Phi(x(x'))\\\\\n&=\\frac{\\partial x^\\mu}{\\partial x'^{\\,\\nu}}\\,\n\\frac{\\partial \\Phi}{\\partial x^\\mu}\n=\\frac{\\partial x^\\mu}{\\partial x'^{\\,\\nu}}\\;\\partial_\\mu \\Phi,\n\\end{aligned}\n\\] which matches the covector rule \\((\\mathrm{d}\\Phi)'_{\\nu}= \\tfrac{\\partial x^\\mu}{\\partial x'^{\\,\\nu}}(\\mathrm{d}\\Phi)_\\mu\\). ## 3. 度量、指标升降与不变量配对 Let \\(g_{\\mu\\nu}\\) be the (coordinate-basis) metric tensor. It lowers indices; its matrix inverse \\(g^{\\mu\\nu}\\) raises them: \\[\nA_\\mu \\equiv g_{\\mu\\nu}A^\\nu,\\qquad\nA^\\mu \\equiv g^{\\mu\\nu}A_\\nu,\\qquad\ng^{\\mu\\alpha}g_{\\alpha\\nu}=\\delta^\\mu_{\\ \\nu}.\n\\] ### 3.1 降指标得到余向量 (Lowering an index gives a covector) If \\(A^\\mu\\) is a vector, then \\(A_\\mu=g_{\\mu\\nu}A^\\nu\\) transforms as a covector. In detail: \\[\n\\begin{aligned}\nA'_{\\nu}\n&=g'_{\\nu\\mu}A'^{\\,\\mu}\n=\\Big(\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\nu}}\n\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\mu}}g_{\\alpha\\beta}\\Big)\n\\Big(\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\sigma}A^\\sigma\\Big)\\\\\n&=\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\nu}}\\,\ng_{\\alpha\\beta}\\,\\delta^\\beta_{\\ \\sigma}\\,A^\\sigma\n=\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\nu}}\\,A_\\alpha,\n\\end{aligned}\n\\] which is exactly the covector law. ### 3.2 向量与余向量的标量积: Scalar (coordinate-invariant) pairing The contraction of a covector and vector is a true scalar: \\[\n\\boxed{A\\cdot B:=A^\\mu B_\\mu\n=A'^{\\,\\mu}B'_{\\mu}.}\n\\] Derivation: \\[\n\\begin{aligned}\nA'^{\\,\\mu}B'_{\\mu}\n&=\\Big(\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}A^\\alpha\\Big)\n\\Big(\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\mu}}B_\\beta\\Big)\n=\\delta^\\beta_{\\ \\alpha}\\,A^\\alpha B_\\beta\n=A^\\mu B_\\mu.\n\\end{aligned}\n\\] ### 3.3 逆度量的变换: Inverse metric transforms with two upper indices By definition \\(g^{\\mu\\alpha}g_{\\alpha\\nu}=\\delta^\\mu_{\\ \\nu}\\). Using the metric’s transformation, \\[\ng'_{\\mu\\nu}=\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\mu}}\n\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\nu}}\\,g_{\\alpha\\beta},\n\\] one finds \\[\n\\boxed{g'^{\\mu\\nu}\n=\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}\n\\frac{\\partial x'^{\\,\\nu}}{\\partial x^\\beta}\\,g^{\\alpha\\beta}.}\n\\] ## 4. \\(n\\)阶张量 (\\(n\\)-th Rank Tensors) An \\(n\\)-th rank tensor \\(T\\) with \\(p\\) upper and \\(q\\) lower indices \\((p+q=n)\\) transforms as \\[\n\\boxed{\nT'^{\\mu_1\\cdots\\mu_p}{}_{\\nu_1\\cdots\\nu_q}\n=\\Big(\\prod_{i=1}^{p}\\frac{\\partial x'^{\\,\\mu_i}}{\\partial x^{\\alpha_i}}\\Big)\n\\Big(\\prod_{j=1}^{q}\\frac{\\partial x^{\\beta_j}}{\\partial x'^{\\,\\nu_j}}\\Big)\nT^{\\alpha_1\\cdots\\alpha_p}{}_{\\beta_1\\cdots\\beta_q}.\n}\n\\] * Each upper index contributes a factor \\(\\partial x'/\\partial x\\). * Each lower index contributes a factor \\(\\partial x/\\partial x'\\). * A scalar is rank \\(0\\) (no factors): \\(\\Phi'=\\Phi\\).\nExamples (rank 2): \\[\n\\begin{aligned}\n&\\text{Metric: } g'_{\\mu\\nu}=\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\mu}}\n                     \\frac{\\partial x^\\beta}{\\partial x'^{\\,\\nu}}\\,g_{\\alpha\\beta},\\\\\n&\\text{Inverse metric: } g'^{\\mu\\nu}=\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}\n                     \\frac{\\partial x'^{\\,\\nu}}{\\partial x^\\beta}\\,g^{\\alpha\\beta},\\\\\n&\\text{Kronecker delta: } \\delta^\\mu_{\\ \\nu}\\ \\text{(mixed, transforms to itself).}\n\\end{aligned}\n\\]",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "张量方程"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/6. Tensor Equation.html#张量运算building-new-tensors-from-old",
    "href": "content/notes/理论/广义相对论/广义相对论理论/6. Tensor Equation.html#张量运算building-new-tensors-from-old",
    "title": "张量方程",
    "section": "5. 张量运算（Building New Tensors from Old）",
    "text": "5. 张量运算（Building New Tensors from Old）\nGiven tensors \\(S,T\\): 1. Sum (same type): \\(U = S+T\\) is a tensor of the same index type (only if indices match exactly). 2. Tensor product: \\((S\\otimes T)^{\\cdots}{}_{\\cdots}=S^{\\cdots}{}_{\\cdots}\\,T^{\\cdots}{}_{\\cdots}\\) Rank adds: $ (ST)=(S)+(T)$. 3. Contraction: Sum over one upper–lower pair, reducing rank by \\(2\\). \\[\n   R^\\mu{}_\\nu := g^{\\alpha\\beta}R^\\mu{}_{\\nu\\alpha\\beta},\\quad\n   A\\cdot B=A^\\mu B_\\mu.\n\\] 4. Raise/lower: Use \\(g^{\\mu\\nu}\\) or \\(g_{\\mu\\nu}\\) to move indices without changing rank: \\[\n   T^\\mu{}_{\\nu}\\ \\leftrightarrow\\ T^{\\mu\\alpha}g_{\\alpha\\nu},\\qquad\n   T_{\\mu\\nu}\\ \\leftrightarrow\\ g_{\\mu\\alpha}g_{\\nu\\beta}T^{\\alpha\\beta}.\n   \\] All four operations preserve tensorial character. ## 6. 为什么张量重要：协变方程（Covariant Equations） If a physical law can be written as \\[\n\\boxed{A^{\\mu_1\\cdots}{}_{\\nu_1\\cdots}=B^{\\mu_1\\cdots}{}_{\\nu_1\\cdots}}\n\\] with matching index pattern on both sides, then both sides transform the same way in any coordinate system. The equation is manifestly covariant—true in all frames once true in one frame. This is how GR encodes physics independently of coordinates. ## 7. Subtlety: Gradients of Non-Scalars\nThe gradient of a scalar is a covector (Sec. 2). But the naive “gradient of a vector”, \\[\n(\\partial_\\nu A^\\mu)\\,,\n\\] does not transform as a tensor because of second-derivative (inhomogeneous) terms from the product rule acting on the Jacobian: \\[\n\\begin{aligned}\n\\partial'_{\\nu} A'^{\\,\\mu}\n&=\\partial'_{\\nu}\\!\\left(\n\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}A^\\alpha\n\\right)\\\\\n&=\\underbrace{\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\nu}}\n              \\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}\n              \\partial_{\\beta}A^\\alpha}_{\\text{looks tensorial}}\n\\;+\\;\n\\underbrace{\\frac{\\partial^2 x'^{\\,\\mu}}{\\partial x'^{\\,\\nu}\\partial x^\\alpha}\\,A^\\alpha}_{\\text{spoils tensoriality}}.\n\\end{aligned}\n\\tag{\\*}\n\\] To repair this in curved/accelerated coordinates, one introduces a connection and the covariant derivative \\(\\nabla_\\nu A^\\mu\\), which does transform tensorially. ## 8. Flat Cartesian Special Case (sanity check)\nIn ordinary Cartesian coordinates of flat space, \\(g_{\\mu\\nu}=\\mathrm{diag}(1,1,\\dots)\\). Then \\[\n\\mathrm{d}s^2=g_{\\mu\\nu}\\,\\mathrm{d}x^\\mu\\mathrm{d}x^\\nu\n=\\sum_\\mu (\\mathrm{d}x^\\mu)^2,\n\\] and there is no distinction between up/down components numerically (though the index positions still carry transformation meaning when you change coordinates). ## 9. Worked Micro-Derivations (for practice)\n\n9.1 Coordinate-invariance of \\(A^\\mu B_\\mu\\)\n\\[\n\\begin{aligned}\nA'^{\\,\\mu}B'_{\\mu}\n&=\\Big(\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}A^\\alpha\\Big)\n  \\Big(\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\mu}}B_\\beta\\Big)\n=\\delta^\\beta_{\\ \\alpha}\\,A^\\alpha B_\\beta\n=A^\\mu B_\\mu.\n\\end{aligned}\n\\]\n\n\n9.2 Lowering an index is covariant\n\\[\n\\begin{aligned}\nA'_{\\nu}\n&=g'_{\\nu\\mu}A'^{\\,\\mu} \\\\\n&=\\Big(\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\nu}}\n       \\frac{\\partial x^\\beta}{\\partial x'^{\\,\\mu}}g_{\\alpha\\beta}\\Big)\n  \\Big(\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\sigma}A^\\sigma\\Big)\\\\\n&=\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\nu}}g_{\\alpha\\beta}\\delta^\\beta_{\\ \\sigma}A^\\sigma\n=\\frac{\\partial x^\\alpha}{\\partial x'^{\\,\\nu}}A_\\alpha.\n\\end{aligned}\n\\] ### 9.3 Inverse metric transformation\nDemand \\(g'^{\\mu\\alpha}g'_{\\alpha\\nu}=\\delta^\\mu_{\\ \\nu}\\):\n\\[\n\\begin{aligned}\ng'^{\\mu\\alpha}\\Big(\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\alpha}}\n\\frac{\\partial x^\\gamma}{\\partial x'^{\\,\\nu}}g_{\\beta\\gamma}\\Big)\n&=\\delta^\\mu_{\\ \\nu}\n\\quad\\Rightarrow\\quad\ng'^{\\mu\\alpha}\\frac{\\partial x^\\beta}{\\partial x'^{\\,\\alpha}}\n=\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\gamma}g^{\\gamma\\beta},\n\\end{aligned}\n\\]\nhence \\(g'^{\\mu\\nu}=\\frac{\\partial x'^{\\,\\mu}}{\\partial x^\\alpha}\\frac{\\partial x'^{\\,\\nu}}{\\partial x^\\beta}g^{\\alpha\\beta}\\). ## 10. Quick Reference (What to Memorize)\n\nVector: \\(A'^{\\,\\mu}=\\dfrac{\\partial x'^{\\,\\mu}}{\\partial x^\\nu}A^\\nu\\).\nCovector: \\(B'_{\\mu}=\\dfrac{\\partial x^\\nu}{\\partial x'^{\\,\\mu}}B_\\nu\\).\nGradient of scalar: \\(\\partial_\\mu\\Phi\\) is a covector.\nMetric lowers: \\(A_\\mu=g_{\\mu\\nu}A^\\nu\\); inverse metric raises: \\(A^\\mu=g^{\\mu\\nu}A_\\nu\\).\nInvariant scalar: \\(A^\\mu B_\\mu\\) (and more generally, any full contraction).\nRank-\\(n\\) tensor: product of \\(n\\) Jacobian factors, one per index; up indices get \\(\\partial x'/\\partial x\\), down indices get \\(\\partial x/\\partial x'\\).\nTensor algebra: sum (same type), tensor product (add rank), contraction (−2 rank), raise/lower (same rank).\nCaveat: \\(\\partial_\\nu A^\\mu\\) is not a tensor in general; use covariant derivatives in curved/accelerated coordinates.",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "张量方程"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/2. Einstein Summation Convention.html",
    "href": "content/notes/理论/广义相对论/广义相对论理论/2. Einstein Summation Convention.html",
    "title": "Einstein求和约定",
    "section": "",
    "text": "Let \\(e=\\{e_1,\\dots,e_n\\}\\) be the standard orthonormal basis in \\(\\mathbb{R}^n\\).\n### 1.1.1 Orthonormality \\[\ne_i\\cdot e_j=\\delta_{ij}\\quad\\text{where}\\quad\n\\delta_{ij}=\\begin{cases}1,& i=j\\\\[2pt]0,& i\\neq j.\\end{cases}\n\\] ### 1.1.2 Vectors Every vector \\({} a\\in \\mathbb{R}^n\\) can be written as a linear combination of the basis \\[a=c_1 e_1+c_2 e_2+\\cdots+c_n e_n=\\sum_{i=1}^n c_i e_i\\] for some unique scalar \\(c_{i}\\).\nIn other words:\n\\[\na=\\begin{bmatrix}a_1\\\\a_2\\\\\\vdots\\\\a_n\\end{bmatrix}=\\sum_{i=1}^{n} a_{i}e_{i}\n\\]\nand as basis expansions,\n\\[\na=\\sum_{i=1}^n a_i\\,e_i,\\qquad b=\\sum_{j=1}^n b_j\\,e_j.\n\\]\n\\[\n\\begin{aligned}\na\\cdot b &= a^\\top b = \\begin{bmatrix}a_1 & a_2 & \\cdots & a_n\\end{bmatrix}\n\\begin{bmatrix}b_1\\\\ b_2\\\\ \\vdots\\\\ b_n\\end{bmatrix} \\\\\n&= a_1 b_1 + a_2 b_2 + \\cdots + a_n b_n \\\\\n&= \\sum_{i=1}^n a_i b_i \\\\\n&= \\Big(\\sum_{i=1}^n a_i e_i\\Big)\\!\\cdot\\!\\Big(\\sum_{j=1}^n b_j e_j\\Big) \\\\\n&= \\sum_{i=1}^n\\sum_{j=1}^n a_i b_j(e_i\\cdot e_j) \\\\\n&= \\sum_{i=1}^n\\sum_{j=1}^n a_i b_j\\delta_{ij} \\\\\n&= \\sum_{i=1}^n a_i b_i \\\\\n&= a_i b_i \\qquad\\text{(Einstein)}\n\\end{aligned}\n\\]\n\n\n\n\\[\n[a_1,a_2,a_3]\\cdot[b_1,b_2,b_3]\n\\;=\\; a_1b_1+a_2b_2+a_3b_3\n\\;=\\; a_i b_i\\quad(\\text{Einstein}).\n\\]\nAlso, the squared norm is just a special case:\n\\[\n\\|a\\|^2=a\\cdot a=\\sum_{i=1}^n a_i a_i\\;=\\;a_i a_i.\n\\]",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "Einstein求和约定"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/2. Einstein Summation Convention.html#set-up-space-basis-components",
    "href": "content/notes/理论/广义相对论/广义相对论理论/2. Einstein Summation Convention.html#set-up-space-basis-components",
    "title": "Einstein求和约定",
    "section": "",
    "text": "Let \\(e=\\{e_1,\\dots,e_n\\}\\) be the standard orthonormal basis in \\(\\mathbb{R}^n\\).\n### 1.1.1 Orthonormality \\[\ne_i\\cdot e_j=\\delta_{ij}\\quad\\text{where}\\quad\n\\delta_{ij}=\\begin{cases}1,& i=j\\\\[2pt]0,& i\\neq j.\\end{cases}\n\\] ### 1.1.2 Vectors Every vector \\({} a\\in \\mathbb{R}^n\\) can be written as a linear combination of the basis \\[a=c_1 e_1+c_2 e_2+\\cdots+c_n e_n=\\sum_{i=1}^n c_i e_i\\] for some unique scalar \\(c_{i}\\).\nIn other words:\n\\[\na=\\begin{bmatrix}a_1\\\\a_2\\\\\\vdots\\\\a_n\\end{bmatrix}=\\sum_{i=1}^{n} a_{i}e_{i}\n\\]\nand as basis expansions,\n\\[\na=\\sum_{i=1}^n a_i\\,e_i,\\qquad b=\\sum_{j=1}^n b_j\\,e_j.\n\\]\n\\[\n\\begin{aligned}\na\\cdot b &= a^\\top b = \\begin{bmatrix}a_1 & a_2 & \\cdots & a_n\\end{bmatrix}\n\\begin{bmatrix}b_1\\\\ b_2\\\\ \\vdots\\\\ b_n\\end{bmatrix} \\\\\n&= a_1 b_1 + a_2 b_2 + \\cdots + a_n b_n \\\\\n&= \\sum_{i=1}^n a_i b_i \\\\\n&= \\Big(\\sum_{i=1}^n a_i e_i\\Big)\\!\\cdot\\!\\Big(\\sum_{j=1}^n b_j e_j\\Big) \\\\\n&= \\sum_{i=1}^n\\sum_{j=1}^n a_i b_j(e_i\\cdot e_j) \\\\\n&= \\sum_{i=1}^n\\sum_{j=1}^n a_i b_j\\delta_{ij} \\\\\n&= \\sum_{i=1}^n a_i b_i \\\\\n&= a_i b_i \\qquad\\text{(Einstein)}\n\\end{aligned}\n\\]",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "Einstein求和约定"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/2. Einstein Summation Convention.html#sanity-check-n3-fully-expanded",
    "href": "content/notes/理论/广义相对论/广义相对论理论/2. Einstein Summation Convention.html#sanity-check-n3-fully-expanded",
    "title": "Einstein求和约定",
    "section": "",
    "text": "\\[\n[a_1,a_2,a_3]\\cdot[b_1,b_2,b_3]\n\\;=\\; a_1b_1+a_2b_2+a_3b_3\n\\;=\\; a_i b_i\\quad(\\text{Einstein}).\n\\]\nAlso, the squared norm is just a special case:\n\\[\n\\|a\\|^2=a\\cdot a=\\sum_{i=1}^n a_i a_i\\;=\\;a_i a_i.\n\\]",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "Einstein求和约定"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/几何基础/index.html",
    "href": "content/notes/理论/广义相对论/几何基础/index.html",
    "title": "几何基础",
    "section": "",
    "text": "无匹配项",
    "crumbs": [
      "Notes",
      "广义相对论",
      "几何基础"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/index.html",
    "href": "content/notes/理论/广义相对论/index.html",
    "title": "广义相对论",
    "section": "",
    "text": "Einstein求和约定\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n几何基础\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n四维向量\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n广义相对论理论\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n张量方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指标\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "广义相对论"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html",
    "title": "Gaussian Integral Computation",
    "section": "",
    "text": "Step 1: Evaluate integral \\(\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy\\) by polar coordinates.\nLet \\(D_R = \\{(x,y) \\in \\mathbb{R}^2 : x^2+y^2 \\leq R^2\\}\\)\n\\[\\int_{D_R} e^{-x^2-y^2} dxdy = \\int_0^{2\\pi} \\int_0^R e^{-r^2} r dr d\\theta\\]\n\\[= \\int_0^{2\\pi} \\left(-\\frac{1}{2} e^{-r^2}\\right)\\bigg|_0^R d\\theta = 2\\pi \\left(\\frac{1}{2} - \\frac{1}{2}e^{-R^2}\\right)\\]\nThe boxed result: \\[\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy = \\pi\\]\nStep 2: Evaluate \\(\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy\\) by Fubini’s Theorem\n\\[\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy = \\lim_{b \\to \\infty} \\int_{-b}^b \\int_{-b}^b e^{-x^2-y^2} dxdy\\]\n\\[= \\lim_{b \\to \\infty} \\int_{-b}^b \\left(\\int_{-b}^b e^{-x^2} dx\\right) \\left(\\int_{-b}^b e^{-y^2} dy\\right)\\]\n\\[= \\left(\\int_{-\\infty}^{\\infty} e^{-x^2} dx\\right)^2\\]\n\n\n\n\\[\\pi = \\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy = \\left(\\int_{-\\infty}^{\\infty} e^{-x^2} dx\\right)^2\\]\nTherefore: \\[\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}\\]\n\n\n\n\n\\(\\int_{\\mathbb{R}^3} \\frac{1}{x^2+y^2+z^2} dxdydz\\)\n\\(\\int_R z e^{-x^2-y^2} dxdydz\\), \\(R = \\{(x,y,z) : |z| \\leq 2\\}\\)\n\n\n\n\n\n\n\nGeneral Idea: Try to decompose certain objects into simpler components\nAlgebraic model: \\(\\mathbb{R}^n\\) \\[X = \\sum_{i=1}^n x_i e_i\\]\n\n\n\n\\[f(x) = \\sum_{n=0}^{\\infty} c_n (x-a)^n\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#exercise-compute-integral-int_-inftyinfty-e-x2-dx.",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#exercise-compute-integral-int_-inftyinfty-e-x2-dx.",
    "title": "Gaussian Integral Computation",
    "section": "",
    "text": "Step 1: Evaluate integral \\(\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy\\) by polar coordinates.\nLet \\(D_R = \\{(x,y) \\in \\mathbb{R}^2 : x^2+y^2 \\leq R^2\\}\\)\n\\[\\int_{D_R} e^{-x^2-y^2} dxdy = \\int_0^{2\\pi} \\int_0^R e^{-r^2} r dr d\\theta\\]\n\\[= \\int_0^{2\\pi} \\left(-\\frac{1}{2} e^{-r^2}\\right)\\bigg|_0^R d\\theta = 2\\pi \\left(\\frac{1}{2} - \\frac{1}{2}e^{-R^2}\\right)\\]\nThe boxed result: \\[\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy = \\pi\\]\nStep 2: Evaluate \\(\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy\\) by Fubini’s Theorem\n\\[\\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy = \\lim_{b \\to \\infty} \\int_{-b}^b \\int_{-b}^b e^{-x^2-y^2} dxdy\\]\n\\[= \\lim_{b \\to \\infty} \\int_{-b}^b \\left(\\int_{-b}^b e^{-x^2} dx\\right) \\left(\\int_{-b}^b e^{-y^2} dy\\right)\\]\n\\[= \\left(\\int_{-\\infty}^{\\infty} e^{-x^2} dx\\right)^2\\]\n\n\n\n\\[\\pi = \\int_{\\mathbb{R}^2} e^{-x^2-y^2} dxdy = \\left(\\int_{-\\infty}^{\\infty} e^{-x^2} dx\\right)^2\\]\nTherefore: \\[\\int_{-\\infty}^{\\infty} e^{-x^2} dx = \\sqrt{\\pi}\\]\n\n\n\n\n\\(\\int_{\\mathbb{R}^3} \\frac{1}{x^2+y^2+z^2} dxdydz\\)\n\\(\\int_R z e^{-x^2-y^2} dxdydz\\), \\(R = \\{(x,y,z) : |z| \\leq 2\\}\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#ch-10.-fourier-analysis",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#ch-10.-fourier-analysis",
    "title": "Gaussian Integral Computation",
    "section": "",
    "text": "General Idea: Try to decompose certain objects into simpler components\nAlgebraic model: \\(\\mathbb{R}^n\\) \\[X = \\sum_{i=1}^n x_i e_i\\]\n\n\n\n\\[f(x) = \\sum_{n=0}^{\\infty} c_n (x-a)^n\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#goal-decompose-a-function-fx-into-a-linear-combination-of-basis",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#goal-decompose-a-function-fx-into-a-linear-combination-of-basis",
    "title": "Gaussian Integral Computation",
    "section": "Goal: Decompose a function \\(f(x)\\) into a “linear combination of basis”:",
    "text": "Goal: Decompose a function \\(f(x)\\) into a “linear combination of basis”:\n\\[f(x) = \\sum_{n=-\\infty}^{\\infty} c_n \\phi_n(x)\\]\nPhysical motivation: Decompose complicated waves into harmonics.",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#ii.-inner-product-space-of-functions",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#ii.-inner-product-space-of-functions",
    "title": "Gaussian Integral Computation",
    "section": "II. Inner Product Space of Functions",
    "text": "II. Inner Product Space of Functions\n\nA. Basic Concepts\n\nDef: Let \\(V\\) be a (complex) vector space. An inner product on \\(V\\) is a map: \\(\\langle \\cdot, \\cdot \\rangle: V \\times V \\to \\mathbb{C}\\) with:\n\n\n\\(\\forall f, g, h \\in V\\)\n\nLinearity: \\(\\langle \\alpha f + h, g \\rangle = \\alpha \\langle f, g \\rangle + \\langle h, g \\rangle\\)\n\n\nConjugate Symmetry: \\(\\langle f, g \\rangle = \\overline{\\langle g, f \\rangle}\\)\n\n\nPositive definite: \\(\\langle f, f \\rangle &gt; 0\\) when \\(f \\neq 0\\)\n\n\n\n\nB. \\(\\mathbb{C}\\) is inner product space under the inner product:\n\\[\\langle z, w \\rangle = z\\overline{w}\\]\n\nExamples:\n\\(\\langle i, i+1 \\rangle = i\\overline{(i+1)} = i(-i+1) = 1+i\\)\n\\(= \\langle z, w \\rangle = z\\overline{w} = (x+iy)(u-iv) = xu+yv+i(yu-xv)\\)\n\\(= \\langle \\vec{x}, \\vec{y} \\rangle = \\vec{x} \\cdot \\vec{y}\\)\n\n\n\n(b). Notion of distance (induced by inner product)\nNorm: \\(||f|| = \\sqrt{\\langle f, f \\rangle}\\)\nDistance: \\(d(f, g) = ||f - g||\\)\nFacts: * \\((V, ||\\cdot||)\\) is a normed space * \\((V, d)\\) is a metric space * Cauchy-Schwarz Ineq.\n\\(|\\langle f, g \\rangle| \\leq ||f|| \\cdot ||g||\\)\n\nProof:\n\\(0 \\leq ||f - \\langle f, g \\rangle g||^2 = \\langle f - \\langle f, g \\rangle g, f - \\langle f, g \\rangle g \\rangle\\)\n\\(= \\langle f, f - \\langle f, g \\rangle g \\rangle - \\langle \\langle f, g \\rangle g, f - \\langle f, g \\rangle g \\rangle\\)\n\\(= \\langle f, f \\rangle - \\langle f, \\langle f, g \\rangle g \\rangle - \\langle \\langle f, g \\rangle g, f \\rangle + \\langle \\langle f, g \\rangle g, \\langle f, g \\rangle g \\rangle\\)\n\\(= ||f||^2 - \\langle f, g \\rangle \\overline{\\langle f, g \\rangle} - \\langle f, g \\rangle \\langle g, f \\rangle + |\\langle f, g \\rangle|^2 ||g||^2\\)\n\\(= ||f||^2 - |\\langle f, g \\rangle|^2 - |\\langle f, g \\rangle|^2 + |\\langle f, g \\rangle|^2 ||g||^2\\)\n\\(= ||f||^2 - |\\langle f, g \\rangle|^2 (1 - ||g||^2)\\)\n\\(\\Rightarrow |\\langle f, g \\rangle|^2 \\leq ||f||^2 \\cdot ||g||^2\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#c.-convergence-in-v",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#c.-convergence-in-v",
    "title": "Gaussian Integral Computation",
    "section": "(C). Convergence in \\(V\\)",
    "text": "(C). Convergence in \\(V\\)\nLet \\(f_n, f \\in V\\). Say \\(f_n \\to f\\) in \\(V\\)\nif \\(\\|f_n-f\\| \\to 0\\) as \\(n \\to \\infty\\).\n(Convergence in norm)",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#the-space-mathbbcinfty-and-l2",
    "href": "content/notes/理论/实分析/第十章/10.1 Fourier Analysis.html#the-space-mathbbcinfty-and-l2",
    "title": "Gaussian Integral Computation",
    "section": "2. The Space \\(\\mathbb{C}^\\infty\\) and \\(L^2\\)",
    "text": "2. The Space \\(\\mathbb{C}^\\infty\\) and \\(L^2\\)\n\\(L^2 = \\{f:[a,b] \\to \\mathbb{C} \\mid \\int_a^b |f(x)|^2 dx &lt; \\infty\\}\\)\n\nIntegral of Complex-Valued functions:\n\\(f(x) = f_1(x) + i f_2(x) : [a,b] \\to \\mathbb{C}\\)\nwhere \\(f_1(x), f_2(x) : [a,b] \\to \\mathbb{R}\\)\nThen \\(\\int_a^b f(x)dx = \\int_a^b f_1(x)dx + i\\int_a^b f_2(x)dx\\)\n\n\nFix interval \\([a,b]\\)\n\\(\\mathbb{C}^\\infty = \\{f(x) \\mid f:[a,b] \\to \\mathbb{C} \\text{ continuous}\\}\\)\n\n\nFact: \\(\\mathbb{C}^\\infty, L^2\\) are vector spaces:\n\nZero Vector in $\\mathbb{C",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章",
      "Gaussian Integral Computation"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第六章/6.9 Taylor Higher Dimentions.html",
    "href": "content/notes/理论/实分析/第六章/6.9 Taylor Higher Dimentions.html",
    "title": "6.9 泰勒公式的高维形式",
    "section": "",
    "text": "\\[\nR_{r-1} = \\frac{1}{r!} D^{(r)} f(\\xi) (x-x_0, \\dots, x-x_0)\n\\] And satisfying \\[\n\\frac{R_{r-1}(x_0)}{\\|x - x_0\\|^{r-1}} \\to 0 \\quad \\text{as} \\quad x \\to x_0.\n\\] \\begin{proof} Consider 1-variable function: \\[\ng(t) = f(x_0 + t(x - x_0)), \\quad (a, b) \\to \\mathbb{R}\n\\] for \\(t\\in (a, b)\\) with \\([0, 1] \\subset (a, b)\\).\n\nApplying Taylor’s theorem to \\(g(t)\\): \\[\n\\begin{align}\ng(1) &= g(0) + g'(0)(1-0) + \\frac{g''(0)}{2!} (1-0)^2 + \\dots + \\frac{g^{(r-1)}(0)}{(r-1)!} (1-0)^{r-1} + R_{r-1}\\\\\nf(x) &= f(x_0) + \\sum_{k=1}^{r-1} \\frac{g^{(k)}(0)}{k!} + \\frac{1}{r!} g^{(r)}(\\tilde{c}), \\quad \\tilde{c} \\in [0,1]\n\\end{align}\n\\] By chain rule, \\[ g'(t) = Df(\\varphi(t)) \\cdot \\varphi'(t) \\] \\[g'(0) = Df(x_0) (x - x_0) \\] \\end{proof} ### #Example Determine the \\(2\\text{nd}\\) order Taylor formula for \\[f(x,y)=e^{(x-1)^{2}}\\cos (y)\\quad \\text{at}\\,(1,0)\\] Solution (compute partials): \\[\n\\begin{align}\n\\frac{\\partial f}{\\partial x} &= e^{(x-1)^2} 2(x-1) \\cos y, \\quad\n\\frac{\\partial f}{\\partial y} = -e^{(x-1)^2} \\sin y, \\\\\n\\frac{\\partial^2 f}{\\partial x^2} &= 2 e^{(x-1)^2} \\cos y + 4(x-1)^2 e^{(x-1)^2} \\cos y, \\\\\n\\frac{\\partial^2 f}{\\partial x \\partial y} &= -2 (x-1) e^{(x-1)^2} \\sin y, \\qquad\n\\frac{\\partial^2 f}{\\partial y^2} = -e^{(x-1)^2} \\cos y.\n\\end{align}\n\\]\nTaylor’s Formula: Let \\(h = x - x_0 = (x,y) - (1,0)\\), then we have\n\\[\n\\boxed{f(x,y) = f(1,0) + \\mathbb{D}f(1,0)(h) + \\frac{1}{2} \\mathbb{D}^2 f(1,0)(h,h) + R_2}\n\\] \\[\nf(1,0) = 1, \\quad \\mathbb{D}f(1,0) = (0 \\quad 0),\n\\] \\[\n\\mathbb{D}^2 f(1,0) =\n\\begin{bmatrix}\n2 & 0 \\\\\n0 & -1\n\\end{bmatrix}\n\\] Evaluating the second-order term: \\[\n\\begin{align}\n\\mathbb{D}^2 f(1,0)(h,h) &=\n\\begin{bmatrix}\nx-1 & y\n\\end{bmatrix}\n\\begin{bmatrix}\n2 & 0 \\\\\n0 & -1\n\\end{bmatrix}\n\\begin{bmatrix}\nx-1 \\\\\ny\n\\end{bmatrix} \\\\\n&= 2(x-1)^2 - y^2\n\\end{align}\n\\]\nThus, \\[f(x,y) = 1 + \\frac{1}{2} (2(x-1)^2 - y^2) + R_2\n\\] # 3 Maximum and Minimum Problem in \\(\\mathbb{R}^n\\) ## 3.1 Introduction Q: Given \\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\), &gt; how do we find (local) max or min points for \\(f\\) in \\(A\\)?\nRecall 1-D case: \\(f: (a,b) \\to \\mathbb{R}\\) - A local max / min point (or extreme point) \\(x_0\\) must be a critical point: \\[\n\\boxed{f'(x_0) = 0 \\quad \\text{or\\quad DNE}}   \n\\] ## 3.2 Second Derivative Test (for a critical point) \\[\n\\begin{aligned}\n    f''(x_0) &gt; 0 &\\Rightarrow x_0 \\text{ is a local minimum} \\\\\n    f''(x_0) &lt; 0 &\\Rightarrow x_0 \\text{ is a local maximum}\n\\end{aligned}\n\\] ## 4. Necessary Condition for Extreme Points in \\(\\mathbb{R}^n\\)\nDefinition: Let \\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\).\nA point \\(x_0 \\in A\\) is a local minimum if: \\[\n\\exists \\delta &gt; 0 \\text{ such that } \\| x - x_0 \\| &lt; \\delta, x \\in A \\Rightarrow f(x) \\geq f(x_0)\n\\] A point \\(x_0 \\in A\\) is a local maximum if: \\[\n\\exists \\delta &gt; 0 \\text{ such that } \\| x - x_0 \\| &lt; \\delta, x \\in A \\Rightarrow f(x) \\leq f(x_0)\n\\]\n\n[!theorem|6.9.2] If \\(f: A \\to \\mathbb{R}\\) is differentiable at \\(x_0\\), and if \\(x_0 \\in A\\) is an extreme point for \\(f\\), then \\(x_0\\) is a critical point, i.e., \\[ Df(x_0) = 0. \\] ## Remark The condition \\(\\mathbb{D}f(x_0) = 0\\) is necessary, but not sufficient! ## Example Let \\(f(x,y) = x^2 - y^2\\), then \\(\\mathbb{D}f(0,0) = 0\\), but \\((0,0)\\) is a saddle point.\n\n\n\\begin{proof}\nAssume \\(Df(x_0) \\neq 0\\).\nThen, there exists \\(v \\in \\mathbb{R}^n\\) such that \\(Df(x_0)(v) = c &gt; 0\\). By the definition of differentiability, choose \\(\\delta &gt; 0\\) such that: \\[\n\\| f(x_0 + h) - f(x_0) - Df(x_0)(h) \\| &lt; \\frac{c}{2 \\| v \\|} \\| h \\|\n\\] for all \\(\\| h \\| &lt; \\delta\\).\nNow, choose \\(h = \\lambda v\\) with \\(\\lambda &gt; 0\\) and \\(\\| h \\| &lt; \\delta\\), then: \\[\n\\begin{cases}\n    f(x_0 + \\lambda v) - f(x_0) &gt; 0 \\\\\n    f(x_0 - \\lambda v) - f(x_0) &lt; 0\n\\end{cases}\n\\] This establishes the desired contradiction. \\end{proof}",
    "crumbs": [
      "Notes",
      "实分析",
      "第六章 可微映射",
      "6.9 泰勒公式的高维形式"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/index.html",
    "href": "content/notes/理论/实分析/第八章/index.html",
    "title": "第八章 度量理论",
    "section": "",
    "text": "1.1 积分的定义\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.5 不定积分\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.6 勒贝格收敛定理\n\n\n\n\n\n\n\n\n2025年3月27日\n\n\n\n\n\n\n\n\n\n\n\n\nCriterion for Integrability\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProof of the Theorem\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.5 Improper Integral.html",
    "href": "content/notes/理论/实分析/第八章/8.5 Improper Integral.html",
    "title": "8.5 不定积分",
    "section": "",
    "text": "WTS: Study integral of the form \\(\\int_A f(x)\\), where \\(f : A \\subset \\mathbb{R}^n \\rightarrow \\mathbb{R}\\) is an arbitrary function and \\(A \\subset \\mathbb{R}^n\\) is an arbitrary set.\n\n\n\nIf \\(A \\subset \\mathbb{R}^n\\) is bounded and \\(f\\) is bounded, then \\[\\int_A f(x) = \\int_{\\overline{A}} f(x) = \\underline{\\int_{A}} f(x) \\quad \\text{(Riemann Condition)}\\]\n\\(f(x) \\geq 0\\) bounded and \\(A\\) is arbitrary, then \\[\\int_A f(x) = \\lim_{a\\to\\infty} \\int_{A_a} f(x)\\]\n\\(A \\subset \\mathbb{R}^n\\)\n\\(A_a = [-a, a]^n\\)\n\\(f(x) \\geq 0\\) unbounded and \\(A\\) is arbitrary.\nFor \\(M &gt; 0\\), define \\[f_M(x) =\n\\begin{cases}\nf(x) & \\text{for } f(x) \\leq M \\\\\n0 & \\text{o/w}.\n\\end{cases}\\]\nThen, \\(\\int_A f(x) = \\lim_{M\\to\\infty} \\int_A f_M(x)\\).\n\\(f\\) is arbitrary and \\(A\\) is arbitrary.\nLet \\[f^+(x) =\n\\begin{cases}\nf(x) & f(x) \\geq 0 \\\\\n0 & f(x) &lt; 0,\n\\end{cases}\\]\nand\n\\[f^-(x) =\n\\begin{cases}\n0 & f(x) \\geq 0 \\\\\n-f(x) & f(x) &lt; 0.\n\\end{cases}\\]\n\nRemark 8.5 1. \\(f^+(x)\\) is the positive part of \\(f\\) and \\(f^-(x)\\) is the negative part of \\(f\\). 2. \\(f^+, f^- \\geq 0\\). 3. \\(f(x) = f^+(x) - f^-(x)\\). We can write any function as the difference of two non-negative functions. 4. \\(|f(x)| = f^+(x) + f^-(x)\\).\nSo, \\(f\\) is integrable on \\(A\\) if both \\(f^+\\) and \\(f^-\\) are integrable on \\(A\\). We write \\[\\int_A f(x) = \\int_A f^+(x) - \\int_A f^-(x).\\]\nRemark 8.6 1. One can show this definition preserves linearity of integral from bounded case. 2. Observation: \\(f\\) integrable \\(\\Rightarrow\\) \\(f^+\\) and \\(f^-\\) integrable \\(\\Rightarrow\\) \\(|f| = f^+ + f^-\\) is also integrable. However, \\(|f|\\) integrable \\(\\nRightarrow\\) \\(f\\) integrable. For counterexample, \\[f(x) =\n   \\begin{cases}\n   1 & x \\text{ rational} \\\\\n   -1 & x \\text{ irrational}\n   \\end{cases}\n   \\text{ on } [0, 1].\\] \\(|f(x)| \\equiv 1 \\Rightarrow\\) integrable. But \\(f^+, f^-\\), or \\(f\\) are not integrable.\n\n\n\nSuppose - \\(0 \\leq g \\leq f\\) on \\(A\\) and \\(\\int_A f\\) converges (i.e., \\(f\\) is integrable on \\(A\\)) - \\(g\\) is integrable on each finite rectangle \\([-a, a]^n\\).\nThen, \\(g\\) is also integrable on \\(A\\), and \\(\\int_A g \\leq \\int_A f\\).\nRemark 8.7 The second condition is crucial and cannot be removed.\nProof 1. Since \\(g \\geq 0\\) and is integrable on \\([-a, a]^n\\), define \\[G(a) = \\int_{[-a,a]^n} g(x).\\]\nThen, \\(G(a)\\) is an increasing function of \\(a\\). Furthermore, \\[g \\leq f \\Rightarrow G(a) = \\int_{[-a,a]^n} g(x) \\leq \\int_{[-a,a]^n} f(x) \\leq \\int_A f(x).\\]\nSo, \\(\\int_A g(x) = \\lim_{a\\to\\infty} G(a) \\leq \\int_A f(x)\\).\nQ.E.D. ■\nQuestion: When does an integrable \\(\\int_a^b f(x)\\) (one-variable function) converge? If it converges, how to compute?\n\n\n\n\nSuppose \\(f : [a, \\infty] \\rightarrow \\mathbb{R}\\) is continuous with \\(f(x) \\geq 0\\). Let \\(F'(x) = f(x)\\). Then, \\[\\int_a^{\\infty} f(x) dx = \\lim_{b\\to\\infty} \\int_a^b f(x) dx = \\lim_{b\\to\\infty} [F(b) - F(a)].\\]\nSuppose \\(f : (a, b] \\rightarrow \\mathbb{R}\\) is continuous with \\(f(x) \\geq 0\\). Then, \\[\\int_a^b f(x) dx = \\lim_{\\varepsilon\\to0^+} \\int_{a+\\varepsilon}^b f(x) dx.\\]\n\n\n\n\n\nConsider \\(\\int_1^{\\infty} x^p dx\\).\nSolution 2.\nFor \\(b \\geq 1\\), \\[\\int_1^b x^p dx =\n\\begin{cases}\n\\ln b & p = -1 \\\\\n\\frac{1}{p + 1}(b^{p+1} - 1) & p \\neq -1.\n\\end{cases}\\]\nWhen \\(b \\to \\infty\\), \\(\\int_1^b x^p dx\\) diverges when \\(p \\geq -1\\) and converges when \\(p &lt; -1\\). So,\n\\(\\int_1^{\\infty} x^p dx\\) is divergent when \\(p \\geq -1\\)\nand\n\\(\\int_1^{\\infty} x^p dx = -\\frac{1}{p + 1}\\) is convergent when \\(p &lt; -1\\).\nConsider \\(\\int_1^{\\infty} e^{-x^2}x^3 dx\\).\nSolution 3.\nConverges by comparison.\n\n\n\n\n\\[\\int_a^{\\infty} f(x) dx \\text{ (conditional)} = \\lim_{b\\to\\infty} \\int_a^b f(x) dx.\\]\nRemark 8.8 (Types of Convergence) For an improper integral \\(\\int_a^{\\infty} f(x) dx\\), there are three types of convergence:\n\nAbsolute Convergence: \\(\\int_a^{\\infty} |f(x)| dx\\) exists.\nConditional Convergence: \\(\\lim_{b\\to\\infty} \\int_a^b f(x) dx\\) exists.\nDivergence.\n\nFor general function, absolute convergence \\(\\nRightarrow\\) conditional convergence. For continuous function, absolute convergence is stronger, and \\(\\Rightarrow\\) conditional convergence.\n\n\n\nDetermine whether the integral \\(\\int_1^{\\infty} \\frac{\\cos x}{x} dx\\) is absolute convergence, conditional convergence, or neither (divergence).\nSolution 4.\n\nFirst, consider absolute convergence.\nObserve that \\[\\int_0^{\\infty} \\left|\\frac{\\cos x}{x}\\right| dx = \\int_1^{\\infty} \\frac{|\\cos x|}{x} dx \\geq \\int_{\\pi/2}^{n\\pi/2} \\frac{|\\cos x|}{x} dx\\]\n\\[= \\sum_{k=1}^{n-1} \\int_{k\\pi/2}^{(k+1)\\pi/2} \\frac{|\\cos x|}{x} dx\\]\n\\[\\geq \\sum_{k=1}^{n-1} \\frac{1}{(k + 1)\\frac{\\pi}{2}} \\int_{k\\pi/2}^{(k+1)\\pi/2} |\\cos x| dx\\]\n\\(\\to \\infty\\) as \\(n \\to \\infty\\).\nSo, \\(\\int_1^{\\infty} \\left|\\frac{\\cos x}{x}\\right| dx\\) diverges, and thus \\(\\int_1^{\\infty} \\frac{\\cos x}{x} dx\\) is not absolutely convergent.\nConditional convergence:\n\\[\\int_1^b \\frac{\\cos x}{x} dx = \\frac{\\sin x}{x}\\Big|_1^b + \\int_1^b \\frac{\\sin x}{x^2} dx \\quad \\text{[Integration by Parts]}\\]\nWhen \\(b \\to \\infty\\), \\[\\lim_{b\\to\\infty} \\frac{\\sin x}{x}\\Big|_1^b = \\frac{\\sin 1}{1} \\quad \\text{converges}.\\]\nFurther, \\[\\left|\\frac{\\sin x}{x^2}\\right| \\leq \\left|\\frac{1}{x^2}\\right| = \\frac{1}{x^2} \\Rightarrow \\int_1^{\\infty} \\left|\\frac{\\sin x}{x^2}\\right| dx \\leq \\int_1^{\\infty} \\frac{1}{x^2} dx.\\]\nSo, \\(\\int_1^{\\infty} \\frac{\\sin x}{x^2} dx\\) absolutely converges by comparison.\nThen, \\(\\int_1^b \\frac{\\cos x}{x} dx\\) is conditional convergence.",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.5 不定积分"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.5 Improper Integral.html#反常积分-improper-integrals",
    "href": "content/notes/理论/实分析/第八章/8.5 Improper Integral.html#反常积分-improper-integrals",
    "title": "8.5 不定积分",
    "section": "",
    "text": "WTS: Study integral of the form \\(\\int_A f(x)\\), where \\(f : A \\subset \\mathbb{R}^n \\rightarrow \\mathbb{R}\\) is an arbitrary function and \\(A \\subset \\mathbb{R}^n\\) is an arbitrary set.\n\n\n\nIf \\(A \\subset \\mathbb{R}^n\\) is bounded and \\(f\\) is bounded, then \\[\\int_A f(x) = \\int_{\\overline{A}} f(x) = \\underline{\\int_{A}} f(x) \\quad \\text{(Riemann Condition)}\\]\n\\(f(x) \\geq 0\\) bounded and \\(A\\) is arbitrary, then \\[\\int_A f(x) = \\lim_{a\\to\\infty} \\int_{A_a} f(x)\\]\n\\(A \\subset \\mathbb{R}^n\\)\n\\(A_a = [-a, a]^n\\)\n\\(f(x) \\geq 0\\) unbounded and \\(A\\) is arbitrary.\nFor \\(M &gt; 0\\), define \\[f_M(x) =\n\\begin{cases}\nf(x) & \\text{for } f(x) \\leq M \\\\\n0 & \\text{o/w}.\n\\end{cases}\\]\nThen, \\(\\int_A f(x) = \\lim_{M\\to\\infty} \\int_A f_M(x)\\).\n\\(f\\) is arbitrary and \\(A\\) is arbitrary.\nLet \\[f^+(x) =\n\\begin{cases}\nf(x) & f(x) \\geq 0 \\\\\n0 & f(x) &lt; 0,\n\\end{cases}\\]\nand\n\\[f^-(x) =\n\\begin{cases}\n0 & f(x) \\geq 0 \\\\\n-f(x) & f(x) &lt; 0.\n\\end{cases}\\]\n\nRemark 8.5 1. \\(f^+(x)\\) is the positive part of \\(f\\) and \\(f^-(x)\\) is the negative part of \\(f\\). 2. \\(f^+, f^- \\geq 0\\). 3. \\(f(x) = f^+(x) - f^-(x)\\). We can write any function as the difference of two non-negative functions. 4. \\(|f(x)| = f^+(x) + f^-(x)\\).\nSo, \\(f\\) is integrable on \\(A\\) if both \\(f^+\\) and \\(f^-\\) are integrable on \\(A\\). We write \\[\\int_A f(x) = \\int_A f^+(x) - \\int_A f^-(x).\\]\nRemark 8.6 1. One can show this definition preserves linearity of integral from bounded case. 2. Observation: \\(f\\) integrable \\(\\Rightarrow\\) \\(f^+\\) and \\(f^-\\) integrable \\(\\Rightarrow\\) \\(|f| = f^+ + f^-\\) is also integrable. However, \\(|f|\\) integrable \\(\\nRightarrow\\) \\(f\\) integrable. For counterexample, \\[f(x) =\n   \\begin{cases}\n   1 & x \\text{ rational} \\\\\n   -1 & x \\text{ irrational}\n   \\end{cases}\n   \\text{ on } [0, 1].\\] \\(|f(x)| \\equiv 1 \\Rightarrow\\) integrable. But \\(f^+, f^-\\), or \\(f\\) are not integrable.\n\n\n\nSuppose - \\(0 \\leq g \\leq f\\) on \\(A\\) and \\(\\int_A f\\) converges (i.e., \\(f\\) is integrable on \\(A\\)) - \\(g\\) is integrable on each finite rectangle \\([-a, a]^n\\).\nThen, \\(g\\) is also integrable on \\(A\\), and \\(\\int_A g \\leq \\int_A f\\).\nRemark 8.7 The second condition is crucial and cannot be removed.\nProof 1. Since \\(g \\geq 0\\) and is integrable on \\([-a, a]^n\\), define \\[G(a) = \\int_{[-a,a]^n} g(x).\\]\nThen, \\(G(a)\\) is an increasing function of \\(a\\). Furthermore, \\[g \\leq f \\Rightarrow G(a) = \\int_{[-a,a]^n} g(x) \\leq \\int_{[-a,a]^n} f(x) \\leq \\int_A f(x).\\]\nSo, \\(\\int_A g(x) = \\lim_{a\\to\\infty} G(a) \\leq \\int_A f(x)\\).\nQ.E.D. ■\nQuestion: When does an integrable \\(\\int_a^b f(x)\\) (one-variable function) converge? If it converges, how to compute?\n\n\n\n\nSuppose \\(f : [a, \\infty] \\rightarrow \\mathbb{R}\\) is continuous with \\(f(x) \\geq 0\\). Let \\(F'(x) = f(x)\\). Then, \\[\\int_a^{\\infty} f(x) dx = \\lim_{b\\to\\infty} \\int_a^b f(x) dx = \\lim_{b\\to\\infty} [F(b) - F(a)].\\]\nSuppose \\(f : (a, b] \\rightarrow \\mathbb{R}\\) is continuous with \\(f(x) \\geq 0\\). Then, \\[\\int_a^b f(x) dx = \\lim_{\\varepsilon\\to0^+} \\int_{a+\\varepsilon}^b f(x) dx.\\]\n\n\n\n\n\nConsider \\(\\int_1^{\\infty} x^p dx\\).\nSolution 2.\nFor \\(b \\geq 1\\), \\[\\int_1^b x^p dx =\n\\begin{cases}\n\\ln b & p = -1 \\\\\n\\frac{1}{p + 1}(b^{p+1} - 1) & p \\neq -1.\n\\end{cases}\\]\nWhen \\(b \\to \\infty\\), \\(\\int_1^b x^p dx\\) diverges when \\(p \\geq -1\\) and converges when \\(p &lt; -1\\). So,\n\\(\\int_1^{\\infty} x^p dx\\) is divergent when \\(p \\geq -1\\)\nand\n\\(\\int_1^{\\infty} x^p dx = -\\frac{1}{p + 1}\\) is convergent when \\(p &lt; -1\\).\nConsider \\(\\int_1^{\\infty} e^{-x^2}x^3 dx\\).\nSolution 3.\nConverges by comparison.\n\n\n\n\n\\[\\int_a^{\\infty} f(x) dx \\text{ (conditional)} = \\lim_{b\\to\\infty} \\int_a^b f(x) dx.\\]\nRemark 8.8 (Types of Convergence) For an improper integral \\(\\int_a^{\\infty} f(x) dx\\), there are three types of convergence:\n\nAbsolute Convergence: \\(\\int_a^{\\infty} |f(x)| dx\\) exists.\nConditional Convergence: \\(\\lim_{b\\to\\infty} \\int_a^b f(x) dx\\) exists.\nDivergence.\n\nFor general function, absolute convergence \\(\\nRightarrow\\) conditional convergence. For continuous function, absolute convergence is stronger, and \\(\\Rightarrow\\) conditional convergence.\n\n\n\nDetermine whether the integral \\(\\int_1^{\\infty} \\frac{\\cos x}{x} dx\\) is absolute convergence, conditional convergence, or neither (divergence).\nSolution 4.\n\nFirst, consider absolute convergence.\nObserve that \\[\\int_0^{\\infty} \\left|\\frac{\\cos x}{x}\\right| dx = \\int_1^{\\infty} \\frac{|\\cos x|}{x} dx \\geq \\int_{\\pi/2}^{n\\pi/2} \\frac{|\\cos x|}{x} dx\\]\n\\[= \\sum_{k=1}^{n-1} \\int_{k\\pi/2}^{(k+1)\\pi/2} \\frac{|\\cos x|}{x} dx\\]\n\\[\\geq \\sum_{k=1}^{n-1} \\frac{1}{(k + 1)\\frac{\\pi}{2}} \\int_{k\\pi/2}^{(k+1)\\pi/2} |\\cos x| dx\\]\n\\(\\to \\infty\\) as \\(n \\to \\infty\\).\nSo, \\(\\int_1^{\\infty} \\left|\\frac{\\cos x}{x}\\right| dx\\) diverges, and thus \\(\\int_1^{\\infty} \\frac{\\cos x}{x} dx\\) is not absolutely convergent.\nConditional convergence:\n\\[\\int_1^b \\frac{\\cos x}{x} dx = \\frac{\\sin x}{x}\\Big|_1^b + \\int_1^b \\frac{\\sin x}{x^2} dx \\quad \\text{[Integration by Parts]}\\]\nWhen \\(b \\to \\infty\\), \\[\\lim_{b\\to\\infty} \\frac{\\sin x}{x}\\Big|_1^b = \\frac{\\sin 1}{1} \\quad \\text{converges}.\\]\nFurther, \\[\\left|\\frac{\\sin x}{x^2}\\right| \\leq \\left|\\frac{1}{x^2}\\right| = \\frac{1}{x^2} \\Rightarrow \\int_1^{\\infty} \\left|\\frac{\\sin x}{x^2}\\right| dx \\leq \\int_1^{\\infty} \\frac{1}{x^2} dx.\\]\nSo, \\(\\int_1^{\\infty} \\frac{\\sin x}{x^2} dx\\) absolutely converges by comparison.\nThen, \\(\\int_1^b \\frac{\\cos x}{x} dx\\) is conditional convergence.",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.5 不定积分"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.2 Criterion for Integrability.html",
    "href": "content/notes/理论/实分析/第八章/8.2 Criterion for Integrability.html",
    "title": "Erise Note",
    "section": "",
    "text": "Q: When is \\(f\\) integrable?\nA: \\(f\\) is integrable when the set of discontinuity is small.\n\n\n\nVolume of \\(A\\)\n\n\n[!definition|8.2.2] A bounded set \\(A \\subset \\mathbb{R}^n\\) has volume (or is Jordan measurable) if its characteristic function: \\[1_A(x) =\n\\begin{cases}\n1, & x \\in A \\\\\n0, & x \\notin A\n\\end{cases} \\] is integrable:\n\n\\[V(A) = \\int_A 1_A(x)\\, dx\\]\nFact: \\(V(A) = 0 \\iff \\forall \\varepsilon &gt; 0, \\exists\\) finite cover of \\(A\\) by rectangles \\(S_1, S_2, \\dots, S_N\\) such that:\n\\[\\sum_{i=1}^N V(S_i) &lt; \\varepsilon\\]\n\n[!definition] A set \\(A \\subset \\mathbb{R}^n\\) (not necessarily bounded) has measure zero, written as \\(m(A) = 0\\), if \\(\\forall \\varepsilon &gt; 0\\), there exists a countable cover of \\(A\\) by rectangles \\(\\{S_i\\}_{i=1}^{\\infty}\\) such that: \\[\\sum_{i=1}^{\\infty} V(S_i) &lt; \\varepsilon\\]\n\n\n\n\nFacts: - \\(V(A) = 0 \\implies m(A) = 0\\) - \\(A\\) is finite \\(\\implies V(A) = 0\\) - \\(A\\) is countable \\(\\implies m(A) = 0\\)\n\n\n[!theorem|8.2.4] Suppose \\(A_i \\subset \\mathbb{R}^n\\) (for \\(i = 1, 2, \\dots\\)) with \\(m(A_i) = 0\\) for all \\(i = 1, 2, \\dots\\). Then, \\[A = \\bigcup_{i=1}^{\\infty} A_i \\text{ has measure zero.}\\]\n\n\n\n\nGiven \\(\\varepsilon &gt; 0\\), for each \\(i = 1, 2, \\dots\\), since \\(m(A_i) = 0\\), there exist rectangles \\(\\{S_j^{(i)}\\}_{j=1}^{\\infty}\\) such that\n\\[\nA_i \\subset \\bigcup_{j=1}^{\\infty} S_j^{(i)}, \\quad \\text{with} \\quad \\sum_{j=1}^{\\infty} V(S_j^{(i)}) &lt; \\frac{\\varepsilon}{2^i}\n\\]\nThen, the set of rectangles \\(\\{S_j^{(i)}\\}_{i,j=1}^{\\infty}\\) forms a countable collection of rectangles with\n\\[A = \\bigcup_{i=1}^{\\infty} A_i \\subset \\bigcup_{i=1}^{\\infty}\\bigcup_{j=1}^{\\infty} S_j^{(i)}\\]\nThus, \\[\\sum_{i=1}^{\\infty}\\sum_{j=1}^{\\infty} V(S_j^{(i)}) &lt; \\sum_{i=1}^{\\infty}\\frac{\\varepsilon}{2^i} = \\varepsilon\\] Therefore, \\(m(A) = 0\\).\n\n\n\n\nRemark: This result is not true for volume zero sets.\n\nCounterexample: Rational numbers in \\([0,1]\\).\n\nRemark: In Definition 2, one can replace closed rectangles \\(S_i\\) by open rectangles.\n\n\nHere’s the content converted into markdown with abbreviations fully written out:\n\n\n\n\n\n\n\n[!theorem|8.3.1] Let \\(A\\) be a bounded set in \\(\\mathbb{R}^n\\) and \\(f\\) be a bounded function on \\(A\\). Extend \\(f\\) to \\(\\mathbb{R}^n\\) by letting: \\[f(x) = 0 \\quad \\text{for} \\quad x \\notin A\\] Then \\(f\\) is integrable on \\(A\\) if and only if the points on which the extended function \\(f\\) is discontinuous form a set of measure zero. \\[D = \\text{Set of discontinuity of extended } f\\]\n\n\n\n\n\n\n\n\\[A = [0, 1], \\quad f(x) =\n\\begin{cases}\n  1, & x \\text{ rational}\\\\]6pt] 0, & \\end{cases}$$\nThen, the set of discontinuity points is \\(D = [0,1]\\), and: \\[m(D) \\neq 0\\]\nBy Lebesgue’s theorem, \\(f\\) is not integrable.\n\n\n\n\\[A = \\{\\text{rationals in }[0,1]\\}, \\quad \\text{Define } f: A \\to \\mathbb{R} \\text{ by } f(x) \\equiv 1\\]\nThen \\(f\\) is continuous on \\(A\\).\nHowever, the extended \\(f\\) has discontinuity at \\([0,1]\\).\nThus, \\(f\\) is NOT integrable by Lebesgue’s theorem.\n\n\n\n\\[A = \\{(x,y): x^2 + y^2 &lt; 1\\} \\subset \\mathbb{R}^2\\]\n\\[f(x,y) =\n\\begin{cases}\nx^2 + \\sin\\left(\\frac{1}{y}\\right), & y \\neq 0 \\\\[6pt]\nx^2, & y = 0\n\\end{cases}\\]\n\n\n\n\n\n\nCorollary 1\nA bounded set \\(A \\subset \\mathbb{R}^n\\) has volume if and only if the boundary of \\(A\\) has measure zero.\nProof:\nAssume \\(V(A)\\) (volume of \\(A\\)) exists. Then the indicator function \\(1_A(x)\\) is integrable.\nThe set of discontinuities for extended \\(f\\): \\[D = \\partial A \\quad (\\text{boundary of } A)\\]\nThus, \\[f = 1_A(x) \\text{ is integrable } \\Longleftrightarrow m(\\partial A) = 0\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "Criterion for Integrability"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.2 Criterion for Integrability.html#criterion-for-integrability",
    "href": "content/notes/理论/实分析/第八章/8.2 Criterion for Integrability.html#criterion-for-integrability",
    "title": "Erise Note",
    "section": "",
    "text": "Q: When is \\(f\\) integrable?\nA: \\(f\\) is integrable when the set of discontinuity is small.\n\n\n\nVolume of \\(A\\)\n\n\n[!definition|8.2.2] A bounded set \\(A \\subset \\mathbb{R}^n\\) has volume (or is Jordan measurable) if its characteristic function: \\[1_A(x) =\n\\begin{cases}\n1, & x \\in A \\\\\n0, & x \\notin A\n\\end{cases} \\] is integrable:\n\n\\[V(A) = \\int_A 1_A(x)\\, dx\\]\nFact: \\(V(A) = 0 \\iff \\forall \\varepsilon &gt; 0, \\exists\\) finite cover of \\(A\\) by rectangles \\(S_1, S_2, \\dots, S_N\\) such that:\n\\[\\sum_{i=1}^N V(S_i) &lt; \\varepsilon\\]\n\n[!definition] A set \\(A \\subset \\mathbb{R}^n\\) (not necessarily bounded) has measure zero, written as \\(m(A) = 0\\), if \\(\\forall \\varepsilon &gt; 0\\), there exists a countable cover of \\(A\\) by rectangles \\(\\{S_i\\}_{i=1}^{\\infty}\\) such that: \\[\\sum_{i=1}^{\\infty} V(S_i) &lt; \\varepsilon\\]\n\n\n\n\nFacts: - \\(V(A) = 0 \\implies m(A) = 0\\) - \\(A\\) is finite \\(\\implies V(A) = 0\\) - \\(A\\) is countable \\(\\implies m(A) = 0\\)\n\n\n[!theorem|8.2.4] Suppose \\(A_i \\subset \\mathbb{R}^n\\) (for \\(i = 1, 2, \\dots\\)) with \\(m(A_i) = 0\\) for all \\(i = 1, 2, \\dots\\). Then, \\[A = \\bigcup_{i=1}^{\\infty} A_i \\text{ has measure zero.}\\]\n\n\n\n\nGiven \\(\\varepsilon &gt; 0\\), for each \\(i = 1, 2, \\dots\\), since \\(m(A_i) = 0\\), there exist rectangles \\(\\{S_j^{(i)}\\}_{j=1}^{\\infty}\\) such that\n\\[\nA_i \\subset \\bigcup_{j=1}^{\\infty} S_j^{(i)}, \\quad \\text{with} \\quad \\sum_{j=1}^{\\infty} V(S_j^{(i)}) &lt; \\frac{\\varepsilon}{2^i}\n\\]\nThen, the set of rectangles \\(\\{S_j^{(i)}\\}_{i,j=1}^{\\infty}\\) forms a countable collection of rectangles with\n\\[A = \\bigcup_{i=1}^{\\infty} A_i \\subset \\bigcup_{i=1}^{\\infty}\\bigcup_{j=1}^{\\infty} S_j^{(i)}\\]\nThus, \\[\\sum_{i=1}^{\\infty}\\sum_{j=1}^{\\infty} V(S_j^{(i)}) &lt; \\sum_{i=1}^{\\infty}\\frac{\\varepsilon}{2^i} = \\varepsilon\\] Therefore, \\(m(A) = 0\\).\n\n\n\n\nRemark: This result is not true for volume zero sets.\n\nCounterexample: Rational numbers in \\([0,1]\\).\n\nRemark: In Definition 2, one can replace closed rectangles \\(S_i\\) by open rectangles.\n\n\nHere’s the content converted into markdown with abbreviations fully written out:\n\n\n\n\n\n\n\n[!theorem|8.3.1] Let \\(A\\) be a bounded set in \\(\\mathbb{R}^n\\) and \\(f\\) be a bounded function on \\(A\\). Extend \\(f\\) to \\(\\mathbb{R}^n\\) by letting: \\[f(x) = 0 \\quad \\text{for} \\quad x \\notin A\\] Then \\(f\\) is integrable on \\(A\\) if and only if the points on which the extended function \\(f\\) is discontinuous form a set of measure zero. \\[D = \\text{Set of discontinuity of extended } f\\]\n\n\n\n\n\n\n\n\\[A = [0, 1], \\quad f(x) =\n\\begin{cases}\n  1, & x \\text{ rational}\\\\]6pt] 0, & \\end{cases}$$\nThen, the set of discontinuity points is \\(D = [0,1]\\), and: \\[m(D) \\neq 0\\]\nBy Lebesgue’s theorem, \\(f\\) is not integrable.\n\n\n\n\\[A = \\{\\text{rationals in }[0,1]\\}, \\quad \\text{Define } f: A \\to \\mathbb{R} \\text{ by } f(x) \\equiv 1\\]\nThen \\(f\\) is continuous on \\(A\\).\nHowever, the extended \\(f\\) has discontinuity at \\([0,1]\\).\nThus, \\(f\\) is NOT integrable by Lebesgue’s theorem.\n\n\n\n\\[A = \\{(x,y): x^2 + y^2 &lt; 1\\} \\subset \\mathbb{R}^2\\]\n\\[f(x,y) =\n\\begin{cases}\nx^2 + \\sin\\left(\\frac{1}{y}\\right), & y \\neq 0 \\\\[6pt]\nx^2, & y = 0\n\\end{cases}\\]\n\n\n\n\n\n\nCorollary 1\nA bounded set \\(A \\subset \\mathbb{R}^n\\) has volume if and only if the boundary of \\(A\\) has measure zero.\nProof:\nAssume \\(V(A)\\) (volume of \\(A\\)) exists. Then the indicator function \\(1_A(x)\\) is integrable.\nThe set of discontinuities for extended \\(f\\): \\[D = \\partial A \\quad (\\text{boundary of } A)\\]\nThus, \\[f = 1_A(x) \\text{ is integrable } \\Longleftrightarrow m(\\partial A) = 0\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "Criterion for Integrability"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/index.html",
    "href": "content/notes/理论/实分析/第九章/index.html",
    "title": "第九章",
    "section": "",
    "text": "积分计算\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/index.html",
    "href": "content/notes/理论/实分析/第七章/index.html",
    "title": "第七章 逆函数和隐函数定理",
    "section": "",
    "text": "7.1 反函数定理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.1.1 反函数定理（证明）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.2 隐函数定理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.6 莫尔斯引理\n\n\n\n\n\n\n\n\n2025年3月22日\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.2 Implicit Function Theorem.html",
    "href": "content/notes/理论/实分析/第七章/7.2 Implicit Function Theorem.html",
    "title": "7.2 隐函数定理",
    "section": "",
    "text": "111",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.2 隐函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html",
    "href": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html",
    "title": "7.1 反函数定理",
    "section": "",
    "text": "Two lines of ideas:\nA: CMP \\(⇒\\) Inverse FT \\(⇒\\) Applications in ODE\nB: IFT \\(⇒\\) Implicit FT \\(⇒\\) Local behavior, extreme problems\n\n\n\n\nConsider a linear map, \\(y = f(x): \\mathbb{R}^n \\to \\mathbb{R}^n\\).\n\\[\nx = (x_1, x_2, \\dots, x_n)^T\n\\]\nGiven \\(y \\in \\mathbb{R}^n\\), \\(f(x)\\) is a linear system of equations:\n\\[\\begin{aligned}\ny_1 &= a_{11} x_1 + a_{12} x_2 + \\dots + a_{1n} x_n \\\\\\\\\ny_2 &= a_{21} x_1 + a_{22} x_2 + \\dots + a_{2n} x_n \\\\\\\\\n&\\vdots \\\\\\\\\ny_n &= a_{n1} x_1 + \\dots + a_{nn} x_n\n\\end{aligned}\\]\nor \\[\nA_{n\\times n}X_{n\\times 1} = Y_{n\\times 1}\n\\]\n\n[!assumption|*] \\[X \\text{ has a unique solution} \\Longleftrightarrow \\det(A) \\neq 0.\\]\n\nIn this case, the solution is given by: \\[\nX = A^{-1} Y\n\\] Thus, the inverse function satisfies: \\[\nf^{-1} \\circ f = \\text{Identity}\n\\] The inverse theorem for \\(y = f(x)\\):\n\\[\nf(f^{-1}(y)) = A A^{-1} y = y\n\\]\n\n\n\nWe consider a system of nonlinear equations: \\[\n\\begin{cases}\n    f_1(x_1, x_2, \\dots, x_n) = y_1 \\\\\\\\\n    f_2(x_1, x_2, \\dots, x_n) = y_2 \\\\\\\\\n    \\quad \\vdots \\\\\\\\\n    f_n(x_1, x_2, \\dots, x_n) = y_n\n\\end{cases}\n\\] or equivalently, \\[\nf(x) = y\n\\] ### 2. The Inverse of a General Function\nNotation:\nLet \\(y = f(x): A \\subset \\mathbb{R}^n \\to \\mathbb{R}^n\\) be a diffeomorphism.\n\\[\ny = (y_1, y_2, \\dots, y_n)\n\\]\nwhere\n\\[\ny_i = f_i(x_1, x_2, \\dots, x_n)\n\\]\nThe Jacobian determinant of \\(f\\) at \\(x\\) is:\n\\[\n\\det \\left( \\frac{\\partial f_i}{\\partial x_j} \\right)\n\\]\n\n[!theorem|7.1.1] Let \\(y = f(x): A \\subset \\mathbb{R}^n \\to \\mathbb{R}^n\\) be of class \\(C^1\\). Suppose \\(x_0 \\in A\\) and \\(\\det(Df(x_0)) \\neq 0\\). Then there exists a neighborhood \\(U\\) of \\(x_0\\) and a neighborhood \\(W\\) of \\(y_0 = f(x_0)\\) such that:\n\n\\(f: U \\to W\\) has an inverse \\(f^{-1}: W \\to U\\).\n\\(f^{-1}\\) is of class \\(C^1\\).\n\\(D(f^{-1}(y)) = (Df(x))^{-1}\\) for all \\(y \\in W\\) at \\(y = f(x)\\).\n\n\n\n\n\n\n\n\n\\(y = f(x)\\) maps from \\(U\\) to \\(W\\).\n\\(x = f^{-1}(y)\\) gives the inverse mapping from \\(W\\) back to \\(U\\). ### Recall: Contraction Mapping Principle (CMP)\n\nLet \\(\\mathbb{X}\\) be a complete metric space and let\n\\[\n\\varphi: \\mathbb{X} \\to \\mathbb{X}\n\\]\nbe a function satisfying a contraction condition for some constant \\(k\\) with \\(0 &lt; k &lt; 1\\):\n\\[\nd(\\varphi(x), \\varphi(y)) \\leq k \\cdot d(x,y), \\quad \\forall x,y \\in \\mathbb{X}.\n\\]\nThen, there exists a unique fixed point \\(X^*\\) such that:\n\\[\n\\varphi(X^*) = X^*.\n\\]\n\n\n\n\n\n\n\n\nMay assume that the Jacobian matrix at \\(x_0\\) is the identity: \\[\nD f(x_0) = I.\n\\] In fact, define the transformation: \\[\nT = D f(x_0).\n\\] Then, we can consider a new function:\n\n\\[\n\\tilde{f} = T^{-1} \\circ f.\n\\]\nThus,\n\\[\nD(\\tilde{f})(x_0) = I.\n\\]\n\nMain assumption:\n\n\\[\nx_0 = f^{-1}(y_0).\n\\]\nTo see this, define:\n\\[\nh(x) = f(x) - f(x_0).\n\\]\nThen,\n\\[\nD h(x_0) = D f(x_0) - D f(x_0) = 0.\n\\]\nIf \\(h^{-1}\\) exists, then \\(y = f(x)\\) can be solved as:\n\\[\nf(x) = h(x) + f(x_0) = y.\n\\]\nThus, the inverse function satisfies:\n\\[\nx = x_0 - h^{-1}(y - f(x_0)).\n\\]\n\n\n\n\n\n\nSetup: By the reduction above, we assume:\n\n\\[\nx_0 = 0, \\quad y_0 = f(x_0) = 0, \\quad D f(x_0) = I.\n\\]\nNeed to show:\nThere exist neighborhoods \\(U\\) and \\(W\\) such that the mapping:\n\\[\ny = f(x): U \\to W\n\\]\nhas an inverse function in \\(W\\), meaning:\n\\[\n\\forall y \\in W, \\quad \\exists! x \\in U \\text{ such that } y = f(x).\n\\]\nIllustration:\nA diagram representing \\(U\\) mapping to \\(W\\) via \\(f\\), where \\(f\\) is invertible.\n\n\n\n\\[\ng_x = g(y) = y + x - f(x).\n\\]\nWe need to show that \\(g_x\\) has a unique fixed point.\n\nConstruction of neighborhoods \\(U\\) and \\(W\\)\n\nLet:\n\\[\ng(x) = x - f(x).\n\\]\nThen:\n\\[\nD g(x) = I - D f(x).\n\\]\nSince:\n\\[\nD g(x_0) = I - I = 0,\n\\]\nit follows that:\n\\[\nD g(x) \\text{ is close to zero}.\n\\]\nThus, choosing:\n\\[\n\\epsilon = \\frac{1}{2n},\n\\]\nthere exists \\(\\delta &gt; 0\\) such that:\n\\[\n\\|x - x_0\\| &lt; \\delta \\implies \\|D g_x(x)\\| \\leq \\frac{1}{2n}.\n\\]\nApplying the Contraction Mapping Principle to \\(g_x\\), we obtain:\n\\[\n\\exists x \\in B_{\\delta}(x_0) \\text{ such that } g_x(x) = x.\n\\]\nThus:\n\\[\ng_x(x) = g_x(x_0) + D g_x(\\xi)(x - x_0),\n\\]\nwhich shows:\n\\[\nD g_x(\\xi) (x - x_0).\n\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1 反函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#i.-inverse-function-theorem",
    "href": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#i.-inverse-function-theorem",
    "title": "7.1 反函数定理",
    "section": "",
    "text": "Consider a linear map, \\(y = f(x): \\mathbb{R}^n \\to \\mathbb{R}^n\\).\n\\[\nx = (x_1, x_2, \\dots, x_n)^T\n\\]\nGiven \\(y \\in \\mathbb{R}^n\\), \\(f(x)\\) is a linear system of equations:\n\\[\\begin{aligned}\ny_1 &= a_{11} x_1 + a_{12} x_2 + \\dots + a_{1n} x_n \\\\\\\\\ny_2 &= a_{21} x_1 + a_{22} x_2 + \\dots + a_{2n} x_n \\\\\\\\\n&\\vdots \\\\\\\\\ny_n &= a_{n1} x_1 + \\dots + a_{nn} x_n\n\\end{aligned}\\]\nor \\[\nA_{n\\times n}X_{n\\times 1} = Y_{n\\times 1}\n\\]\n\n[!assumption|*] \\[X \\text{ has a unique solution} \\Longleftrightarrow \\det(A) \\neq 0.\\]\n\nIn this case, the solution is given by: \\[\nX = A^{-1} Y\n\\] Thus, the inverse function satisfies: \\[\nf^{-1} \\circ f = \\text{Identity}\n\\] The inverse theorem for \\(y = f(x)\\):\n\\[\nf(f^{-1}(y)) = A A^{-1} y = y\n\\]\n\n\n\nWe consider a system of nonlinear equations: \\[\n\\begin{cases}\n    f_1(x_1, x_2, \\dots, x_n) = y_1 \\\\\\\\\n    f_2(x_1, x_2, \\dots, x_n) = y_2 \\\\\\\\\n    \\quad \\vdots \\\\\\\\\n    f_n(x_1, x_2, \\dots, x_n) = y_n\n\\end{cases}\n\\] or equivalently, \\[\nf(x) = y\n\\] ### 2. The Inverse of a General Function\nNotation:\nLet \\(y = f(x): A \\subset \\mathbb{R}^n \\to \\mathbb{R}^n\\) be a diffeomorphism.\n\\[\ny = (y_1, y_2, \\dots, y_n)\n\\]\nwhere\n\\[\ny_i = f_i(x_1, x_2, \\dots, x_n)\n\\]\nThe Jacobian determinant of \\(f\\) at \\(x\\) is:\n\\[\n\\det \\left( \\frac{\\partial f_i}{\\partial x_j} \\right)\n\\]\n\n[!theorem|7.1.1] Let \\(y = f(x): A \\subset \\mathbb{R}^n \\to \\mathbb{R}^n\\) be of class \\(C^1\\). Suppose \\(x_0 \\in A\\) and \\(\\det(Df(x_0)) \\neq 0\\). Then there exists a neighborhood \\(U\\) of \\(x_0\\) and a neighborhood \\(W\\) of \\(y_0 = f(x_0)\\) such that:\n\n\\(f: U \\to W\\) has an inverse \\(f^{-1}: W \\to U\\).\n\\(f^{-1}\\) is of class \\(C^1\\).\n\\(D(f^{-1}(y)) = (Df(x))^{-1}\\) for all \\(y \\in W\\) at \\(y = f(x)\\).\n\n\n\n\n\n\n\n\n\\(y = f(x)\\) maps from \\(U\\) to \\(W\\).\n\\(x = f^{-1}(y)\\) gives the inverse mapping from \\(W\\) back to \\(U\\). ### Recall: Contraction Mapping Principle (CMP)\n\nLet \\(\\mathbb{X}\\) be a complete metric space and let\n\\[\n\\varphi: \\mathbb{X} \\to \\mathbb{X}\n\\]\nbe a function satisfying a contraction condition for some constant \\(k\\) with \\(0 &lt; k &lt; 1\\):\n\\[\nd(\\varphi(x), \\varphi(y)) \\leq k \\cdot d(x,y), \\quad \\forall x,y \\in \\mathbb{X}.\n\\]\nThen, there exists a unique fixed point \\(X^*\\) such that:\n\\[\n\\varphi(X^*) = X^*.\n\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1 反函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#proof-of-the-inverse-function-theorem-ift",
    "href": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#proof-of-the-inverse-function-theorem-ift",
    "title": "7.1 反函数定理",
    "section": "",
    "text": "May assume that the Jacobian matrix at \\(x_0\\) is the identity: \\[\nD f(x_0) = I.\n\\] In fact, define the transformation: \\[\nT = D f(x_0).\n\\] Then, we can consider a new function:\n\n\\[\n\\tilde{f} = T^{-1} \\circ f.\n\\]\nThus,\n\\[\nD(\\tilde{f})(x_0) = I.\n\\]\n\nMain assumption:\n\n\\[\nx_0 = f^{-1}(y_0).\n\\]\nTo see this, define:\n\\[\nh(x) = f(x) - f(x_0).\n\\]\nThen,\n\\[\nD h(x_0) = D f(x_0) - D f(x_0) = 0.\n\\]\nIf \\(h^{-1}\\) exists, then \\(y = f(x)\\) can be solved as:\n\\[\nf(x) = h(x) + f(x_0) = y.\n\\]\nThus, the inverse function satisfies:\n\\[\nx = x_0 - h^{-1}(y - f(x_0)).\n\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1 反函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#step-2-existence-of-the-inverse-function",
    "href": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#step-2-existence-of-the-inverse-function",
    "title": "7.1 反函数定理",
    "section": "",
    "text": "Setup: By the reduction above, we assume:\n\n\\[\nx_0 = 0, \\quad y_0 = f(x_0) = 0, \\quad D f(x_0) = I.\n\\]\nNeed to show:\nThere exist neighborhoods \\(U\\) and \\(W\\) such that the mapping:\n\\[\ny = f(x): U \\to W\n\\]\nhas an inverse function in \\(W\\), meaning:\n\\[\n\\forall y \\in W, \\quad \\exists! x \\in U \\text{ such that } y = f(x).\n\\]\nIllustration:\nA diagram representing \\(U\\) mapping to \\(W\\) via \\(f\\), where \\(f\\) is invertible.\n\n\n\n\\[\ng_x = g(y) = y + x - f(x).\n\\]\nWe need to show that \\(g_x\\) has a unique fixed point.\n\nConstruction of neighborhoods \\(U\\) and \\(W\\)\n\nLet:\n\\[\ng(x) = x - f(x).\n\\]\nThen:\n\\[\nD g(x) = I - D f(x).\n\\]\nSince:\n\\[\nD g(x_0) = I - I = 0,\n\\]\nit follows that:\n\\[\nD g(x) \\text{ is close to zero}.\n\\]\nThus, choosing:\n\\[\n\\epsilon = \\frac{1}{2n},\n\\]\nthere exists \\(\\delta &gt; 0\\) such that:\n\\[\n\\|x - x_0\\| &lt; \\delta \\implies \\|D g_x(x)\\| \\leq \\frac{1}{2n}.\n\\]\nApplying the Contraction Mapping Principle to \\(g_x\\), we obtain:\n\\[\n\\exists x \\in B_{\\delta}(x_0) \\text{ such that } g_x(x) = x.\n\\]\nThus:\n\\[\ng_x(x) = g_x(x_0) + D g_x(\\xi)(x - x_0),\n\\]\nwhich shows:\n\\[\nD g_x(\\xi) (x - x_0).\n\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1 反函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#contraction-mapping-principle-cmp",
    "href": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#contraction-mapping-principle-cmp",
    "title": "7.1 反函数定理",
    "section": "Contraction Mapping Principle (CMP)",
    "text": "Contraction Mapping Principle (CMP)\nLet \\(\\mathbb{X}\\) be a complete metric space, and let \\(\\varphi: \\mathbb{X} \\to \\mathbb{X}\\) satisfy:\n\\[\nd(\\varphi(x), \\varphi(y)) \\leq k \\cdot d(x,y), \\quad 0 &lt; k &lt; 1.\n\\]\nThen, there exists a unique fixed point \\(X^\\*\\) such that \\(\\varphi(X^{\\*}) = X^{\\*}\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1 反函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#proof-of-the-inverse-function-theorem-ift-1",
    "href": "content/notes/理论/实分析/第七章/7.1 Inverse Function Theorem.html#proof-of-the-inverse-function-theorem-ift-1",
    "title": "7.1 反函数定理",
    "section": "Proof of the Inverse Function Theorem (IFT)",
    "text": "Proof of the Inverse Function Theorem (IFT)\n\nStep 1: Reduction\nAssume \\(Df(x_0) = I\\). Define \\(\\tilde{f} = Df(x_0)^{-1} \\circ f\\), ensuring \\(D\\tilde{f}(x_0) = I\\).\nFor \\(x_0 = f^{-1}(y_0)\\), define \\(h(x) = f(x) - f(x_0)\\). Since \\(Dh(x_0) = 0\\), solving \\(f(x) = y\\) reduces to:\n\\[\nx = x_0 - h^{-1}(y - f(x_0)).\n\\]\n\n\n\nStep 2: Existence of the Inverse**\nSet up: \\(x_0 = 0, y_0 = f(x_0) = 0, Df(x_0) = I\\). Need to show a local inverse:\n\\[\n\\forall y \\in W, \\quad \\exists! x \\in U \\text{ such that } y = f(x).\n\\]\nDefine:\n\\[\ng_x(y) = y + x - f(x).\n\\]\nWe need to show \\(g_x\\) has a unique fixed point.\nLet \\(g(x) = x - f(x)\\), then \\(Dg(x) = I - Df(x)\\). Since \\(Dg(x_0) = 0\\), choosing \\(\\epsilon = \\frac{1}{2n}\\) ensures \\(\\|D g_x(x)\\|\\) is small. Applying CMP, we get:\n\\[\n\\exists x \\in B_{\\delta}(x_0) \\text{ such that } g_x(x) = x.\n\\] Thus, the inverse exists and is unique.\nbabeldown::deepl_translate_hugo( post_path = “content.en/docs/Mathematics/MATH 412 Real Analysis II/Lecture/7.1 Inverse Function Theorem.md”, target_lang = “ZH”, source_lang = “EN”, force = TRUE )",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1 反函数定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/index.html",
    "href": "content/notes/理论/实分析/Homework/index.html",
    "title": "Real Analysis II",
    "section": "",
    "text": "无匹配项",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/Homework 8.html",
    "href": "content/notes/理论/实分析/Homework/Homework 8.html",
    "title": "Erise Note",
    "section": "",
    "text": "8.1: 1, [2, 6]; 8.2: [2], 3, 4, 5, [6]; 8.3: [2], 5, 6; Chapter 8: [12].\nProblem 8.1.2 Let \\(f:[0,2] \\rightarrow \\mathbb{R}\\) be defined by \\(f(x)=0\\) for \\(0 \\leq x \\leq 1\\), and by \\(f(x)=1\\) for \\(1&lt;x \\leq 2\\). Compute, using the definition, \\(\\int_0^2 f(x) d x\\).\n\n[!definition] We first define a partition \\(P_{n}\\) on \\([0,2]\\) into \\(n\\) equal subintervals \\(\\Delta x=\\frac{2}{n}\\), s.t. \\[\\left[ 0, \\frac{2}{n} \\right], \\left[ \\frac{2}{n} , \\frac{4}{n} \\right],\\dots,\\left[ \\frac{2(n-1)}{n},2 \\right]\\] Then, each subinterval, we have \\([x_{i-1},x_{i}]=\\left[ \\frac{2(i-1)}{n}, \\frac{2i}{n} \\right]\\). Consider Riemman sum \\(S_n\\) for this partition with any choice of sample points \\(k_{i} \\in [x_{i-1},x_i]\\): \\[\nS_n \\;=\\;\\sum_{k=1}^{n} f(k_{i})\\,\\Delta x\n\\;=\\;\\sum_{k=1}^{n} f(k_{i}) \\cdot \\frac{2}{n}.\n\\] For \\([x_{i-1},\\,x_i]\\subset [0,1]\\), then \\(f(x)=0\\) by definition. Hence \\(f(k_{i}) = 0\\); for \\([x_{i-1},\\,x_i]\\subset (1,2]\\), then \\(f(x)=1\\). Hence \\(f(k_{i}) = 1\\). Then, notice one subinterval, say \\([x_{j-1},\\,x_j]\\), must include \\(x=1\\), and \\(f\\) = 0 or 1 depending on \\(k_{j}\\le 1\\) or \\(k_{j}&gt;1\\). Hence, we have: \\[\n\\inf \\{f(x): x\\in [x_{j-1},x_j]\\} \\;=\\; 0,\n\\quad\n\\sup \\{f(x): x\\in [x_{j-1},x_j]\\} \\;=\\; 1.\n\\] Next, we find a lower bound and an upper bound for \\(S_n\\). For lower bound, suppose subinterval \\([x_{j-1},x_j]\\) contains 1, and we pick \\(j\\) so that \\(f(k_j)=0\\). Let \\(m\\) be the number of intervals inside fully in \\((1,2]\\). Then for those \\(m\\) intervals, we have \\[\n\\begin{align}\nS_n \\;\\ge\\; L(P) =  &  (1)m\\cdot\\Delta x +(0)(n-m)\\cdot\\Delta x\n\\; \\\\\n= & \\; m \\cdot \\frac{2}{n}\n\\end{align}\n\\] Since \\([x_{j},x_{j+1}]\\) begins once \\(x &gt; 1\\), notice that \\(m\\approx \\frac{n}{2}\\) for large \\(n\\). More precisely, we have \\(m \\ge \\frac{n}{2}-1\\). Hence: \\[\nm \\;\\ge\\; \\frac{n}{2} -1\n\\quad\\Longrightarrow\\quad\nS_n\n\\;\\ge\\; \\Bigl(\\frac{n}{2}-1\\Bigr)\\,\\frac{2}{n}\n\\;=\\;\n1 - \\frac{2}{n}.\n\\] Similarly, for upper bound, we pick \\(k_j\\) such that \\(f(k_{j})=1\\). The the number of intervals \\(m\\) entirely in \\((1,2]\\) each contribute 1, so we in total have \\(m+1\\) subintervals to contribute \\(\\Delta x\\). Thus \\[\n\\begin{align}\nS_n\n\\; & \\le\\; U(P)= (1)(m+1)\\cdot \\Delta x \\\\\n\\; & =\\; (m+1)\\,\\frac{2}{n}.\n\\end{align}\n\\] But \\(m \\le \\frac{n}{2}\\) for this case. Hence, \\[\nm+1 \\;\\le\\; \\frac{n}{2} + 1\n\\quad\\Longrightarrow\\quad\nS_n\n\\;\\le\\; \\Bigl(\\frac{n}{2}+1\\Bigr)\\,\\frac{2}{n}\n\\;=\\;\n1 + \\frac{2}{n}.\n\\] Therefore, for every Riemann sum \\(S_n\\): \\[\n1 - \\frac{2}{n}\n\\;\\;\\le\\;\\;\nS_n\n\\;\\;\\le\\;\\;\n1 + \\frac{2}{n}.\n\\] As \\(n\\) grows, the Squeeze Theorem forces each Riemann sum \\(S_n\\) to converge to 1. More precisely, for any \\(\\varepsilon&gt;0\\), choose \\(N\\) large enough s.t. \\(\\forall n \\ge N\\), \\[\n-\\frac{2}{n} &gt; -\\varepsilon\n\\quad\\text{and}\\quad\n\\frac{2}{n} &lt; \\varepsilon,\n\\] which gives \\(\\bigl|S_n - 1\\bigr| &lt; \\varepsilon\\). This shows that \\(\\lim_{n\\to\\infty} S_n = 1\\), so by definition of the Riemann integral, we have \\[\n\\int_{0}^{2} f(x)\\,dx = 1.\n\\]\n\nProblem 8.1.6 Let \\(f:[a, b] \\rightarrow \\mathbb{R}\\) be continuous. Use Riemann’s condition and uniform continuity of \\(f\\) to prove that \\(f\\) is integrable.\n\n[!definition|*] To show that \\(f\\) is Riemann integrable from continuity, we must show that \\(\\forall \\,\\varepsilon&gt;0\\), \\(\\exists\\) partition \\(P\\) of \\([a,b]\\) such that \\[0\\leq U(P_{\\varepsilon})-L(P_{\\varepsilon})&lt;\\varepsilon\\] First, since \\(f\\) is continuous on a closed, bounded interval \\([a,b]\\), then we know it is uniformly continuous by Heine–Cantor theorem. We define \\[\\varepsilon_{0} =\\frac{\\varepsilon}{b-a}\\] Then, by definition of uniform continuity, \\(\\forall \\varepsilon &gt;0\\), there exists \\(\\delta&gt;0\\) s.t. \\(\\forall x,y \\in [a,b]\\), we have \\[|x-y|&lt;\\delta \\Longrightarrow |f(x)-f(y)|&lt;\\varepsilon_{0} =\\frac{\\varepsilon}{b-a}\\] We define a partition \\(P\\) s.t. for each \\([x_{i-1},x_{i}]\\), the subinterval is less than \\(\\delta\\). So \\(P:= \\max(x_{i}-x_{i-1})&lt;\\delta\\) (this is always possible because \\(f\\) is continuous). Next, we set \\[M_i=\\sup _{x \\in\\left[x_{i-1}, x_i\\right]} f(x) \\quad \\text{and} \\quad m_i=\\inf _{x \\in\\left[x_{i-1}, x_i\\right]} f(x)\\] for each subinterval. Notice that by the unform continuity of \\(f\\), we must have \\(M_{i}-m_{i}&lt;\\varepsilon_{0}\\) since the lengths of each interval is awalys strictly less than \\(\\delta\\). Therefore, the difference between upper and lower bound is: \\[\n\\begin{align}\nU(f, P)-L(f, P) & =\\sum_{i=1}^n(M_i\\Delta x_i)-\\sum_{i=1}^n(m_i\\Delta x_i)  \\\\\n& =\\sum_{i=1}^n\\left(M_i-m_i\\right) \\Delta x_i \\\\\n& &lt; (\\frac{\\varepsilon}{b-a})\\sum_{i=1}^n\\Delta x_i    \\\\\n& =(\\frac{\\varepsilon}{b-a})(b-a)   \\\\\n& =\\varepsilon\n\\end{align}\n\\] Therefore, since \\(\\varepsilon\\) is arbitrarily chosen, by Riemann’s criterion for integrability, this implies that \\(f\\) is Riemann integrable on \\([a,b]\\).\n\nProblem 8.2.2 Show that the \\(x y\\) plane in \\(\\mathbb{R}^3\\) has 3-dimensional measure 0.\n\n[!definition|*] We let \\[P=\\{x,y,z\\in \\mathbb{R}^{3}\\,|\\,z =0\\}\\] to be the \\(xy\\) plane in \\(\\mathbb{R}^3\\), with \\(z=0\\). We construct a countable union of rectangular boxes to cover it by defining the box: \\[S_{n}=[-n,n]\\times[-n,n]\\times [-\\delta_{n},\\delta_{n}]\\] with \\(\\delta_{n}&gt;0\\) to be determined. By such construction, every point \\((x,y,0)\\in P\\) lies in some \\(S_{n}\\) since \\(x\\in [-n,n]\\) and \\(y\\in [-n,n]\\). If \\(n\\geq \\max(|x|,|y|)\\), we get \\((x,y,0)\\in S_{n}\\), such that \\[P\\subseteq\\bigcup^{\\infty}_{n=1}S_{n}\\] Then, the volume of \\(S_{n}\\) is given by \\[V(S_{n})=(2n)(2n)(2\\delta_{n})=8n^2\\delta_{n}\\] we want to choose \\(\\delta\\) s.t. the sum of the volumes is less than \\(\\epsilon\\). Notice that \\(\\sum_{n=1}^{\\infty} \\frac{\\varepsilon}{2^n}=\\varepsilon \\sum_{n=1}^{\\infty} \\frac{1}{2^n}=\\varepsilon\\), so a motivated choice is: \\[\\begin{align}\n8 n^2 \\delta_n  & \\leq \\frac{\\varepsilon}{2^n} \\\\\n\\delta_n& \\leq\\frac{\\varepsilon}{2^{n+3} n^2}\n\\end{align}\n\\] Therefore, we define \\(\\delta=\\cfrac{\\varepsilon}{2^{n+3} n^2}\\), then \\[V\\left(S_n\\right)=8 n^2 \\cdot \\frac{\\varepsilon}{2^{n+3} n^2}=\\frac{8 \\varepsilon}{2^{n+3}}=\\frac{\\varepsilon}{2^n}\\] and the total volume of the covering is \\[\\sum_{n=1}^{\\infty} V\\left(S_n\\right)=\\sum_{n=1}^{\\infty} \\frac{\\varepsilon}{2^n}=\\varepsilon \\sum_{n=1}^{\\infty} \\frac{1}{2^n}=\\varepsilon \\cdot 1=\\varepsilon\\] Hence, we have constructed a countable cover \\(\\{S_{n}\\}^\\infty_{n=1}\\) of \\(P\\) whose total volume is precisely \\(\\varepsilon\\). Because \\(\\varepsilon&gt;0\\) was arbitrary. So by Definition 8.2.2 of the textbook, the xy-plane has 3-dimensional measure zero in \\(ℝ³\\).\n\nProblem 8.2.6 Must the boundary of a set of measure zero have measure zero?\n\n[!definition|*] This statement is false. Here is a counterexample: consider the set \\(Q \\cap [0,1]\\). From Example 8.2.5 in the textbook, we know that the set of rational numbers in \\([0,1]\\) has measure zero. However, the boundary of a set \\(A\\) consists of all points \\(x\\) s.t. every neighborhood of \\(x\\) contains at least one point in \\(A\\) and at least one point not in \\(A\\).\nFor any point \\(x \\in [0,1]\\), every neighborhood of \\(x\\) contains both rational and irrational numbers. This is due to the density of both rational and irrational numbers in \\(\\mathbb{R}\\). Therefore: \\[\\partial(Q \\cap [0,1]) = [0,1]\\] Lebesgue measure of \\([0,1]\\) is 1, which is positive.\n\nProblem 8.3.2 Let \\(f(x, y)=1\\) if \\(x \\neq 0\\) and \\(f(0, y)=0\\). Prove that \\(f\\) is integrable on \\(A=[0,1] \\times[0,1] \\subset \\mathbb{R}^2\\).\n\n[!definition|*] We want to show that \\(f\\) is Riemann integrable on \\(A\\) and \\[\\iint_A f(x,y)\\,dx\\,dy = 1.\\] Let \\(\\varepsilon&gt;0\\) be given. Choose a number \\(\\delta\\) such that \\(0&lt;\\delta&lt;\\varepsilon\\). We partition the square \\(A\\) by subdividing the \\(y\\)-axis arbitrarily to form sub-rectangles \\(Q\\) inside \\([0,\\delta]\\times [0,1]\\). These rectangles contain points with \\(x=0\\) and \\(x&gt;0\\), so \\(f=0\\) and \\(f=1\\). Therefore, on each such \\(Q\\), \\[\\inf f = 0 \\quad \\text{and} \\quad \\sup f = 1\\] We let \\(A_1 = [0,\\delta]\\times [0,1]=\\delta\\) to be the vertical strip, and \\(A_2 = [\\delta,1]\\times [0,1]=1-\\delta\\) to be the rest of the square. For lower Riemann sum, we have \\[\n\\begin{align}\nL(f,P) & =(0)\\cdot A_{1}+(1)\\cdot A_{2} \\\\\n& =A_{2} \\\\\n& =(1-\\delta)\n\\end{align}\n\\] since \\(A_{1}:\\inf f=0\\) and \\(A_{2}:\\inf f=1\\). Similarly, for upper Riemann sum, we have \\[\n\\begin{align}\nU(f,P)  & = (1)\\cdot A_1 + (1)\\cdot A_2  \\\\\n& =A_1 + A_2 \\\\\n& =\\delta+1-\\delta \\\\\n& =1\n\\end{align}\n\\] since \\(A_{1}:\\inf f=1\\) and \\(A_{2}:\\inf f=1\\). Therefore, the difference between the upper and lower sums is \\[U(f,P)-L(f,P) = 1 - (1-\\delta) = \\delta.\\] By choosing \\(\\delta &lt; \\varepsilon\\), we ensure that \\[U(f,P)-L(f,P) &lt; \\varepsilon.\\] Since \\(\\forall\\varepsilon&gt;0\\) there exists a partition \\(P\\) s.t. \\[U(f,P)-L(f,P) &lt; \\varepsilon,\\] the function \\(f\\) is Riemann integrable on \\(A\\). Since the upper sums are always 1 and the lower sums can be made arbitrarily close to 1 by choosing arbitrarily small, it follows that \\[\\iint_A f(x,y)\\,dx\\,dy = 1.\\]\n\nChapter Exercise 8.12 Prove that \\(A\\) has measure zero iff for every \\(\\varepsilon&gt;0\\) there is a covering of \\(A\\) by sets \\(V_1, V_2, \\ldots\\) with volume such that \\(\\sum_{i=1}^{\\infty} v\\left(V_i\\right)&lt;\\varepsilon\\).\n\n[!definition|*] ( \\(\\implies\\) ) Suppose \\(m(A)=0\\), by definition 8.2.2, we know \\(\\forall \\varepsilon&gt;0, \\exists\\) countable cover of \\(A\\) by rectangles \\(\\left\\{S_i\\right\\} \\text { s.t. }\\sum_{i=1}^{\\infty} v\\left(S_i\\right)&lt;\\varepsilon\\). We choose volume \\(V_{i}=S_{i}\\), such that: \\[A\\subset \\sum_{i=1}^{\\infty} S_{i}=\\sum_{i=1}^{\\infty} V_{i}\\] and \\[\\sum_{i=1}^{\\infty} v(S_{i})=\\sum_{i=1}^{\\infty} v(V_{i}) &lt;\\varepsilon \\] Therefore, \\(m(A)=0 \\implies\\) \\(\\forall \\varepsilon&gt;0, \\exists\\) \\(\\{V_{i}\\}^{\\infty}_{1}\\) as a covering of \\(A\\) with total volume \\(\\sum_{i=1}^{\\infty} v(V_{i})&lt;\\epsilon\\).\n( \\(\\Longleftarrow\\) ) Suppose \\(\\forall \\varepsilon&gt;0, \\exists\\) \\(\\{V_{i}\\}^\\infty_{1}\\) a cover of \\(A\\) with total volume \\(\\sum_{i=1}^{\\infty} v(V_{i})&lt;\\epsilon\\). Note that every set in \\(\\mathbb{R}^n\\) can be covered by a union of open rectangles that is countable. Specifically, for each \\(i\\), we can cover \\(V_i\\) by a countable number of rectangles \\(\\{S_{i,1}, S_{i,2}, \\dots\\}\\) such that \\[V_i \\;\\subset\\; \\bigcup_{k=1}^{\\infty} S_{i,k}\\] We make sure the total volume of these rectangles is within arbitrarily small \\(\\delta_i\\) of \\(v(V_i)\\), so \\[\\sum_{k=1}^{\\infty} v(S_{i,k}) \\;&lt;\\; v(V_i) \\;+\\; \\delta_i.\\] Then, we choose each \\(\\delta_i\\) s.t. the sum of volumes is less than \\(\\varepsilon\\). Let \\[\\delta_i \\;=\\;\\frac{\\varepsilon}{2}\\,2^{-i} \\;=\\;\\frac{\\varepsilon}{2^{\\,i+1}}.\\]Then \\(\\forall i\\), we have: \\[\\sum_{k=1}^{\\infty} v\\bigl(S_{i,k}\\bigr)\\;&lt;\\; v(V_i) \\;+\\; \\frac{\\varepsilon}{2^{\\,i+1}}.\\] Hence, summing over all \\(i\\): \\[\\sum_{i=1}^{\\infty} \\sum_{k=1}^{\\infty} v(S_{i,k})\\;\\le\\; \\sum_{i=1}^{\\infty} \\Bigl( v(V_i)\\;+\\;\\tfrac{\\varepsilon}{2^{\\,i+1}} \\Bigr)\\;=\\;\\sum_{i=1}^{\\infty} v(V_i)\\;+\\;\\frac{\\varepsilon}{2}\\;&lt;\\; \\varepsilon \\;+\\; \\frac{\\varepsilon}{2} \\;=\\; \\tfrac{3\\varepsilon}{2}\n\\] Because \\(\\varepsilon\\) was arbitrary, we can make \\(\\delta_i\\) smaller such that the total can be strictly less than \\(\\varepsilon\\). Therefore, \\[A \\;\\subset\\;\\bigcup_{i=1}^\\infty \\bigcup_{k=1}^{\\infty} S_{i,k},\\quad\\text{and}\\quad\\sum_{i,k} v\\bigl(S_{i,k}\\bigr) \\;&lt;\\;\\varepsilon.\\] This demonstrates that \\(A\\) is covered by rectangles \\(\\{S_{i,k}\\}\\) whose total volume is &lt; \\(\\varepsilon\\), which is by definition, \\(m(A)=0\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II",
      "Homework 8"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/Homework 6.html",
    "href": "content/notes/理论/实分析/Homework/Homework 6.html",
    "title": "Erise Note",
    "section": "",
    "text": "7.2: 1, 2, [3,4]; Chapter 7: [4], 5, [6], 9, [12].\nProblem 7.2.3 In the system \\[\\begin{array}{r}\n3 x+2 y+z^2+u+v^2=0 \\\\\n4 x+3 y+z+u^2+v+w+2=0 \\\\\nx+z+w+u^2+2=0\n\\end{array}\n\\] discuss the solvability for \\(u, v, w\\) in terms of \\(x, y, z\\) near \\(x=y=z=0, u=\\) \\(v=0, w=-2\\).\n\n[!theorem|*] We first define three functions: \\[\n\\begin{aligned}\nF_1(x,y,z,u,v,w) \\;&=\\; 3x + 2y + z^2 + u + v^2,\\\\\nF_2(x,y,z,u,v,w) \\;&=\\; 4x + 3y + z + u^2 + v + w + 2,\\\\\nF_3(x,y,z,u,v,w) \\;&=\\; x + z + w + u^2 + 2.\n\\end{aligned}\n\\]\nSubstitute \\(x=0,y=0,z=0,u=0,v=0,w=-2\\) into each equation: - \\(F_{1}(0,0,0,0,0,-2) = 3\\cdot 0 + 2\\cdot 0 + 0^2 + 0 + 0^2 = 0.\\)\n- \\(F_{2}(0,0,0,0,0,-2) = 4\\cdot 0 + 3\\cdot 0 + 0 + (0)^2 + 0 + (-2) + 2 = 0.\\)\n- \\(F_{3}(0,0,0,0,0,-2) = 0 + 0 + (-2) + (0)^2 + 2 = 0.\\)\nHence \\(\\bigl(0,0,0,0,0,-2\\bigr)\\) satisfies all three equations. By the Implicit Function Theorem, we want to solve for \\((u,v,w)\\) if the Jacobian of \\(D_{(u,v,w)} (F_1, F_2, F_3) \\;\\) is invertible at that point.\nWe then compute partial derivatives, and evaluate them at \\(\\bigl(0,0,0,0,0,-2\\bigr)\\): \\[\nD_{(u,v,w)} (F_1, F_2, F_3)=\\begin{bmatrix}\nF_{1u} & F_{1v}&F_{1w} \\\\\nF_{2u} & F_{2v}&F_{2w} \\\\\nF_{3u} & F_{3v}&F_{3w}\n\\end{bmatrix}=\\begin{bmatrix}\n1 & 2v & 0 \\\\\n2u & 1 & 1 \\\\\n2u & 0 & 1\n\\end{bmatrix}\n\\] At that point, \\(u=0\\) and \\(v=0\\), the determinant of this \\(3\\times 3\\) matrix is \\[\\det \\begin{pmatrix}\n1 & 0 & 0 \\\\\n0 & 1 & 1 \\\\\n0 & 0 & 1\n\\end{pmatrix}\n\\;=\\; 1 \\;\\neq\\; 0.\n\\] So the matrix is invertible. Therefore, since \\(F_1=F_2=F_3=0\\) is at our point of interest, and the invertibility of Jacobian ensures that the mapping is locally bijective, the Implicit FT guarantees that in a neighborhood of \\(\\bigl(x,y,z\\bigr)=(0,0,0)\\), there exist unique smooth functions \\[u = u(x,y,z), \\quad v = v(x,y,z), \\quad w = w(x,y,z), \\] satisfying the system. And since, \\(\\bigl(u(0,0,0),\\,v(0,0,0),\\,w(0,0,0)\\bigr)=(0,0,-2)\\), the system is locally solvable for \\(\\,(u,v,w)\\,\\) as functions of \\(\\,(x,y,z)\\,\\) near \\(\\,(0,0,0)\\,\\).\n\n\nProblem 7.2.4 Does the map\n\\[\n(x, y) \\mapsto\\left(\\frac{x^2-y^2}{x^2+y^2}, \\frac{x y}{x^2+y^2}\\right)\n\\]\nhave a local inverse near \\((0,1)\\) ?\n\n[!definition|*] Define \\[F(x,y)\\;=\\;\\Bigl(F_1(x,y),\\,F_2(x,y)\\Bigr)\\;=\\;\\biggl(\\,\\frac{x^2 - y^2}{x^2 + y^2},\\;\\frac{x\\,y}{x^2 + y^2}\\biggr)\\] We substitute \\(\\bigl(x,y\\bigr)=(0,1)\\) into \\(F\\): \\[F(0,1)\n\\;=\\;\\Bigl(\\tfrac{0^2 - 1^2}{0^2 + 1^2},\\;\\tfrac{0\\cdot1}{0^2 + 1^2}\\Bigr)\n\\;=\\;(-1,\\,0)\\] We check if the Jacobian of \\(F\\) at \\((0,1)\\) is invertible. The partial of \\(\\,(F_1,F_2)\\) are\n\\[F_1(x,y)=\\tfrac{x^2 - y^2}{x^2 + y^2},\n\\quad\nF_2(x,y)=\\tfrac{x\\,y}{x^2 + y^2}\n\\]\nFor \\(F_1\\): \\[\\begin{align}\n\\frac{\\partial F_1}{\\partial x}(x,y)\n& =\\frac{(x^2+y^2)(2x) - (x^2-y^2)(2x)}{(x^2+y^2)^2}\\\\\n& =\\frac{2x\\Bigl[(x^2+y^2)-(x^2-y^2)\\Bigr]}{(x^2+y^2)^2}=\\frac{4xy^2}{(x^2+y^2)^2}\n\\end{align}\n\\] And \\[\\begin{align}\n\\frac{\\partial F_1}{\\partial y}(x,y)\n& =\\frac{(x^2+y^2)(-2y) - (x^2-y^2)(2y)}{(x^2+y^2)^2} \\\\\n& =\\frac{-2y\\Bigl[(x^2+y^2)+(x^2-y^2)\\Bigr]}{(x^2+y^2)^2}=-\\frac{4x^2y}{(x^2+y^2)^2}\n\\end{align}\n\\] For \\(F_2\\): \\[\\begin{align}\n\\frac{\\partial F_2}{\\partial x}(x,y)\n&   =\\frac{(x^2+y^2)(y) - (xy)(2x)}{(x^2+y^2)^2} \\\\\n&   =\\frac{y\\Bigl[(x^2+y^2)-2x^2\\Bigr]}{(x^2+y^2)^2}\n=\\frac{y(y^2-x^2)}{(x^2+y^2)^2}\n\\end{align}\n\\] And \\[\\begin{align}\n\\frac{\\partial F_2}{\\partial y}(x,y)   & =\\frac{(x^2+y^2)(x) - (xy)(2y)}{(x^2+y^2)^2} \\\\\n& =\\frac{x\\Bigl[(x^2+y^2)-2y^2\\Bigr]}{(x^2+y^2)^2}\n=\\frac{x(x^2-y^2)}{(x^2+y^2)^2}\n\\end{align}\n\\] Since \\(x^2+y^2=0^2+1^2=1\\), the evaluation at \\((0,1)\\) are: - \\(\\displaystyle \\frac{\\partial F_1}{\\partial x}(0,1)=\\frac{4\\cdot 0\\cdot1^2}{1^2}=0\\) - \\(\\displaystyle \\frac{\\partial F_1}{\\partial y}(0,1)=-\\frac{4\\cdot0^2\\cdot1}{1^2}=0\\) - \\(\\displaystyle \\frac{\\partial F_2}{\\partial x}(0,1)=\\frac{1\\,(1^2-0^2)}{1^2}=1\\) - \\(\\displaystyle \\frac{\\partial F_2}{\\partial y}(0,1)=\\frac{0\\,(0^2-1^2)}{1^2}=0\\)\nHence the Jacobian matrix of \\(F\\) at \\(\\,(0,1)\\) is \\[D F(0,1)\n\\;=\\;\n\\begin{pmatrix}\n0 & 0 \\\\\n1 & 0\n\\end{pmatrix}\n\\] The determinant of \\(D F(0,1)\\) is \\[\\det\\begin{pmatrix}\n0 & 0\\\\\n1 & 0\n\\end{pmatrix}\n\\;=\\;0\n\\] Because this determinant is zero, the matrix is not invertible. This means we cannot apply the IFT to conclude that \\(F\\) is invertible near \\((0,1)\\); there is no diffeomorphic local inverse of \\(F\\) around \\((0,1)\\).\nTherefore, we conclude that the map \\(F\\) does not have a local inverse near \\((0,1)\\).\n\nProblem [7.4] 4. Show that the equations\n\\[\n\\begin{array}{r}\nx^2-y^2-u^3+v^2+4=0 \\\\\n2 x y+y^2-2 u^2+3 v^4+8=0\n\\end{array}\n\\]\ndetermine functions \\(u(x, y), v(x, y)\\) near \\(x=2, y=-1\\) such that \\(u(2,-1)=\\) \\(2, v(2,-1)=1\\). Compute \\(\\partial u / \\partial x\\).\n\n[!definition|*] Let \\[\nF(x,y,u,v)=\\begin{cases}\nx^2 - y^2 -u^3 +v^2 +4 =0\\\\\n2xy+y^2 -2u^2 +v^4 +8=0\n\\end{cases}\n\\]\nWe first verify \\(\\,(x,y,u,v)=(2,-1,2,1)\\) is a solution: \\[\\begin{cases}\\;4 - 1 - 8 + 1 + 4\n\\;=\\;0 \\\\\n-4 +1 -8 +3 +8\n\\;=\\;0\\end{cases}\n\\] Therefore \\(\\bigl(2,-1,2,1\\bigr)\\) is indeed a solution of the system. Then, we compute the Jobcobian: \\[\\begin{align}\nD_{(u,v)} (F_1, F_2)   & =\\begin{pmatrix}\nF_{1u} & F_{1v}\\\\\nF_{2u} & F_{2v}\n\\end{pmatrix}\n\\Bigg|_{(2,-1,2,1)} \\\\[3pt]\n& =\\begin{pmatrix}\n-3u^{2}& 2v\\\\\n-4u & 12v^3\n\\end{pmatrix}\\Bigg|_{(2,-1,2,1)} \\\\[5pt]\n& =\n\\begin{pmatrix}\n-12 & 2\\\\\n-8 & 12\n\\end{pmatrix}\\end{align}\n\\] Its determinant is \\(\\Delta=(-12)(12) - 2(-8)= -144 +16= -128\\neq 0\\). Therefore, the matrix is invertible, so by the IFT we know that we can solve for \\(u\\) and \\(v\\) as functions of \\(x,y\\) near \\(\\,(2,-1)\\). Now we compute \\(u_x(2,-1)\\). For \\(F_1=0\\): \\[\\frac{\\partial}{\\partial x}(x^2-y^2 -u^3 +v^2 +4)\n\\;=\\;2x \\;-\\;3u^2 u_x \\;+\\;2v v_x\n\\;=\\;0\n\\] At \\((x,y,u,v)=(2,-1,2,1)\\), this is \\(4 -12u_x + 2v_x=0\\). For \\(F_2=0\\): \\[\\frac{\\partial}{\\partial x}(2xy +y^2 -2u^2 +3v^4 +8)\n=2y \\;-\\;4u u_x \\;+\\;12v^3 v_x\n=0\n\\] At \\((2,-1,2,1)\\), this is \\(-2 \\;-\\;8 u_x +12 v_x=0\\). So we obtain: \\[\\begin{cases}\n4 \\;-\\;12u_x +2v_x = 0\\\\\n-2 \\;-\\;8u_x +12v_x = 0\n\\end{cases}\n\\] To solve this system of equations, we have \\[\nv_x = \\frac{8u_x + 2}{12}\n\\] So, \\[\n\\begin{align*}\n4 - 12u_x + 2v_x &= 4 - 12u_x + 2\\left(\\frac{8u_x + 2}{12} \\right) \\\\\n&= 4 - 12u_x + \\frac{4}{3}u_x + \\frac{1}{3} \\\\\n&= -\\frac{32}{3} u_x + \\frac{13}{3} = 0\n\\end{align*}\n\\] \\[\n\\Longrightarrow u_x = \\frac{13}{32}\n\\] Hence, we have \\[u_x(2,-1) = \\frac{13}{32}\\]\n\nProblem [7.6] Determine whether the “curve” described by the equation \\(x^2+y+\\sin (x y)\\) \\(=0\\) can be written in the form \\(y=f(x)\\) in a neighborhood of \\((0,0)\\). Does the implicit function theorem allow you to say whether the equation can be written in the form \\(x=h(y)\\) in a neighborhood of \\((0,0)\\) ?\n\n[!definition|*] Let \\[F(x,y)=x^2 + y +\\sin\\!\\bigl(x\\,y\\bigr)=0\\] We want to show that \\(F\\colon \\mathbb{R}^2 \\to \\mathbb{R}\\) is \\(C^1\\), and \\(F(x_0,y_0)=0\\). We first substitute \\(x=0,y=0\\) into \\(F\\): \\[F(0,0)=0^2+0+\\sin(0\\cdot 0)=0\\] Hence \\((0,0)\\) lies on the curve \\(F(x,y)=0\\). We then compute the partial at \\((0,0)\\): \\[\\begin{align}\nF_{y}  =1 +\\cos\\!\\bigl(xy\\bigr)\\bigl(x\\bigr) \\Longrightarrow   F_{y}(0,0)\n=1 +0\n=1\\neq 0\n\\end{align}\n\\] And \\[\n\\begin{align}\nF_{x}\n=2x +\\cos\\!\\bigl(xy\\bigr)\\bigl(y\\bigr)   \n\\Longrightarrow  F_{y}(0,0)\n= 2\\cdot 0 + 0 = 0\n\\end{align}\n\\]\nBecause \\(F_{y}(0,0)=1\\neq 0\\), the Implicit Function Theorem ensures that there exists neighborhood of \\((0,0)\\) in which we can uniquely solve the equation for \\(y\\) as a function of \\(x\\). Therefore, there exists \\(y =f(x)\\) for \\((x,y)\\) near \\((0,0)\\) for all \\(x\\) in the neighborhood of \\(0\\).\nHowever, on the other hand, since \\(F_{x}(0,0)=0\\), Implicit FT does not apply, so the test is conclusive. This means the usual IFT statement fails to guarantee a local solution of the form \\(x=h(y)\\).\n\nProblem [7.12] Show that the implicit function theorem implies the inverse function theorem.\n\n[!definition|*]\nLet \\(f\\colon A\\subset\\mathbb{R}^n \\to \\mathbb{R}^n\\) be of class \\(C^1\\). Suppose \\(x_0\\in A\\) and\n\\[ J_f(x_0)\\;=\\;\\det\\bigl(Df(x_0)\\bigr)\\;\\neq\\;0.\n\\] We want to show that, there exist neighborhoods \\(U\\) of \\(x_0\\) in \\(A\\) and \\(V\\) of \\(y_0=f(x_0)\\) in \\(\\mathbb{R}^n\\) such that - (1) \\(f(U)=V\\) and \\(f\\colon U\\to V\\) has an inverse \\(f^{-1}:V\\to U\\).\n- (2) \\(f^{-1}\\) is of class \\(C^1\\). - (3) \\(D f^{-1}(y)=\\bigl[D f(x)\\bigr]^{-1}\\) for all \\(x\\in U\\) with \\(y=f(x)\\).\nDefine a new function \\[F\\colon \\mathbb{R}^n\\times \\mathbb{R}^n \\longrightarrow \\mathbb{R}^n,\n\\quad\nF(x,y)=f(x)-y\n\\] with \\(x=(x_1,\\dots,x_n)\\) and \\(y=(y_1,\\dots,y_n)\\). Then we know that \\(F\\) is \\(C^1\\) because \\(f\\) is \\(C^1\\) and subtraction is smooth. Note that \\(F(x_0,\\,f(x_0))= f(x_0)- f(x_0)=0\\). We want to compute the Jacobian of \\(F\\) w.r.t. \\(y\\). So for each \\(i=1,\\dots,n\\), the \\(i\\)th component of \\(F\\) is \\[F_i(x,y)=f_i(x)-y_i.\\] Since \\(f_i(x)\\) does not depend on \\(y\\), we have for each \\(j=1,\\dots,n\\) \\[\\frac{\\partial F_i}{\\partial y_j}(x,y)=\\frac{\\partial}{\\partial y_j}\\bigl(f_i(x)-y_i\\bigr)\n=\\frac{\\partial f_i(x)}{\\partial y_j}-\\frac{\\partial y_i}{\\partial y_j}\n=0-\\delta_{ij}\n\\] where \\(\\delta_{ij}\\) is \\[\\delta_{ij}=\n\\begin{cases}1 \\quad i=j \\\\0 \\quad i\\neq j \\\\\n\\end{cases}\n\\] Thus, the \\((i,j)\\)-entry of the Jacobian is \\[\\left[\\frac{\\partial F}{\\partial y}(x,y)\\right]_{ij}=-\\delta_{ij}\n\\] In matrix form, we have: \\[\\frac{\\partial F}{\\partial y}(x,y)=-I\n\\] where \\(I\\) is the \\(n\\times n\\) identity matrix. Since the determinant \\(\\det(-I)=(-1)^n\\neq 0\\), we know that \\(D_y F(x,y)=-I\\) is invertible everywhere. This satisfy the condition for Implicit FT. Hence, by the Implicit Function Theorem, there is a neighborhood \\(U\\) of \\(x_0\\in \\mathbb{R}^n\\) and a neighborhood \\(V\\) of \\(y_0=f(x_0)\\in \\mathbb{R}^n\\) s.t. \\(\\forall\\, y\\in V\\), \\(\\exists! \\,x\\in U\\) satisfying: \\[F(x,y)=0\n\\;\\;\\Longleftrightarrow\\;\\;\nf(x)-y=0\n\\;\\;\\Longleftrightarrow\\;\\;\ny=f(x)\n\\] and we have a map that is \\(C^1\\) \\[\\Phi:V \\;\\to\\; U\n\\quad\\text{such that}\\quad\nF\\bigl(\\Phi(y),\\,y\\bigr)=0\n\\quad\\text{for all }y\\in V\n\\] which this demonstrates (2). Since \\(F(\\Phi(y),y) \\Longrightarrow f(\\Phi(y))=y\\), it follows that \\(\\Phi\\) is the local inverse \\(f^{1}\\) by definition. Because \\(f\\) itself is \\(C^1\\) and \\(\\Phi=f^{-1}\\) is also \\(C^1\\), we conclude that \\(f^{-1}\\) is a local diffeomorphism near \\(x_0\\), which shows (1). Next, by Corollary 7.2.2 for each \\(y\\in V\\), we have \\[\\begin{align}\nD\\Phi(y) & =-\\Bigl(D_yF(\\Phi(y),y)\\Bigr)^{-1}D_xF(\\Phi(y),y) \\\\\n& =-(-I)^{-1}\\,D f\\bigl(\\Phi(y)\\bigr)  \\\\\n& =D f\\bigl(\\Phi(y)\\bigr)^{-1}\n\\end{align}\n\\] Since \\(\\Phi(y)=x\\), near \\(x_{0}\\) this yields: \\[D f^{-1}(f(x))\n\\;=\\;\n\\bigl(Df(x)\\bigr)^{-1}\n\\] which shows the (3) of theorem. Hence, we have shown that Implicit Function Theorem directly implies the Inverse Function Theorem.",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II",
      "Homework 6"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/Homework 10.html",
    "href": "content/notes/理论/实分析/Homework/Homework 10.html",
    "title": "Erise Note",
    "section": "",
    "text": "8.6: [1, 3]; Chapter 8: [24, 36, 39]\nProblem 8.6.1 Show that Theorem 8.6.1 can be proved using the methods of Chapter 5 if the \\(g_n\\) are continuous.\nTheorem 8.6.1 (Lebesgue’s Monotone Convergence Theorem) Let \\(g_n : [0, 1] \\to \\mathbb{R}\\) be a sequence of nonnegative functions such that each improper integral \\(\\int_0^1 g_n(x) dx\\) exists and is finite. Suppose that \\(0 \\leq g_{n+1}(x) \\leq g_n(x)\\) and that \\(g_n(x) \\to 0\\) for each \\(x \\in [0, 1]\\). Then \\[\\lim_{n\\to\\infty} \\int_0^1 g_n(x) dx = 0.\\]\n\n[!definition|*] Proof. Let \\(g_n : [0, 1] \\to \\mathbb{R}\\) be a sequence of nonnegative functions such that each improper integral \\(\\int_0^1 g_n(x) dx\\) exists and is finite. Suppose that \\(0 \\leq g_{n+1}(x) \\leq g_n(x)\\). Since each \\(g_n\\) is continuou within the compact interval \\([0,1]\\), so it is bounded by a maximum vlaue. We define: \\[      M_n := \\max g_n(x)\n\\] The monotonicity condition \\(g_{n+1}(x) \\le g_n(x)\\) for all \\(x\\) means that \\(M_{n+1} \\le M_n\\). Therefore, the sequence \\(\\{M_n\\}\\) is nonincreasing and bounded below by 0. for each fixed , we have\n\\[\\lim_{n\\to\\infty} g_n(x) = 0\\] Suppose, for the sake of contradiction, that \\(\\lim_{n\\to\\infty} M_n \\neq 0\\). Then there exists an \\(\\epsilon_0 &gt; 0\\) and a subsequence \\(\\{n_k\\}\\) such that\n\\[M_{n_k} \\ge \\epsilon_0 \\quad \\forall k\\\n\\] For each \\(k\\), choose \\(x_{n_k} \\in [0,1]\\) such that\n\\[ g_{n_k}(x_{n_k}) = M_{n_k} \\ge \\epsilon_0\\] This contradicts the fact that \\(g_{n_k}(x_{n_k}) \\to 0\\) as \\(n_k \\to \\infty\\). Hence, it must be true that \\(\\lim_{n\\to\\infty} M_n = 0\\). This means for every \\(\\epsilon &gt; 0\\) there exists \\(N \\in \\mathbb{N}\\) such that for all \\(n \\ge N\\),\n\\[ M_n &lt; \\epsilon\\] Since \\(0 \\le g_n(x) \\le M_n\\) for all \\(x \\in [0,1]\\), it follows that for all \\(x\\) and for \\(n\\ge N\\),\n\\[|g_n(x) - 0| \\le M_n &lt; \\epsilon \\] Thus, \\(g_n \\to 0\\) uniformly on \\([0,1]\\). By the Uniform Convergence Theorem , if a sequence of integrable functions \\(\\{f_n\\}\\) converges uniformly to a function \\(f\\) on \\([a,b]\\), then\n\\[\\lim_{n\\to\\infty} \\int_a^b f_n(x)\\,dx = \\int_a^b \\lim_{n\\to\\infty} f_n(x)\\,dx.\n\\] apply this to \\(\\{g_n\\}\\), which converges uniformly to \\(f(x) = 0\\) on \\([0,1]\\), we hence conclude that\n\\[\\lim_{n\\to\\infty} \\int_0^1 g_n(x)\\,dx = \\int_0^1 0\\,dx = 0\\]\n\nProblem 8.6.3 Evaluate \\[\\lim_{n\\to\\infty} \\int_0^1 \\frac{1 - e^{-nx}}{\\sqrt{x}} dx.\\]\n\n[!definition|*] Proof. We define\n\\[f_n(x) = \\frac{1-e^{-nx}}{\\sqrt{x}},\\]\nNotice that for every fixed \\(x&gt;0\\), as \\(n\\to\\infty\\) we have \\(e^{-nx}\\to 0\\) and hence\n\\[\\lim_{n\\to\\infty} f_n(x) = \\frac{1}{\\sqrt{x}}\\]\nwhich means, every \\(x&gt;0\\) the function \\(1-e^{-nx}\\) is increasing in \\(n\\), so that the sequence \\(\\{f_n(x)\\}\\) is nonnegative and monotonically increasing. Thus, by Corollary 8.6.2:\n\\[\\lim_{n\\to\\infty}\\int_0^1 f_n(x)\\,dx = \\int_0^1\\lim_{n\\to\\infty} f_n(x)\\,dx = \\int_0^1 \\frac{1}{\\sqrt{x}}\\,dx.\\]\nThe remaining integral is just computed normally as an improper integral near \\(x=0\\), which is: \\[\\int_0^1 \\frac{1}{\\sqrt{x}}\\,dx = \\lim_{\\epsilon\\to0^{+}} \\int_{\\epsilon}^1 x^{-\\frac{1}{2}}\\,dx\n= \\lim_{\\epsilon\\to0^{+}} \\left[ 2\\sqrt{x} \\,\\right]_{\\epsilon}^{1}\n= \\lim_{\\epsilon\\to0^{+}} \\bigl(2 - 2\\sqrt{\\epsilon}\\bigr)\n= 2.\\]\nTherefore,\n\\[\\lim_{n\\to\\infty}\\int_{0}^{1} \\frac{1-e^{-nx}}{\\sqrt{x}}\\,dx = 2.\\]\n\nChatper 8.24 Give an example to show that the following is not equivalent to the integrability of \\(f\\):\nFor any \\(\\varepsilon &gt; 0\\), there is a \\(\\delta &gt; 0\\) such that if \\(P\\) is any partition into rectangles \\(S_1, \\ldots, S_N\\) with sides less than \\(\\delta\\), there exist \\(x_1 \\in S_1, \\ldots, x_N \\in S_N\\) such that \\[\\left|\\sum_{i=1}^N f(x_i)v(S_i) - I\\right| &lt; \\varepsilon.\\]\n\n[!definition|*] Proof. For a counterexample, consider the function \\(f : [0, 1] \\to \\mathbb{R}\\) such that:\n\\[f(x) = \\begin{cases}\n1 & \\text{if } x \\in \\mathbb{Q} \\cap [0, 1],\\\\\n0 & \\text{if } x \\in \\mathbb{R} \\setminus \\mathbb{Q}.\n\\end{cases}\\] This function \\(f(x)\\) is not integrable due to the set of discontinuity \\(D = [0, 1]\\) because these set of discontinuities have positive measure. Since the irrationals are dense in \\(\\mathbb{R}\\), every subinterval \\(S_i\\) (no matter how small) contains at least one irrational number. Thus, for any partition \\(P\\) of \\([0,1]\\) with subinterval lengths \\(x_i \\in S_i\\) with \\(x_i\\in \\mathbb{R} \\setminus \\mathbb{Q}\\), we have \\(f\\left(x_i\\right)=0\\) \\(\\forall i\\) such that: \\[\n\\sum_{i=1}^N f\\left(x_i\\right) v\\left(S_i\\right)=0\n\\] Therefore, \\[\n\\left|\\sum_{i=1}^N f\\left(x_i\\right) v\\left(S_i\\right)-0\\right|=0&lt;\\varepsilon\n\\] So, the property is satisfied. This shows that the condition holds for the function \\(f\\), even though \\(f\\) is not Riemann integrable on \\([0,1]\\).\n\nProblem 8.36 Prove that \\[\\lim_{n\\to\\infty}\\frac{(n!)^{1/n}}{n} = e^{-1}\\] by considering Riemann sums for \\[\\int_0^1 \\log x \\, dx\\] based on the partition \\[\\frac{1}{n} &lt; \\frac{2}{n} &lt; \\cdots &lt; 1\\]\n\n[!definition] Proof. We first take the natural logarithm: \\[\\frac{(n!)^{\\frac{1}{n}}} {n} \\Longrightarrow\\log \\left(\\frac{(n!)^{1 / n}}{n}\\right)=\\frac{1}{n} \\log (n!)-\\log (n)\\]\nnow, we want to first show that this expression converges to \\(-1\\). Notice that: \\[\\begin{align}\\log(n!)  & = \\sum_{k=1}^n \\log(k) = \\sum_{k=1}^n \\bigl[\\log(k/n) + \\log(n)\\bigr]= \\sum_{k=1}^n \\log\\bigl(\\tfrac{k}{n}\\bigr) + n\\,\\log(n) \\\\\\frac{1}{n}\\log(n!) & = \\frac{1}{n}\\sum_{k=1}^n \\log\\Bigl(\\frac{k}{n}\\Bigr) \\;+\\; \\log(n) \\\\\\frac{1}{n}\\log(n!) - \\log(n)& = \\frac{1}{n}\\sum_{k=1}^n \\log\\Bigl(\\tfrac{k}{n}\\Bigr)\\end{align}\n\\] So we have: \\[\\log\\!\\Bigl(\\tfrac{(n!)^{1/n}}{n}\\Bigr)\\;=\\; \\frac{1}{n}\\sum_{k=1}^n \\log\\Bigl(\\tfrac{k}{n}\\Bigr).\\] Notice that\n\\[\\frac{1}{n}\\sum_{k=1}^n \\log\\bigl(\\tfrac{k}{n}\\bigr)\\]\nis Riemann sum for the integral \\(\\int_0^1 \\log x \\,dx\\), using the partition\n\\[0 &lt; \\tfrac{1}{n} &lt; \\tfrac{2}{n} &lt; \\cdots &lt; \\tfrac{n}{n}=1\\]\nTherefore,\n\\[\\frac{1}{n}\\sum_{k=1}^n \\log\\Bigl(\\tfrac{k}{n}\\Bigr)\\;\\longrightarrow\\; \\int_0^1 \\log x\\,dx\\quad\\text{as }n\\to\\infty\n\\] Now we proceed to compute \\(\\int_0^1 \\log x \\, dx\\). We have\n\\[\\int_0^1 \\log x \\, dx \\;=\\; \\left[x\\log x - x\\right]_{0}^{1}= (0) - (-1) = -1\n\\]\nBy the definition of a Riemann sum, we know that,\n\\[\\lim_{n\\to\\infty} \\frac{1}{n}\\sum_{k=1}^n \\log\\Bigl(\\tfrac{k}{n}\\Bigr)\\;=\\; \\int_0^1 \\log x\\,dx\\;=\\; -1\n\\]\nso \\[\\lim_{n\\to\\infty}\\log\\Bigl(\\tfrac{(n!)^{1/n}}{n}\\Bigr)\\;=\\;-1\n\\]\nwhich is: \\[\\lim_{n\\to\\infty}\\frac{(n!)^{1/n}}{n} \\;=\\; e^{-1}.\\]\n\nProblem 8.39 Prove that \\[\\log 2 = \\lim_{n\\to\\infty} \\left[\\frac{1}{n+1} + \\frac{1}{n+2} + \\cdots + \\frac{1}{2n}\\right]\\]\n\n[!definition|*] Proof. Define, for each \\(n\\in\\mathbb{N}\\), \\[S_n = \\frac{1}{n+1} + \\frac{1}{n+2} + \\cdots + \\frac{1}{2n} = \\sum_{k=n+1}^{2n} \\frac{1}{k}.\\] We let \\(i=k-n\\), so that \\(k=n+i\\) and \\(i\\) runs from 1 to \\(n\\), then we obtain\n\\[S_n = \\sum_{i=1}^{n} \\frac{1}{n+i} = \\sum_{i=1}^{n} \\frac{1}{n\\left(1+\\frac{i}{n}\\right)} = \\frac{1}{n}\\sum_{i=1}^{n} \\frac{1}{1+\\frac{i}{n}}.\\] Now, consider the function \\(f(x)=\\frac{1}{1+x}\\) defined on \\([0,1]\\). Since \\(f\\) is continuous on \\([0,1]\\), it is Riemann integrable. Consider partition \\(P\\) over the interval \\([0,1]\\) for \\(n\\) equal subintervals \\(\\Delta x = \\frac{1}{n}\\): \\[0 = x_0 &lt; x_1 &lt; x_2 &lt; \\cdots &lt; x_n = 1\\] where \\(x_i = \\frac{i}{n}\\) for \\(i=0,1,\\dots,n\\). Then the Riemann sum for \\(f\\) is\n\\[R_n = \\sum_{i=1}^{n} f(x_i) \\Delta x = \\frac{1}{n}\\sum_{i=1}^{n} \\frac{1}{1+\\frac{i}{n}}\\] By construction, \\(R_n=S_n\\). Thus, by the definition of the Riemann integral,\n\\[\\lim_{n\\to\\infty} S_n = \\lim_{n\\to\\infty} R_n = \\int_0^1 \\frac{1}{1+x}\\,dx\\] That is: \\[\\int_0^1 \\frac{1}{1+x}\\,dx = \\Bigl[\\log(1+x)\\Bigr]_0^1 = \\log(2) - \\log(1) = \\log2\\] Therefore,\n\\[\\lim_{n\\to\\infty} \\left[\\frac{1}{n+1} + \\frac{1}{n+2} + \\cdots + \\frac{1}{2n}\\right] = \\log2\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II",
      "Homework 10"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html",
    "title": "Solutions for Quiz 4",
    "section": "",
    "text": "For a given problem, we know that the solution belongs to \\(H^2(\\Omega)\\). We use finite elements of order 2. What is the expected order of convergence in the norm of \\(H^1(\\Omega)\\). Is this an “optimal” choice? Motivate your answer.\n\n\nBased on approximation theory for finite elements, we can analyze this using the relationship between the solution regularity, the polynomial order, and the expected convergence rate.\nFor a solution \\(u \\in H^2(\\Omega)\\) and using order \\(k\\) Lagrange interpolation (where \\(k=2\\) in this case), we can refer to the following relationship for error estimates:\nIf we construct a table of convergence rates based on solution regularity \\(q\\) and polynomial order \\(k\\):\n\n\n\n\\(q\\)  \\(k\\)\n1\n2\n3\n\n\n\n\n1\n1\n1\n1\n\n\n2\n1\n2\n2\n\n\n3\n1\n2\n3\n\n\n\nHere we’re looking at the case where \\(q=2\\) (solution in \\(H^2\\)) and \\(k=2\\) (quadratic elements).\nFor this combination, we expect order of convergence \\(O(h^1)\\) in the \\(H^1(\\Omega)\\) norm.\nThis is not optimal. The optimal convergence rate would be \\(O(h^2)\\) in the \\(H^1(\\Omega)\\) norm, which would require the solution to be in \\(H^3(\\Omega)\\) when using quadratic elements.\nFor a solution in \\(H^2(\\Omega)\\), we only achieve first-order convergence in the \\(H^1\\) norm with quadratic elements, which is the same rate we would get with linear elements. Therefore, using quadratic elements is not computationally efficient for this problem.\n\n\n\n\nExplain why in advection-dominated problems in 2+ D, adding artificial viscosity to stabilize the solution is not optimal.\n\n\nIn advection-dominated problems where the convection term significantly outweighs the diffusion term, we often encounter numerical instabilities. Consider the extreme case where the velocity field is highly anisotropic, such as:\n\\[\\beta = \\begin{bmatrix} 1000 \\\\ 0 \\end{bmatrix}\\]\nIn this scenario, using the upwind method with artificial viscosity is not optimal because:\nThe advection-diffusion equation takes the form: \\[-\\mu^* \\frac{\\partial^2 u}{\\partial x^2} - \\mu^* \\frac{\\partial^2 u}{\\partial y^2} + \\beta_0 \\cdot \\frac{\\partial u}{\\partial x} = f\\]\nThe key issue is that \\(\\mu^*\\) (artificial viscosity) doesn’t help stabilize the problem in the \\(y\\)-direction. The only thing we need to do is to regularize the \\(x\\)-direction, which can be written as:\n\\[-\\mu^* \\frac{\\partial^2 u}{\\partial x^2} - \\mu \\frac{\\partial^2 u}{\\partial y^2} + \\beta_0 \\frac{\\partial u}{\\partial x}\\]\nMore generally, we can write: \\[\\mu \\int_\\Omega \\nabla v \\cdot \\nabla u + \\int_\\Omega \\beta \\nabla u \\cdot v + \\frac{\\mu}{2} \\int_\\Omega (\\beta \\cdot \\nabla u)(\\beta \\cdot \\nabla v) \\frac{1}{|\\beta|^2} = \\int_\\Omega f v\\]\nThis shows that artificial viscosity adds diffusion isotropically (in all directions), whereas the instability primarily occurs in the direction of the flow. This makes the method unnecessarily diffusive in directions perpendicular to the flow, degrading solution accuracy where stabilization isn’t needed.\n\n\n\n\nTrue or False?\n\n\nAnswer: F\nWhen convection dominates diffusion, standard finite element methods will produce oscillatory solutions unless stabilization techniques are applied.\n\n\n\nAnswer: F (ATO-1), u = f\nThis is stable. Unlike advection-dominated problems, reaction-dominated problems may not show oscillations but can exhibit sharp boundary layers. The finite element solution doesn’t typically oscillate in the same way as advection-dominated problems.\n\n\n\nAnswer: T\nIn mass lumping, all terms become one term in the diagonal. The mass matrix, which normally has entries from the integral of basis function products, is approximated by a diagonal matrix through the lumping process.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Solutions for Quiz 4"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html#question-1",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html#question-1",
    "title": "Solutions for Quiz 4",
    "section": "",
    "text": "For a given problem, we know that the solution belongs to \\(H^2(\\Omega)\\). We use finite elements of order 2. What is the expected order of convergence in the norm of \\(H^1(\\Omega)\\). Is this an “optimal” choice? Motivate your answer.\n\n\nBased on approximation theory for finite elements, we can analyze this using the relationship between the solution regularity, the polynomial order, and the expected convergence rate.\nFor a solution \\(u \\in H^2(\\Omega)\\) and using order \\(k\\) Lagrange interpolation (where \\(k=2\\) in this case), we can refer to the following relationship for error estimates:\nIf we construct a table of convergence rates based on solution regularity \\(q\\) and polynomial order \\(k\\):\n\n\n\n\\(q\\)  \\(k\\)\n1\n2\n3\n\n\n\n\n1\n1\n1\n1\n\n\n2\n1\n2\n2\n\n\n3\n1\n2\n3\n\n\n\nHere we’re looking at the case where \\(q=2\\) (solution in \\(H^2\\)) and \\(k=2\\) (quadratic elements).\nFor this combination, we expect order of convergence \\(O(h^1)\\) in the \\(H^1(\\Omega)\\) norm.\nThis is not optimal. The optimal convergence rate would be \\(O(h^2)\\) in the \\(H^1(\\Omega)\\) norm, which would require the solution to be in \\(H^3(\\Omega)\\) when using quadratic elements.\nFor a solution in \\(H^2(\\Omega)\\), we only achieve first-order convergence in the \\(H^1\\) norm with quadratic elements, which is the same rate we would get with linear elements. Therefore, using quadratic elements is not computationally efficient for this problem.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Solutions for Quiz 4"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html#question-2",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html#question-2",
    "title": "Solutions for Quiz 4",
    "section": "",
    "text": "Explain why in advection-dominated problems in 2+ D, adding artificial viscosity to stabilize the solution is not optimal.\n\n\nIn advection-dominated problems where the convection term significantly outweighs the diffusion term, we often encounter numerical instabilities. Consider the extreme case where the velocity field is highly anisotropic, such as:\n\\[\\beta = \\begin{bmatrix} 1000 \\\\ 0 \\end{bmatrix}\\]\nIn this scenario, using the upwind method with artificial viscosity is not optimal because:\nThe advection-diffusion equation takes the form: \\[-\\mu^* \\frac{\\partial^2 u}{\\partial x^2} - \\mu^* \\frac{\\partial^2 u}{\\partial y^2} + \\beta_0 \\cdot \\frac{\\partial u}{\\partial x} = f\\]\nThe key issue is that \\(\\mu^*\\) (artificial viscosity) doesn’t help stabilize the problem in the \\(y\\)-direction. The only thing we need to do is to regularize the \\(x\\)-direction, which can be written as:\n\\[-\\mu^* \\frac{\\partial^2 u}{\\partial x^2} - \\mu \\frac{\\partial^2 u}{\\partial y^2} + \\beta_0 \\frac{\\partial u}{\\partial x}\\]\nMore generally, we can write: \\[\\mu \\int_\\Omega \\nabla v \\cdot \\nabla u + \\int_\\Omega \\beta \\nabla u \\cdot v + \\frac{\\mu}{2} \\int_\\Omega (\\beta \\cdot \\nabla u)(\\beta \\cdot \\nabla v) \\frac{1}{|\\beta|^2} = \\int_\\Omega f v\\]\nThis shows that artificial viscosity adds diffusion isotropically (in all directions), whereas the instability primarily occurs in the direction of the flow. This makes the method unnecessarily diffusive in directions perpendicular to the flow, degrading solution accuracy where stabilization isn’t needed.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Solutions for Quiz 4"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html#question-3",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Quiz 4.html#question-3",
    "title": "Solutions for Quiz 4",
    "section": "",
    "text": "True or False?\n\n\nAnswer: F\nWhen convection dominates diffusion, standard finite element methods will produce oscillatory solutions unless stabilization techniques are applied.\n\n\n\nAnswer: F (ATO-1), u = f\nThis is stable. Unlike advection-dominated problems, reaction-dominated problems may not show oscillations but can exhibit sharp boundary layers. The finite element solution doesn’t typically oscillate in the same way as advection-dominated problems.\n\n\n\nAnswer: T\nIn mass lumping, all terms become one term in the diagonal. The mass matrix, which normally has entries from the integral of basis function products, is approximated by a diagonal matrix through the lumping process.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Solutions for Quiz 4"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/index.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/index.html",
    "title": "第九章",
    "section": "",
    "text": "9.1 边值问题的近似\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.2 有限差分法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3 对流-扩散方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.4 4.1 二维（2D）偏微分方程问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n习题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html",
    "title": "9.4 4.1 二维（2D）偏微分方程问题",
    "section": "",
    "text": "我们考虑一个二维空间的问题，记为区域 \\(\\Omega\\)。边界记为 \\(\\partial\\Omega\\)。\n方程一般形式如下： \\[-\\mu \\Delta u + \\beta \\cdot \\nabla u = f,\\quad \\text{在}\\ \\Omega 内\\]\n边界条件为： \\[u(\\partial \\Omega) = d \\quad (\\text{给定的数据})\\]\n\n这里的符号解释（见上一章）：\n\n\\(\\beta\\)：表示”风”或者对流的方向和强度\n\\(\\mu\\)：扩散系数\n\\(f\\)：外力或源项\n\n\n因此，上面的方程可以展开写成：\n\\[-\\mu \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right)\n+ \\beta_x \\frac{\\partial u}{\\partial x} + \\beta_y \\frac{\\partial u}{\\partial y} = f(x,y)\\]\n\n\n\n首先考虑更简单的情况，忽略对流（即“关掉风”），变成纯扩散问题：\n\\[-\\mu\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = f(x,y)\\]\n\n\n\n用有限差分法来数值求解：\n假设空间被划分为一个网格，每个网格点用坐标 \\((i,j)\\) 来表示位置：\n\n在\\(x\\)方向的间距为 \\(\\Delta x\\)\n在\\(y\\)方向的间距为 \\(\\Delta y\\)\n\n则对于二维的拉普拉斯算子，常用的中心差分格式为：\n\\[\\frac{\\partial^2 u}{\\partial x^2}\\approx \\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2}\\]\n\\[\\frac{\\partial^2 u}{\\partial y^2}\\approx \\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2}\\]\n代入扩散方程得到：\n\\[-\\mu\\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2}\n-\\mu\\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2}\n= f(x_i,y_j)\\]\n\n\n\n所有网格点的未知数\\(u_{i,j}\\)放到一个向量中（向量记为\\(u\\)），这样就可以把离散后的方程写成一个矩阵方程：\n\\[A u = b\\]\n这里： - \\(A\\) 是系数矩阵（稀疏、对称、正定，简称SPD） - \\(u\\) 是未知量向量（所有网格点的解） - \\(b\\) 是已知项的向量（源项\\(f\\)和边界条件的组合）",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.4 4.1 二维（2D）偏微分方程问题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#椭圆型",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#椭圆型",
    "title": "9.4 4.1 二维（2D）偏微分方程问题",
    "section": "",
    "text": "我们考虑一个二维空间的问题，记为区域 \\(\\Omega\\)。边界记为 \\(\\partial\\Omega\\)。\n方程一般形式如下： \\[-\\mu \\Delta u + \\beta \\cdot \\nabla u = f,\\quad \\text{在}\\ \\Omega 内\\]\n边界条件为： \\[u(\\partial \\Omega) = d \\quad (\\text{给定的数据})\\]\n\n这里的符号解释（见上一章）：\n\n\\(\\beta\\)：表示”风”或者对流的方向和强度\n\\(\\mu\\)：扩散系数\n\\(f\\)：外力或源项\n\n\n因此，上面的方程可以展开写成：\n\\[-\\mu \\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right)\n+ \\beta_x \\frac{\\partial u}{\\partial x} + \\beta_y \\frac{\\partial u}{\\partial y} = f(x,y)\\]\n\n\n\n首先考虑更简单的情况，忽略对流（即“关掉风”），变成纯扩散问题：\n\\[-\\mu\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = f(x,y)\\]\n\n\n\n用有限差分法来数值求解：\n假设空间被划分为一个网格，每个网格点用坐标 \\((i,j)\\) 来表示位置：\n\n在\\(x\\)方向的间距为 \\(\\Delta x\\)\n在\\(y\\)方向的间距为 \\(\\Delta y\\)\n\n则对于二维的拉普拉斯算子，常用的中心差分格式为：\n\\[\\frac{\\partial^2 u}{\\partial x^2}\\approx \\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2}\\]\n\\[\\frac{\\partial^2 u}{\\partial y^2}\\approx \\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2}\\]\n代入扩散方程得到：\n\\[-\\mu\\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{\\Delta x^2}\n-\\mu\\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{\\Delta y^2}\n= f(x_i,y_j)\\]\n\n\n\n所有网格点的未知数\\(u_{i,j}\\)放到一个向量中（向量记为\\(u\\)），这样就可以把离散后的方程写成一个矩阵方程：\n\\[A u = b\\]\n这里： - \\(A\\) 是系数矩阵（稀疏、对称、正定，简称SPD） - \\(u\\) 是未知量向量（所有网格点的解） - \\(b\\) 是已知项的向量（源项\\(f\\)和边界条件的组合）",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.4 4.1 二维（2D）偏微分方程问题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#时间相关问题抛物型parabolic",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#时间相关问题抛物型parabolic",
    "title": "9.4 4.1 二维（2D）偏微分方程问题",
    "section": "4.2 时间相关问题：抛物型（Parabolic）",
    "text": "4.2 时间相关问题：抛物型（Parabolic）\n考虑的问题形式：\n\\[\\frac{\\partial u}{\\partial t}-\\mu\\frac{\\partial^2 u}{\\partial x^2}=f,\\quad x\\in(0,1),\\quad 0&lt;t&lt;T\\]\n初值与边界条件为：\n\n初值：\\(u(x,t=0)=u_0(x)\\)\n边界条件：\\(u(0,t)=u_L(t),\\quad u(1,t)=u_R(t)\\)\n\n\n半离散化方法（空间离散，时间连续）\n我们首先只对空间（\\(x\\)）做离散化，得到：\n\\[\\frac{d u_j(t)}{d t}-\\mu\\frac{u_{j+1}(t)-2u_j(t)+u_{j-1}(t)}{\\Delta x^2}=f_j(t)\\]\n记：\n\n向量形式：\\(u(t)=[u_1(t),u_2(t),...,u_n(t)]^T\\)\n源项向量：\\(f(t)=[f_1(t),f_2(t),...,f_n(t)]^T\\)\n系数矩阵：\\(A=\\frac{\\mu}{\\Delta x^2}\\text{tridiag}(-1,2,-1)\\)\n\n于是问题变成常微分方程（ODE）的系统形式：\n\\[\\frac{d u}{d t}-A u=f\\]\n\n\n时间离散化（ODE方法）\n接下来我们对时间进行离散化，采用两种方法：\n\n方法1：显式欧拉（Explicit Euler, FE）\n将时间导数在时间点\\(t_n\\)近似为：\n\\[\\frac{u^{n+1}-u^n}{\\Delta t}=f^n+A u^n\\]\n解得：\n\\[u^{n+1} = (I+\\Delta t A)u^n+\\Delta t f^n\\]\n显式方法容易计算，但稳定性有限，时间步长不能太大。\n\n\n方法2：隐式欧拉（Implicit Euler, IE/BE）\n另一种方法是在时间点\\(t_{n+1}\\)处求导：\n\\[\\frac{u^{n+1}-u^n}{\\Delta t}=f^{n+1}+A u^{n+1}\\]\n解出隐式方程：\n\\[(I-\\Delta t A)u^{n+1}=u^n+\\Delta t f^{n+1}\\]\n这个方法更稳定，但需要在每个时间步解一个线性系统。\n\n\n\n关于矩阵性质的总结：\n\n\\(A\\) 为SPD矩阵（对称正定）\n当 \\(A\\) 和 \\(b\\) 是与时间无关时，通常我们更喜欢隐式方法，因为可以分解矩阵一次（如LU分解）并反复使用，加快计算速度。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.4 4.1 二维（2D）偏微分方程问题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#总结一下",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#总结一下",
    "title": "9.4 4.1 二维（2D）偏微分方程问题",
    "section": "总结一下：",
    "text": "总结一下：\n以上涉及了两类偏微分方程问题：\n\n椭圆型（空间二维）问题，通过空间离散化直接得到线性方程组；\n抛物型（空间一维+时间）问题，先对空间离散变为ODE，再对时间离散使用ODE数值方法（显式/隐式欧拉方法）进行求解。\n\n以上步骤逐步解释了问题如何从连续形式变成数值可求解的离散形式。\n\\[\n\\begin{align}\n-\\mu\\Delta u + \\vec{\\beta} \\cdot \\nabla u &= f \\\\\nu(\\partial\\Omega) &= \\text{data}\n\\end{align}\n\\]\nWrite it out: \\[\n\\begin{align}\n-\\mu\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) + \\beta_x\\frac{\\partial u}{\\partial x} + \\beta_y\\frac{\\partial u}{\\partial y} &= f(x,y) \\\\\nu(\\partial\\Omega) &= d\n\\end{align}\n\\]\n\n4.1 Only Consider Diffusion. Turn off Wind:\nTo form a system: \\((i,j) \\to k\\).\n\\(Au = b\\).\n\\(A\\) is symmetric, SPD.\n\n\n4.2 Turn on the Wind. Upwind\nWith upwind, the pts are not good.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.4 4.1 二维（2D）偏微分方程问题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#抛物型parabolic问题时间相关问题",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#抛物型parabolic问题时间相关问题",
    "title": "9.4 4.1 二维（2D）偏微分方程问题",
    "section": "5. 抛物型（Parabolic）问题（时间相关问题）",
    "text": "5. 抛物型（Parabolic）问题（时间相关问题）\n\\[\n\\begin{align}\n\\frac{\\partial u}{\\partial t} - \\mu\\frac{\\partial^2 u}{\\partial x^2} &= f, \\quad x \\in (0,1) \\quad 0 &lt; t &lt; T\\\\\nu(0,t) &= u_L(t), \\quad u(1,t) = u_R(t) \\\\\nu(x, t=0) &= u_0(x)\n\\end{align}\n\\]\nDiscretization along \\(x\\): semi-discretization: \\(u_j(t) \\approx u(x_j, t)\\). \\[\\frac{du_j}{dt} - \\mu\\frac{u_{j+1}(t) - 2u_j(t) + u_{j-1}(t)}{\\Delta x^2} = f_j(t) = f(x_j, t)\\]\nSo, we form system \\(Au = f\\).\n\\[A = \\frac{\\mu}{\\Delta x^2}\\text{Triad}(-1, 2, 1), \\quad u(t) = \\begin{bmatrix} u_1(t) \\\\ \\vdots \\\\ u_n(t) \\end{bmatrix}, \\quad f(t) = \\begin{bmatrix} f_1(t) \\\\ \\vdots \\\\ f_n(t) \\end{bmatrix}\\]\nThen, we have a system of ODE: \\[\\frac{du}{dt} - Au = f\\]\nWe can now do time discretization and use ODE methods.\n\nEE/FE: \\[u^n = u(t^n), \\quad \\left.\\frac{du}{dt}\\right|_{t^n} \\approx \\frac{u^{n+1} - u^n}{\\Delta t} = f^n + Au^n\\]\n\\[u^{n+1} = u^n + \\Delta t Au^n + \\Delta t f^n = (I + \\Delta t A)u^n + \\Delta t f^n = (I + \\Delta t A)^n u_0 + \\Delta t f^n\\]\nIE/BE: \\[\\left.\\frac{du}{dt}\\right|_{t^n} = \\frac{u^n - u^{n-1}}{\\Delta t} = f^n + Au^n\\]\n\\[u^n - u^{n-1} = \\Delta t f^n + \\Delta t Au^n\\]\n\\[u^n - \\Delta t Au^n = \\Delta t f^n + u^{n-1}\\]\n\\[(I - \\Delta t A)u^n = u^{n-1} + \\Delta t f^n \\quad \\leftarrow \\text{A linear system to solve}\\]\n\n\\(I - \\Delta t A\\) is SPD and \\(A\\) is time-independent. So, we may favor direct method (as we can store \\(A = LU\\) and reuse it) over iterative methods.\nTo discuss stability, set \\(f = 0\\):\n\nEE is conditionally stable: Let \\(\\lambda_i\\) be eigenvalues of \\(A\\).\n\\[\\Delta t &lt; \\frac{2}{|\\lambda_i|} \\quad \\text{for stability}\\]\nFurther, \\(A = \\frac{\\mu}{\\Delta x^2}\\text{triad}(1, -2, 1)\\), \\(\\rho(A) \\sim \\frac{c}{\\Delta x^2}\\). So,\n\\[\\Delta t &lt; \\frac{2}{|\\lambda_i|} \\leq \\frac{2}{\\rho(A)} = \\frac{2}{c}\\Delta x^2\\]\nSo, if we decrease \\(\\Delta x\\) by 2, to have stability\n\\[\\Delta t_{new} &lt; \\frac{2}{c}\\left(\\frac{\\Delta x}{2}\\right)^2 = \\frac{\\Delta t_{old}}{4} \\quad \\Rightarrow \\text{we need finer intervals for time}\\]\nIE is unconditionally stable.\nDef. (\\(\\theta\\) Methods). \\[\\frac{u^{n+1} - u^n}{\\Delta t} = \\theta Au^{n+1} + (1-\\theta)Au^n + \\theta f^{n+1} + (1-\\theta)f^n, \\quad \\theta \\in [0,1]\\]\nEE: \\(\\theta = 0 \\quad \\mathcal{O}(\\Delta t) \\quad\\) explicit \\(\\quad\\) conditional stability\nIE: \\(\\theta = 1 \\quad \\mathcal{O}(\\Delta t) \\quad\\) implicit \\(\\quad\\) unconditional stability\nCN: \\(\\theta = \\frac{1}{2} \\quad \\mathcal{O}(\\Delta t^2) \\quad\\) implicit \\(\\quad\\) unconditional stability\n\nSuppose \\(f = 0\\). Then, \\[\\frac{u^{n+1} - u^n}{\\Delta t} = \\theta Au^{n+1} + (1-\\theta)Au^n\\]\n\\[u^{n+1} - u^n = \\Delta t \\theta Au^{n+1} + \\Delta t(1-\\theta)Au^n\\]\n\\[(I - \\Delta t \\theta A)u^{n+1} = (I + \\Delta t(1-\\theta)A)u^n\\]\nWe essentially solve a linear system in each iteration.\n\n5.1 Thm (Stability and Order of \\(\\theta\\) Methods)\n\n\\(\\theta\\) methods are unconditionally stable for \\(\\theta \\geq \\frac{1}{2}\\). Otherwise, it is conditionally stable for \\(\\theta &lt; \\frac{1}{2}\\) and the stability condition for parabolic problem is \\(\\Delta t &lt; c\\Delta x^2\\).\nMeanwhile, the method is order 1 for \\(\\theta \\neq \\frac{1}{2}\\) and order 2 for \\(\\theta = \\frac{1}{2}\\).\nAlthough the \\(\\theta\\) method is 2nd order in space, the order of error is dominant and determined by the order in time.\nCN is the most vulnerable to lack of regularity and sensitive to non-smoothness.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.4 4.1 二维（2D）偏微分方程问题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#hyperbolic-problems",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.4 2D Problem.html#hyperbolic-problems",
    "title": "9.4 4.1 二维（2D）偏微分方程问题",
    "section": "6. Hyperbolic Problems",
    "text": "6. Hyperbolic Problems\n\n6.1\n$ \\[\\begin{align}\n\\frac{\\partial u}{\\partial t} + \\alpha\\frac{\\partial u}{\\partial x} &= 0, \\quad \\alpha &gt; 0, \\text{ constant} \\\\\nu(x,0) &= u_0(x)\n\\end{align}\\] $\nExact solution: \\(u(x,t) = u_0(x - \\alpha t)\\)\n\n\n6.2 Example: Modeling Density of Pollutant\n\\(u\\): pollutant, \\(x\\): displacement of boat, \\(t\\): time.\n$$ \\[\\begin{align}\n\\frac{du}{dx} &= 0 \\quad \\text{(i.e, pollutant and boat moves at the same velocity)} \\\\\n\\frac{dx}{dt} & = a \\quad \\text{(i.e., boat moves at velocity of $a$)}\n\\end{align}\\]\n$$\n\\(x(t) = x_0 + at \\Rightarrow\\) characteristic curves\n\\(u(x,t) = u_0(x-at)\\). Solution to \\(\\begin{cases} \\frac{dx}{dt} = a \\\\ x(0) = x_0 \\end{cases}\\)\nConsider \\(u(x(t),t)\\): \\(\\frac{du}{dt} = \\frac{\\partial u}{\\partial t} + \\frac{\\partial u}{\\partial x} \\cdot \\frac{dx}{dt} = \\frac{\\partial u}{\\partial t} + a \\cdot \\frac{\\partial u}{\\partial x} = 0\\).\n\n\n6.3 Similar Problems:\n\nConservation law \\(\\frac{\\partial u}{\\partial t} + \\frac{\\partial q(u)}{\\partial x} = 0\\)\n\\(q(u) = v(u) \\cdot u\\) with \\(v = v_{max}\\left(1 - \\frac{u}{u_{max}}\\right)\\)\n\\(\\Rightarrow \\frac{\\partial u}{\\partial t} + v_{max}\\left(1 - \\frac{u}{u_{max}}\\right)\\frac{\\partial u}{\\partial x} = 0\\). Models the density of traffic.\n\\(= \\alpha\\), but \\(\\alpha\\) is not constant here.\nHeat equation \\(\\frac{\\partial^2 u}{\\partial t^2} - v^2\\frac{\\partial^2 u}{\\partial x^2} = f\\)\nDefine \\(w_1 = \\frac{\\partial u}{\\partial x}\\) and \\(w_2 = \\frac{\\partial u}{\\partial t}\\).\n$ \\[\\begin{align}\n\\frac{\\partial w_1}{\\partial t} - v^2\\frac{\\partial w_2}{\\partial x} &= f \\\\\n\\frac{\\partial w_2}{\\partial t} - \\frac{\\partial w_1}{\\partial x} &= 0 \\quad \\frac{\\partial^2 u}{\\partial x \\partial t} = \\frac{\\partial^2 u}{\\partial t \\partial x}\n\\end{align}\\] $\nDefine \\(w = \\begin{bmatrix} w_1 \\\\ w_2 \\end{bmatrix}\\), \\(A = \\begin{bmatrix} 0 & -v^2 \\\\ -1 & 0 \\end{bmatrix}\\)\nThen, the original equation becomes a system: \\(\\frac{\\partial w}{\\partial t} + A\\frac{\\partial w}{\\partial x} = 0\\)\nThe eigenvalues of \\(A\\): \\(\\lambda_{1,2} = \\pm iv\\). \\(\\Rightarrow\\) Diagonalizable.\n\nFind the numerical solution.\n\\(\\frac{\\partial u}{\\partial t}\\bigg|_{t^{n+1}, x_j} = \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\\)\n\\(\\alpha\\frac{\\partial u}{\\partial x}\\bigg|_{t^{n+1}, x_j} = \\frac{\\alpha}{2} \\cdot \\frac{u_{j+1}^{n+1} - u_{j-1}^{n+1}}{\\Delta t}\\)\n\nWith BE-C: \\(\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + \\frac{\\alpha}{2} \\cdot \\frac{u_{j+1}^{n+1} - u_{j-1}^{n+1}}{\\Delta t} = 0\\)\n$ \n\\[\\begin{bmatrix}\n\\frac{1}{\\Delta t} & \\frac{\\alpha}{2\\Delta t} & 0 & 0 & \\cdots \\\\\n-\\frac{\\alpha}{2\\Delta t} & \\frac{1}{\\Delta t} & \\frac{\\alpha}{2\\Delta t} & 0 & \\cdots \\\\\n& & \\ddots & &\n\\end{bmatrix}\\]\n$\nWith FE-C: unconditionally unstable. NEVER USE IT! \\(\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + \\frac{\\alpha}{2} \\cdot \\frac{u_{j+1}^n - u_{j-1}^n}{\\Delta t} = 0\\)\n\\(\\Rightarrow u_j^{n+1} = u_j^n + \\frac{\\alpha\\Delta t}{2\\Delta t}(u_{j+1}^n - u_{j-1}^n)\\)\nWith FE-Upwind: \\(\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + \\alpha\\frac{u_j^n - u_{j-1}^n}{\\Delta x} = 0 \\quad \\alpha &gt; 0\\)\n\\(\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + \\alpha\\frac{u_{j+1}^n - u_j^n}{\\Delta x} = 0 \\quad \\alpha &lt; 0\\)\n\\(\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + \\frac{\\alpha}{2}\\frac{u_{j+1}^n - u_{j-1}^n}{\\Delta x} - \\frac{|\\alpha|\\Delta t}{2}\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2} = 0\\)\nDiffusion\nLax Wendroff: FE-upwind with modified coefficient \\(\\frac{u_j^{n+1} - u_j^n}{\\Delta t} + \\frac{\\alpha}{2}\\frac{u_{j+1}^n - u_{j-1}^n}{\\Delta x} - \\frac{\\alpha^2\\Delta t}{2}\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2} = 0\\)\n\\(u(x_j, t^{n+1}) = u(x_j, t^n) + \\frac{\\partial u}{\\partial t}\\bigg|_{t^n, x_j}(t^{n+1} - t^n) + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial t^2}\\bigg|_{t^n, x_j}(t^{n+1} - t^n)^2 + \\mathcal{O}(||t^{n+1} - t^n||^3)\\)\n\n\\(\\frac{\\partial u}{\\partial t} = -\\alpha\\frac{\\partial u}{\\partial x}, \\quad \\frac{\\partial^2 u}{\\partial x \\partial t} = -\\alpha\\frac{\\partial^2 u}{\\partial x^2}, \\quad \\frac{\\partial^2 u}{\\partial t^2} = \\alpha^2\\frac{\\partial^2 u}{\\partial x^2}\\)\nSubstitute: \\(u_j^{n+1} = u_j^n - \\alpha\\left(\\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x}\\right)\\Delta t + \\frac{\\alpha^2}{2}\\left(\\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2}\\right)\\Delta t^2\\)\nStability: \\(\\left|\\frac{\\alpha\\Delta t}{\\Delta x}\\right| \\leq 1\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.4 4.1 二维（2D）偏微分方程问题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html",
    "title": "9.2 有限差分法",
    "section": "",
    "text": "[!claim|*] Consider the Boundary-Value Problem: \\[\n\\begin{align}\n-\\mu\\frac{d^2u}{dx^2} &= f, \\quad x \\in (0,1) \\\\\nu(0) &= u(1) = 0\n\\end{align}\n\\] with discrete points: \\[0 = x_0 &lt; x_1 &lt;  \\cdots &lt; x_{N} = 1\\quad\\Longrightarrow \\quad-\\mu\\frac{d^2u}{dx^2}(x_i) = f(x_i)\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.2 有限差分法"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html#边值问题bvp的有限差分",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html#边值问题bvp的有限差分",
    "title": "9.2 有限差分法",
    "section": "",
    "text": "[!claim|*] Consider the Boundary-Value Problem: \\[\n\\begin{align}\n-\\mu\\frac{d^2u}{dx^2} &= f, \\quad x \\in (0,1) \\\\\nu(0) &= u(1) = 0\n\\end{align}\n\\] with discrete points: \\[0 = x_0 &lt; x_1 &lt;  \\cdots &lt; x_{N} = 1\\quad\\Longrightarrow \\quad-\\mu\\frac{d^2u}{dx^2}(x_i) = f(x_i)\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.2 有限差分法"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html#推导二阶中心差分近似法",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html#推导二阶中心差分近似法",
    "title": "9.2 有限差分法",
    "section": "2.2 推导二阶中心差分近似法",
    "text": "2.2 推导二阶中心差分近似法\n\n2.2.1 Poisson 微分方程\n对与任意一个离散的点\\(x_{i}\\)，我们首先在网格点 \\(x_{i+1} = x_i + \\Delta x\\) 和 \\(x_{i-1} = x_i - \\Delta x\\) 处对函数 \\(u(x)\\) 进行泰勒级数展开：\n\\[\n\\begin{align}\nu(x_{i+1}) &= u(x_i) + \\frac{du}{dx}(x_i)\\Delta x + \\frac{1}{2}\\frac{d^2u}{dx^2}(x_i)\\Delta x^2 + \\cdots \\\\\nu(x_{i-1}) &= u(x_i) - \\frac{du}{dx}(x_i)\\Delta x + \\frac{1}{2}\\frac{d^2u}{dx^2}(x_i)\\Delta x^2 + \\cdots\n\\end{align}\n\\]\n当我们将这两个方程相加时，由于奇数阶导数项的符号相反，它们会相互抵消：\n\\[\n\\begin{align}\nu(x_{i+1}) + u(x_{i-1}) &= 2u(x_i) + 2\\left(\\frac{1}{2}\\frac{d^2u}{dx^2}(x_i)\\Delta x^2\\right) + 2\\left(\\frac{1}{24}\\frac{d^4u}{dx^4}(x_i)\\Delta x^4\\right) + \\mathcal{O}(\\Delta x^6) \\\\\n\\\\\n&= 2u(x_i) + \\frac{d^2u}{dx^2}(x_i)\\Delta x^2 + \\frac{1}{12}\\frac{d^4u}{dx^4}(x_i)\\Delta x^4 + \\mathcal{O}(\\Delta x^6)\n\\end{align}\n\\]\n接着, 我们重新整理方程以分离出二阶导数项（舍去高阶项）\n\\[\\begin{align}\n\\frac{d^2u}{dx^2}(x_i)\\Delta x^2 &= u(x_{i+1}) + u(x_{i-1}) - 2u(x_i) - \\frac{1}{12}\\frac{d^4u}{dx^4}(x_i)\\Delta x^4 + \\mathcal{O}(||\\Delta x||^6)\\\\\n\\frac{d^2u}{dx^2}(x_i) &= \\frac{u(x_{i+1}) + u(x_{i-1}) - 2u(x_i)}{\\Delta x^2} - \\frac{1}{12}\\frac{d^4u}{dx^4}(x_i)\\Delta x^2 + \\mathcal{O}(||\\Delta x||^2) \\\\\n&\\approx \\boxed{ \\frac{u(x_{i+1}) + u(x_{i-1}) - 2u(x_i)}{\\Delta x^2}}\n\\end{align}\\]\n记 \\(u_i = u(x_i)\\) 与 \\(f_i = f(x_i)\\). 因此我们得到微分方程\n\n[!claim|*] \\[-\\mu\\frac{d^2u}{dx^2}(x_i) = -\\mu\\frac{u_{i+1} + u_{i-1} - 2u_i}{\\Delta x^2} = f_i\\]\n\n\n\n截断误差（Truncation Error）为 \\(\\mathcal{O}(\\Delta x^2)\\)\n这证实了该近似是二阶精度 （second-order accuracy）\n\n\n\n\n2.2.2 构建线性系统\n用这种离散化方法推导出一个线性方程组（linear system）:\n\\[Au = f\\]\nwhere \\(A\\) is given by:\n\\[A = \\frac{\\mu}{\\Delta x^2}\n\\begin{bmatrix}\n2 & -1 & 0 & & \\\\\n-1 & \\ddots & \\ddots & & \\\\\n0 & \\ddots & \\ddots & \\ddots & \\\\\n& & \\ddots & \\ddots & -1 \\\\\n& & & -1 & 2\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.2 有限差分法"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html#what-is-the-accuracy-of-fd",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.2 Finite Difference.html#what-is-the-accuracy-of-fd",
    "title": "9.2 有限差分法",
    "section": "2.3 What is the Accuracy of FD?",
    "text": "2.3 What is the Accuracy of FD?\n\n矩阵A的关键性质 (Key Properties of Matrix A)\n从差分离散化得到的matrix \\(A\\)有几个重要性质：\n\n正定性 (Positive Definiteness)：\\(x^TAx &gt; 0 \\quad \\forall x \\neq 0\\) \\(\\Longrightarrow\\) solvable。\n对称性 (Symmetry)：Symmetry \\(\\Longrightarrow \\forall \\,\\lambda \\in \\mathbb{R}\\)\n特征值性质 (Eigenvalue Properties)：Non-singular\n条件数关系 (Condition Number Relation)：A的最小特征值与最大特征值之比与Δx成正比，即\\[\\frac{\\lambda_{min}}{\\lambda_{max}} \\propto \\Delta x\\]\n\n\n\n误差\n当我们解离散系统（\\(Au = f\\)）时，精确解\\(u_{ex}\\)与近似解\\(u\\)之间存在误差，所以\\(Au_{ex} \\neq f\\)。\n精确关系实际上为：\n\n[!claim|*] \\[Au_{ex} = f + T\\] where \\(T_i = C(x_i)\\Delta x^2\\) is truncation error\n\n其中\\(C(x_i)\\)与四阶导数相关：\\[C(x_i) = C\\frac{d^4u}{dx^4}(x_i)\\]\n\n\n误差方程 (Error Equation)\n若定义误差\\(e = u_{ex} - u\\)，则 \\[Ae = T\\]\n\\[\\Longrightarrow e = A^{-1}T\\]\n因此\n\\[||e|| = ||A^{-1}T|| \\leq ||A^{-1}|| \\cdot ||T||\\]\n\n\n收敛性证明 (Convergence Proof)\n为了证明方法收敛，需要满足两个条件：1. 稳定性：\\(A^{-1}\\)有界 (Boundedness of \\(A^{-1}\\)) 2. 一致性：截断误差趋零 (Truncation Error Tends to Zero)\n\n[!lemma|*] Conditions to show convergence: \\[||A^{-1}|| &lt; \\infty \\quad \\text{and} \\quad ||T|| \\to 0 \\quad \\text{as} \\quad \\Delta x \\to 0\\]\n\n\n关于 \\(\\|A^{-1}\\|\\) 的有界性\n\n矩阵的条件数定义为：\n\n\\[\\kappa(A) = \\|A\\| \\cdot \\|A^{-1}\\|=\\frac{\\lambda_{max}}{\\lambda_{min}}\\]\n\n\\(\\frac{\\lambda_{min}}{\\lambda_{max}} \\propto \\Delta x \\longrightarrow\\kappa(A) \\propto \\frac{1}{\\Delta x}\\)\nhence, \\(||A^{-1}||\\) is bounded, regardless of \\(\\Delta x\\).\n\n\n\n关于\\(T\\)的一致性\n因为截断误差范数\\(\\|T\\| \\sim \\Delta x^2\\)，所以\n\\[\\|T\\| \\to 0 \\,\\,\\text{as}\\,\\, \\Delta x \\to 0\\]\n这也意味着：\n\\[\\|e\\| \\to 0 \\,\\,\\text{as}\\,\\, \\Delta x \\to 0\\]\n\n因此，该有限差分方法是收敛的 (convergent)\n\n\n虽然\\(\\kappa\\)随 \\(\\Delta x\\) 变化，但 \\(\\|A^{-1}\\|\\) 的增长被 \\(\\|T\\|\\) 的更快减小所抵消。\n\n\n\n\n实际意义？\n\n该有限差分法随着网格间距 (grid spacing) 减小而收敛到精确解\n收敛速率 (convergence rate) 是\\(O(\\Delta x^2)\\)，即二阶精度 (second-order accuracy)\n误差主要受控于四阶导数的大小和网格间距的平方\n这解释了为什么在实际计算中，当我们将网格间距减半时，误差大约会减小到原来的四分之一\n\n这种数学证明为我们使用有限差分法求解微分方程提供了理论保障，确保了在足够细的网格下，数值解 (numerical solution) 会以可预测的速率接近真实解 (exact solution)。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.2 有限差分法"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/index.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/index.html",
    "title": "数值方法",
    "section": "",
    "text": "1. Ok Honestly I Have No Idea Where He Started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1 边值问题的近似\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.2 有限差分法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3 对流-扩散方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.4 4.1 二维（2D）偏微分方程问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormula Derivation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder of Convergence in Finite Elements\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolutions for Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n习题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常微分方程的数值解\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第九章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第十章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第四章 有限元分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/02 Three-Point Backward Differentiation Formula.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/02 Three-Point Backward Differentiation Formula.html",
    "title": "Erise Note",
    "section": "",
    "text": "MATH 212 is useless - Alessandro Veneziani\n\nGiven the population problem #Implicit:\n\\[\n\\dfrac{d y}{d x} = A\\left( 1 - \\dfrac{y}{B}\\right)y\n\\] * Numerically**, the problem is: \\[\n\\frac{u_{i+1} - u_i}{\\Delta t} = A \\left(1 - \\frac{u_{i+1}}{B} \\right) u_{i+1}\n\\] To solve this numerically, we rewrite the equation: \\[\n\\begin{align}\nx - u_i &= A \\left(1 - \\frac{x}{B} \\right) x \\\\\n&= A x - \\frac{A}{B} x^2\n\\end{align}\n\\]\nusing \\(f(x)=0\\), and we iterate using Newton’s method: &gt; yes he changed notation again\n\n[!remark|*] Newton’s Method \\[\\underbrace{x^{(u+1)}}_{y_{\\text{new}}}=\\underbrace{x^{(u)}}_{y_{\\text{old}}}-\\frac{f(x^{(u)})}{f'(x^{(u)})}\\] We have \\(|y_{\\text{new}}-y_{\\text{old}}|\\leq \\text{tol}.\\)\n\n$$ \\[\\begin{align}\nx - u_i  & = \\Delta t A \\left(1 - \\frac{x}{B} \\right) x \\\\\n& = \\Delta t A x - \\Delta t \\frac{A}{B} x^2 \\\\\n\n\\Longrightarrow \\quad x - u_{i}-\\Delta t A x + \\Delta t \\frac{A}{B} x^{2}&=0\n\\end{align}\\] \\[\nDefine a function $g(x)$ from above:\n\\] \\[\\begin{align}\ng(x)  & = x - u_i - \\Delta t A x + \\Delta t \\frac{A}{B} x^{2}\\\\\n\\end{align}\\] \\[\nTaking the derivative:\n\\] \\[\\begin{align}\n    g'(x) &= \\frac{d}{dx} \\left( x - u_i - \\Delta t A x + \\Delta t \\frac{A}{B} x^2 \\right) \\\\\n    &= 1 - \\Delta t \\left(A - \\frac{2A}{B} x \\right) \\\\\n    &= 1 - \\Delta t f'(x).\n\\end{align}\\] $$ For \\(f^{\\prime}(x)=A-\\frac{2 A}{B} x\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "1. Ok Honestly I Have No Idea Where He Started"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/02 Three-Point Backward Differentiation Formula.html#ok-honestly-i-have-no-idea-where-he-started",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/02 Three-Point Backward Differentiation Formula.html#ok-honestly-i-have-no-idea-where-he-started",
    "title": "Erise Note",
    "section": "",
    "text": "MATH 212 is useless - Alessandro Veneziani\n\nGiven the population problem #Implicit:\n\\[\n\\dfrac{d y}{d x} = A\\left( 1 - \\dfrac{y}{B}\\right)y\n\\] * Numerically**, the problem is: \\[\n\\frac{u_{i+1} - u_i}{\\Delta t} = A \\left(1 - \\frac{u_{i+1}}{B} \\right) u_{i+1}\n\\] To solve this numerically, we rewrite the equation: \\[\n\\begin{align}\nx - u_i &= A \\left(1 - \\frac{x}{B} \\right) x \\\\\n&= A x - \\frac{A}{B} x^2\n\\end{align}\n\\]\nusing \\(f(x)=0\\), and we iterate using Newton’s method: &gt; yes he changed notation again\n\n[!remark|*] Newton’s Method \\[\\underbrace{x^{(u+1)}}_{y_{\\text{new}}}=\\underbrace{x^{(u)}}_{y_{\\text{old}}}-\\frac{f(x^{(u)})}{f'(x^{(u)})}\\] We have \\(|y_{\\text{new}}-y_{\\text{old}}|\\leq \\text{tol}.\\)\n\n$$ \\[\\begin{align}\nx - u_i  & = \\Delta t A \\left(1 - \\frac{x}{B} \\right) x \\\\\n& = \\Delta t A x - \\Delta t \\frac{A}{B} x^2 \\\\\n\n\\Longrightarrow \\quad x - u_{i}-\\Delta t A x + \\Delta t \\frac{A}{B} x^{2}&=0\n\\end{align}\\] \\[\nDefine a function $g(x)$ from above:\n\\] \\[\\begin{align}\ng(x)  & = x - u_i - \\Delta t A x + \\Delta t \\frac{A}{B} x^{2}\\\\\n\\end{align}\\] \\[\nTaking the derivative:\n\\] \\[\\begin{align}\n    g'(x) &= \\frac{d}{dx} \\left( x - u_i - \\Delta t A x + \\Delta t \\frac{A}{B} x^2 \\right) \\\\\n    &= 1 - \\Delta t \\left(A - \\frac{2A}{B} x \\right) \\\\\n    &= 1 - \\Delta t f'(x).\n\\end{align}\\] $$ For \\(f^{\\prime}(x)=A-\\frac{2 A}{B} x\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "1. Ok Honestly I Have No Idea Where He Started"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/02 Three-Point Backward Differentiation Formula.html#approximate-fracd-yd-x-using-a-three-point-backward-differentiation-formula-bdf",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/02 Three-Point Backward Differentiation Formula.html#approximate-fracd-yd-x-using-a-three-point-backward-differentiation-formula-bdf",
    "title": "Erise Note",
    "section": "2. Approximate \\(\\frac{d y}{d x}\\) Using a Three-Point Backward Differentiation Formula (BDF)",
    "text": "2. Approximate \\(\\frac{d y}{d x}\\) Using a Three-Point Backward Differentiation Formula (BDF)\n\ntracing back to last lecture on determination of coefficients \\(A, B, C\\)\n\n\\[\n\\begin{aligned}\nf(t_{i},y_{i})=\\left. \\frac{dy}{dx} \\right|_{x_i} &\\approx \\frac{3}{2 \\Delta x} y_i - \\frac{4}{2 \\Delta x} y_{i-1} + \\frac{1}{2 \\Delta x} y_{i-2} \\\\ \\\\\n\\text{Taylor Expansion}\\Longrightarrow\\quad\n&\\left\\{\n\\begin{aligned}\ny_{i-1} &= y_i - \\left. \\frac{dy}{dx} \\right|_{x_i} \\Delta x \\dots \\\\\ny_{i-2} &= y_i - \\left. \\frac{dy}{dx} \\right|_{x_i} 2 \\Delta x \\dots\n\\end{aligned}\n\\right.\n\\end{aligned}\\] we yield: \\[\n\\begin{align}\n\\frac{3}{2 \\Delta x} u_i&-\\frac{4}{2 \\Delta x} u_{i-1}+\\frac{1}{2 \\Delta x} u_{i-2}=f\\left(t_i , u_i\\right)\\\\\n\\end{align}\n\\]\nImplicit formula: \\[\nu_i=\\frac{4}{3} u_{i-1}-\\frac{1}{3} u_{i-2}+\\frac{2}{3} \\Delta x\\left(t_i, u_i\\right)\n\\] we substitute \\(f(t_{i},u_{i})=\\lambda u_{i}\\) to derive explicitly:\n\\[\\begin{align}\nu_i - \\frac{4}{3} u_{i-1} + \\frac{1}{3} u_{i-2} - &\\frac{2}{3} \\Delta x f(t_i, u_i) = 0 \\\\\nu_i - \\frac{4}{3} u_{i-1} + \\frac{1}{3} u_{i-2} - &\\frac{2}{3} \\Delta x \\lambda u_{i} = 0 \\\\\n\\end{align}\n\\] Explicit formula: $$\n$$\n\n[!definition|*] Generalized p-step BDF Form \\[\\boxed{u_i-\\sum_{j=1}^{p} \\alpha_j u_{i-j}=\\Delta x \\beta_{-1} f\\left(t_i, u_i\\right)} \\] Generalized Implicit Multistep Method: \\[\\boxed{u_{i+1}-\\sum_{j=1}^p \\alpha_j u_{i-j}=\\Delta x \\sum_{j={-1}}^p \\beta_j f\\left(t_{i-j}, u_{i+1-j}\\right)}\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "1. Ok Honestly I Have No Idea Where He Started"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html",
    "title": "傅立叶级数",
    "section": "",
    "text": "在经历了周期\\(T\\)后，重新获得原值的函数为周期函数：\n\\[\n\\varphi(t+T)=\\varphi\n\\]\n\n\n\n正弦型量形如：\n\n\\(y(t)=Asin(\\omega t+\\alpha)\\) where \\(\\omega = \\cfrac{2\\pi}{T}\\) is the frequency.\n\nNotice that for values \\(s.t.\\):\n\\[\ny_0 = A_0, \\ y_1=A_1\\sin(\\omega t + \\alpha_1), \\  y_2=A_2\\sin(2\\omega t + \\alpha_2), \\ y_3=A_3\\sin(3\\omega t + \\alpha_3) ...\n\\]\nwe have frequency as the multiple of the smallest frequency with their period:\n\\(\\omega\\), \\(2\\omega\\), \\(3\\omega\\)…\n\\(T\\), \\(\\frac{1}{2}T\\), \\(\\frac{1}{3}T\\)…\n![[Fourier Series.png]]\nIf we add them together, we get…\n\n\n\n\n💡 It is possible to represent any periodic function with finite or infinite summations of sin functions:\n\\[\n\\varphi(t)=A_0 + \\sum_{n=1}^{\\infty}A_n\\sin(n\\omega t+ \\alpha_n)\n\\]\nwhere \\(A_n, \\alpha_n\\) are constants\n\n\\(\\varphi(t)\\)可以被分解成无数个调和震动\n每一项称之为调和素\n对\\(\\varphi(t)\\)进行分解的手法被称之为调和分析\n\n\n\n\n\n\n注意ppt里的公式是不一样的换元，\\(x=\\frac{2Lt}{T}\\)，所以\\(\\frac{\\pi}{L}\\)被抽出来了。这里我们会用正常的逻辑换元推导，等到后面需要计算generic interval，才重新换一个\\(L\\)进去***\n\n当我们用\\(x=\\omega t = \\frac{2\\pi t}{T}\\) 来换元 \\(s.t.\\) \\(f(x)=\\varphi(t) = \\varphi(\\frac{x}{\\omega})\\) ，我们用三角正弦公式展开：\n\\[\n\\begin{align}f(x)&= A_0 + \\sum_{n=1}^{\\infty}A_n\\sin(nx+ \\alpha_n)\\\\  &=A_0 + \\sum_{n=1}^{\\infty}A_n(\\cos nx\\sin \\alpha_n+ \\sin nx \\cos \\alpha_n) \\\\\\end{align}\n\\]\n\n正弦公式：\\(\\sin(a+b)=\\cos a\\sin b + \\sin a\\cos b\\) 展开\n\n\\[\nf(x)=A_0+\\sum_{n=1}^{\\infty}[(A_n\\sin \\alpha_n)\\cos nx+ (A_n \\cos \\alpha_n)\\sin nx )]\n\\]\n并令 \\(A_0=a_0, \\ A_n\\sin\\alpha_n = b_n, \\  A_n\\cos\\alpha_n = b_n\\)\n\n💡 于是我们就有了会有三角级数的最终展开形态：\n\\[\nf(x)=a_0 + \\sum_{n=1}^{\\infty}(a_n\\cos nx+ b_n\\sin nx)\n\\]\n\nthe period for \\(f\\) is \\(2\\pi\\) due to our definition of new independent variable \\(x\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#周期",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#周期",
    "title": "傅立叶级数",
    "section": "",
    "text": "在经历了周期\\(T\\)后，重新获得原值的函数为周期函数：\n\\[\n\\varphi(t+T)=\\varphi\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#正弦型量",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#正弦型量",
    "title": "傅立叶级数",
    "section": "",
    "text": "正弦型量形如：\n\n\\(y(t)=Asin(\\omega t+\\alpha)\\) where \\(\\omega = \\cfrac{2\\pi}{T}\\) is the frequency.\n\nNotice that for values \\(s.t.\\):\n\\[\ny_0 = A_0, \\ y_1=A_1\\sin(\\omega t + \\alpha_1), \\  y_2=A_2\\sin(2\\omega t + \\alpha_2), \\ y_3=A_3\\sin(3\\omega t + \\alpha_3) ...\n\\]\nwe have frequency as the multiple of the smallest frequency with their period:\n\\(\\omega\\), \\(2\\omega\\), \\(3\\omega\\)…\n\\(T\\), \\(\\frac{1}{2}T\\), \\(\\frac{1}{3}T\\)…\n![[Fourier Series.png]]\nIf we add them together, we get…",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#三角级数---varphit函数",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#三角级数---varphit函数",
    "title": "傅立叶级数",
    "section": "",
    "text": "💡 It is possible to represent any periodic function with finite or infinite summations of sin functions:\n\\[\n\\varphi(t)=A_0 + \\sum_{n=1}^{\\infty}A_n\\sin(n\\omega t+ \\alpha_n)\n\\]\nwhere \\(A_n, \\alpha_n\\) are constants\n\n\\(\\varphi(t)\\)可以被分解成无数个调和震动\n每一项称之为调和素\n对\\(\\varphi(t)\\)进行分解的手法被称之为调和分析",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#三角级数---最终展开式",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#三角级数---最终展开式",
    "title": "傅立叶级数",
    "section": "",
    "text": "注意ppt里的公式是不一样的换元，\\(x=\\frac{2Lt}{T}\\)，所以\\(\\frac{\\pi}{L}\\)被抽出来了。这里我们会用正常的逻辑换元推导，等到后面需要计算generic interval，才重新换一个\\(L\\)进去***\n\n当我们用\\(x=\\omega t = \\frac{2\\pi t}{T}\\) 来换元 \\(s.t.\\) \\(f(x)=\\varphi(t) = \\varphi(\\frac{x}{\\omega})\\) ，我们用三角正弦公式展开：\n\\[\n\\begin{align}f(x)&= A_0 + \\sum_{n=1}^{\\infty}A_n\\sin(nx+ \\alpha_n)\\\\  &=A_0 + \\sum_{n=1}^{\\infty}A_n(\\cos nx\\sin \\alpha_n+ \\sin nx \\cos \\alpha_n) \\\\\\end{align}\n\\]\n\n正弦公式：\\(\\sin(a+b)=\\cos a\\sin b + \\sin a\\cos b\\) 展开\n\n\\[\nf(x)=A_0+\\sum_{n=1}^{\\infty}[(A_n\\sin \\alpha_n)\\cos nx+ (A_n \\cos \\alpha_n)\\sin nx )]\n\\]\n并令 \\(A_0=a_0, \\ A_n\\sin\\alpha_n = b_n, \\  A_n\\cos\\alpha_n = b_n\\)\n\n💡 于是我们就有了会有三角级数的最终展开形态：\n\\[\nf(x)=a_0 + \\sum_{n=1}^{\\infty}(a_n\\cos nx+ b_n\\sin nx)\n\\]\n\nthe period for \\(f\\) is \\(2\\pi\\) due to our definition of new independent variable \\(x\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#欧拉-傅立叶公式euler-fourier-formula",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#欧拉-傅立叶公式euler-fourier-formula",
    "title": "傅立叶级数",
    "section": "2.1 欧拉-傅立叶公式（Euler-Fourier formula）",
    "text": "2.1 欧拉-傅立叶公式（Euler-Fourier formula）\n\n这个是一个18世纪初欧拉使用的系数确定法。后面我们还学了泛函分析的inner product算系数的方法。\n\nAssuming \\(f(x)\\) under \\([-\\pi,\\pi]\\) is an integrable function, if we assume Fourier Expansion for \\(f(x)\\) is true, then directly we have:\n\\[\n\\begin{align}\\int_{-\\pi}^{\\pi} f(x) \\, dx = 2\\pi a_0 + \\sum_{n=1}^{\\infty} \\left[ a_n \\int_{-\\pi}^{\\pi} \\cos nx \\, dx + b_n \\int_{-\\pi}^{\\pi} \\sin nx \\, dx \\right]\\end{align}\n\\]\nobviously, the integration for \\(\\cos\\) and \\(\\sin\\) for \\([-\\pi,\\pi]\\) is 0 regardless of the values, so we only left with:\n\\[\na_0= \\frac{1}{2\\pi}\\int_{-\\pi}^{\\pi} f(x) \\, dx\n\\]\nnext, if to find the specific value for arbitrary \\(a_m\\) (\\(m=1,2,3...\\)), we multiply \\((3)\\) by \\(\\cos (ma)\\) so that the terms we needed wouldn’t cancel out, eventually we reached at:\n\\[\na_m= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\cos(ma) \\, dx\n\\]\nSimilarly, multiply by \\(\\sin(ma)\\), we derive:\n\\[\nb_m= \\frac{1}{\\pi}\\int_{-\\pi}^{\\pi} f(x) \\sin(ma) \\, dx\n\\]\n这些公式被称之为欧拉-傅立叶公式（Euler-Fourier formula），而他们算出来的数值被称为已给函数的傅立叶系数（Fourier Coefficient）。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#狄利克雷积分dirichlet-integral",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#狄利克雷积分dirichlet-integral",
    "title": "傅立叶级数",
    "section": "2.2* 狄利克雷积分（Dirichlet integral）",
    "text": "2.2* 狄利克雷积分（Dirichlet integral）\n\n通过傅立叶展开的一个定点\\(x=x_0\\)的性质，获得的重要积分：\n\n$$ s_n(x_0) = _{0}^{} , dt\n$$\ne.x. https://www.bilibili.com/video/BV1XE411p7ZN/",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#任意区间的情况",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#任意区间的情况",
    "title": "傅立叶级数",
    "section": "3.1 任意区间的情况",
    "text": "3.1 任意区间的情况\n\n💡 We can separate out a \\(\\frac{1}{2}\\) from the original \\(a_0\\) coefficient, so the first term becomes a special case for \\(n=0\\).\n\n在任意\\(2L\\)大小的区间 \\((-L,L]\\) 上，我们可以使用变换：\\(x=\\frac{Ly}{\\pi} (-\\pi&lt;y\\leq\\pi)\\) 使得\\(f(x)\\rightarrow f(\\frac{Ly}{\\pi})\\) 。于是，我们根据公式获得：\n\\[\nf\\left( \\frac{Ly}{\\pi} \\right) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty} \\left( a_n \\cos ny + b_n \\sin ny \\right)\n\\]\n以及其系数：\n\\[\na_n = \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f\\left( \\frac{y}{\\pi} \\right) \\cos ny \\, dy \\quad (n = 0, 1, 2, \\ldots)\n\\]\n$$\nb_n = _{-}^{} f( ) ny , dy (n = 1, 2, ) $$\n当我们重新变换回去，即使得\\(y = \\cfrac{\\pi x}{L}\\)，那么我们就会获得一个广义上的傅立叶展开！\n\n💡 The general form of Fourier Expansion:\n\\[\n\\begin{align}f(x)=\\frac{A_0}{2} + \\sum_{n=1}^{\\infty} \\left( A_n \\cos \\frac{n\\pi x}{L} + B_n \\sin \\frac{n\\pi x}{L} \\right) \\end{align}\n\\]\nHere, \\(x\\) is no longer the angle, but the integer multiples of \\(\\frac{\\pi x}{L}\\), such that the Fourier Coefficient for generic interval \\([-L,L]\\) are:\n$$ \\[\\begin{align} A_n \\equiv \\frac{1}{L} \\int_{-L}^{L} f(x) \\cos\\left(\\frac{n\\pi x}{L}\\right) dx, \\quad n = 0, 1, 2, \\ldots\n\\\\\nB_n \\equiv \\frac{1}{L} \\int_{-L}^{L} f(x) \\sin\\left(\\frac{n\\pi x}{L}\\right) dx, \\quad n = 1, 2, 3, \\ldots \\end{align}\\]\n$$",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#菜就多练给爷展",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#菜就多练给爷展",
    "title": "傅立叶级数",
    "section": "3.2 菜就多练，给爷展",
    "text": "3.2 菜就多练，给爷展\n\n\\(f(x)=e^{ax}\\), \\(a\\neq0\\) on the interval of \\((-\\pi,\\pi)\\)\n答案\n\\(f(x)=\\frac{\\pi-x}{2}\\) on the interval of \\((0,2\\pi)\\)\n答案\n\\(f(x)=x^2\\) on the interval of \\([-\\pi,\\pi]\\), expand as cosine series.\n答案\nTwo functions (\\(a\\) is assumed to be non-integers):\n\n\\(f_1(x)=\\cos(ax)\\) on the interval of \\([-\\pi,\\pi]\\), expand as cosine series.\n答案\n\\(f_2(x)=\\sin(ax)\\) on the interval of \\((-\\pi,\\pi)\\), expand as sine series.\n答案\n\n\\(f(x)=e^{ax}\\), \\(a\\neq0\\) on the interval of \\((0,\\pi)\\):\n\nexpand as cosine series\nexpand as sine series\n\n答案",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#infty维欧式空间---rinfty",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#infty维欧式空间---rinfty",
    "title": "傅立叶级数",
    "section": "4.1 \\(\\infty\\)维欧式空间 - \\(\\R^{\\infty}\\)",
    "text": "4.1 \\(\\infty\\)维欧式空间 - \\(\\R^{\\infty}\\)\n\n4.1.1 \\(n\\)维空间的定义- \\(\\R^{n}\\)\n范数（Norm）:\n\\[\nN_p(x) = \\| x \\|_p = \\left( |x_1|^p + |x_2|^p + \\cdots + |x_n|^p \\right)^{\\frac{1}{p}}\n\\]\n单位正交向量基（standard orthogonal basis）:\n\\[\n\\left\\{ \\begin{aligned}\\vec{e}_1 &= (1, 0, \\ldots, 0), \\\\\\vec{e}_2 &= (0, 1, \\ldots, 0), \\\\& \\vdots \\\\\\vec{e}_n &= (0, 0, \\ldots, 1)\\end{aligned}\\right.\n\\]\n因此\\(n\\)维欧式空间的任何向量可以被直接表达成：\n\\[\n\\vec{a} = \\sum_{i=1}^{n} a_i \\vec{e}_i\n\\]\n\n\n4.1.2 由此推出\\(\\infty\\)维空间 - \\(\\R^{\\infty}\\)\n同理，当我们有无数个标准基，\\(\\{ \\vec{e}_1 , \\vec{e}_2 , \\vec{e}_3 \\ldots\\}\\)，的时候，向量变成了\n\\[\n\\vec{a} = \\sum_{i=1}^{\\infty} a_i \\vec{e}_i\n\\]\n\n但是他们依然是离散的元素",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#hilbert空间",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#hilbert空间",
    "title": "傅立叶级数",
    "section": "4.2 Hilbert空间",
    "text": "4.2 Hilbert空间\n我们需要把离散的元素过度到连续的函数，Hilbert空间：\n\n设定一个向量函数\\(\\vec{f}(x)\\)\n并且存在一组基函数（standard orthogonal functions）\n\\(\\{ \\vec{\\varphi}_1 , \\vec{\\varphi}_2 , \\vec{\\varphi}_3 \\ldots\\}\\) \\(s.t.\\) we have\n\\[\n\\vec{f}(x) = \\sum_{i=1}^{\\infty} a_i \\vec{\\varphi_i}(x)\n\\]\n\n因此，我们在Hilbert空间就有了这样的性质：\n\n💡 1. 函数在区间\\([a,b]\\)上的模（norm）：\n\\[\n| f(x) | = \\sqrt{\\int_a^b f^2(x) \\, dx} ;\n\\]\n\n如果两个函数的正交条件（orthogonality）为其内积（inner product）为零：\n\n\\[\n\\int_{a}^{b} f(x) g(x) \\, dx = 0\n\\]\n\n两者的角的余弦为\n\n\\[\n\\cos(\\theta) = \\frac{\\langle f(x), g(x) \\rangle}{| f(x) | \\cdot | g(x) |} = \\frac{\\int f(x)g(x) \\, dx}{\\sqrt{\\int f^2(x) \\, dx} \\sqrt{\\int g^2(x) \\, dx}} ;\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#lp-空间lebesgue-space",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#lp-空间lebesgue-space",
    "title": "傅立叶级数",
    "section": "4.3 \\(L^p\\) 空间（Lebesgue Space）",
    "text": "4.3 \\(L^p\\) 空间（Lebesgue Space）\n\n定义：Suppose \\(f(x)\\) is measurable functions on \\(E\\subset R^n\\).\nFor \\(0&lt;p&lt;\\infty\\), we denote:\n\\[\n||f||_p=(\\int_E|f(x)|^pdx)^{1/p}\n\\]\n\n我们用\\(L^p(E)\\)来表示\\(||f||_p&lt;\\infty\\)的全体函数，称其为\\(L^p\\)空间。\n其范数（norm）为：\n\\[\nL_p = \\| \\varphi \\|_p = \\left( \\sum_{i=1}^{n} |\\varphi_i|^p \\right)^{\\frac{1}{p}}, \\quad x = (x_1, x_2, \\ldots, x_n)\n\\]\n\n\\(L^p\\)空间的一些基础属性：\n\n\\(L\\)空间里的每一个函数都是Lebesgue可积的\n空间维度是无穷而且不可数的度量空间（Metric Space）\nBanach空间，或者完备赋范向量空间 (complete normed vector space)\n当\\(p=2\\)，\\(L^2\\)变成了一个Hilbert空间，一个带有内积的Banach空间\n\n\nA Hilbert space is a real or complex inner product space that is also a complete metric space with respect to the distance function induced by the inner product. In every Hilbert Space, we have functions that\n\\[\n\\langle x, y \\rangle = \\sum_{k=1}^{n} \\overline{x_k} y_k\n\\]\n\n\\(L^2\\)空间的范数（norm），根据之前的公式，我们可以得知：\n\\[\n\\| \\varphi \\|_2 = \\sqrt{ \\sum_{i=1}^{n} |\\varphi_i|^2 }, \\quad x = (x_1, x_2, \\ldots, x_n)\n\\]\np.s. 以（p=2）为例，空间中到原点的欧氏距离为1的点构成了一个球面。\n![[L-space-1.png]] ## 4.4 傅里叶级数的正交函数系与规范系\n\n定义：if \\(\\int_{a}^{b} \\varphi(x) \\psi(x) \\, dx = 0\\) for interval \\([a,b]\\), then \\(\\varphi(x), \\psi(x)\\) are orthogonal.\n\n\n4.4.1 正交函数系 (orthogonal functions)\n当每对双函数\\(\\varphi_n(x), \\ \\varphi_m(x)\\) 都符合定义以下，我们称这样的函数群体为正交函数系 （orthogonal group）：\n\\[\n\\int_{a}^{b} \\varphi_n(x) \\varphi_m(x) \\, dx = 0 \\space \\space\\space\\space\\space\\space\\space\\space \\{n,m\\in \\N\\ | \\ n\\neq m \\}\n\\]\n\n\n4.4.2 规范正交函数系 (orthonormal functions)\n若函数的 \\(\\lambda_n=1\\) \\((n=1,2,3...)\\), 那么这便是规范系（orthonormal group）：\n\\[\n\\int_{a}^{b} \\varphi_n^2(x) \\, dx = \\lambda_n\n\\]\n若不是orthogonal，则我们可以通过\\(\\left\\{ \\cfrac{\\varphi_n(x)}{\\sqrt{\\lambda_n}} \\right\\}\\) 来进行换取新的orthogonal functions。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#傅里叶级数在l2-空间的基函数",
    "href": "content/notes/理论/偏微分方程/Heat Equation/The Fourier Series.html#傅里叶级数在l2-空间的基函数",
    "title": "傅立叶级数",
    "section": "4.5 傅里叶级数在\\(L^2\\) 空间的基函数",
    "text": "4.5 傅里叶级数在\\(L^2\\) 空间的基函数\nNotice back to this set of functions inside the interval \\([-\\pi,\\pi]\\):\n\\[1, \\cos(x), \\sin(x), \\cos(2x), \\sin(2x),...\\cos(nx), \\sin(nx),...\\]\nThese are orthogonal basis functions for their vector space because we see for any two functions in this set \\(\\int_{-\\pi}^{\\pi} \\cos(mx) \\cdot \\sin(nx) \\, dx = 0.\\)\nHowever, they are not standard, or normed, because \\(\\lambda_n \\neq1\\).\n我们可以通过模（norm）的定义获得他们的normalizing coefficient：\n\\[\\|1\\| = \\sqrt{\\int_{-\\pi}^{\\pi} 1^2 \\, dx} = \\sqrt{2\\pi}\\]\n\\[\\|\\cos(nx)\\| = \\sqrt{\\int_{-\\pi}^{\\pi} \\cos^2(nx) \\, dx} = \\sqrt{\\pi}\\]\n\\[\\|\\sin(nx)\\| = \\sqrt{\\int_{-\\pi}^{\\pi} \\sin^2(nx) \\, dx} = \\sqrt{\\pi}\\] Then, we would have a standard orthonormal functions: \\[\\frac{1}{\\sqrt{2\\pi}}, \\ldots, \\, \\frac{\\cos nx}{\\sqrt{\\pi}}, \\, \\frac{\\sin nx}{\\sqrt{\\pi}}, \\, \\ldots\\]\nLet’s define them:\n\\[\\psi_0=\\frac{1}{\\sqrt{2\\pi}}, \\psi_j=\\frac{1}{\\sqrt{\\pi}}\\cos(jx),  \\varphi_j=\\frac{1}{\\sqrt{\\pi}}\\sin(jx)\\]\n\\[\\psi_0\\equiv\\sqrt L\\quad \\psi_j\\equiv\\sqrt L\\cos\\left ( \\frac{j\\pi}{L}x\n\\right )\\quad \\varphi_j\\equiv\\sqrt L\\sin\\left ( \\frac{j\\pi}{L}x\n\\right) \\]\nsuch that, we obtain the coefficient for each standard basis functions needed:\n\\[\\begin{align} a_0 &= \\langle f,\\psi_0\\rangle=\\frac{1}{\\sqrt{2\\pi}} \\int_{-\\pi}^{\\pi} f(x) \\, dx\\\\a_j &=\\langle f,\\psi_k\\rangle=\\frac{1}{\\sqrt{\\pi}} \\int_{-\\pi}^{\\pi} f(x) \\cos(jx) \\, dx\\\\ b_j &=\\langle f,\\varphi_k\\rangle =\\frac{1}{\\sqrt{\\pi}} \\int_{-\\pi}^{\\pi} f(x) \\sin(kx) \\, dx \\end{align} \\]\nThen, for the function \\(\\mathcal X\\) and its coffecient \\(C_k\\) defined as\n\\[\n\\mathcal X_k=(\n\\psi_k ,\\varphi_k\n), \\quad C_k=(a_j,b_j)\n\\]\nwe have a function space:\n\\[\n\\mathcal F(f)=\\sum_{k=0}^\\infty C_k \\cdot \\mathcal X_k\n\\]\n\n如同\\(\\vec{a} = \\sum_{i=1}^{n} a_i \\vec{e}_i \\quad\\)一样，我们有\\(f(x) = a_0 \\frac{1}{\\sqrt{2\\pi}} + a_1 \\frac{\\cos x}{\\sqrt{\\pi}} + b_1 \\frac{\\sin x}{\\sqrt{\\pi}} + a_2 \\frac{\\cos 2x}{\\sqrt{\\pi}} + b_2 \\frac{\\sin 2x}{\\sqrt{\\pi}} + \\cdots\\)，或者\n$$\nf(x) = a_0 + {k=1}^{} a_k + {k=1}^{} b_k $$\n代入\\(a_0,a_k,b_k\\)到上式中，我们获得：\n\\[\nf(x) =  \\frac{1}{\\sqrt{2\\pi}} \\int_{-\\pi}^{\\pi} f(x) \\, dx  \\frac{1}{\\sqrt{2\\pi}} + \\sum_{k=1}^{\\infty} \\frac{\\cos kx}{\\sqrt{\\pi}}\\frac{1}{\\sqrt{\\pi}} \\int_{-\\pi}^{\\pi} f(x) \\cos kx \\, dx + \\sum_{k=1}^{\\infty} \\frac{\\sin kx}{\\sqrt{\\pi}} \\frac{1}{\\sqrt{\\pi}} \\int_{-\\pi}^{\\pi} f(x) \\sin kx \\, dx\n\\]\n当我们简化之后，并且将系数项更新，我们最终有了现在的傅里叶展开式：\n\\[\nf(x)=A_0 + \\sum_{n=1}^{\\infty}(A_n\\cos nx+ B_n\\sin nx)\n\\]\n\\[\n\\begin{align} A_0 &= \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} f(x) \\, dx\\\\A_n &= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\cos(nx) \\, dx\\\\ B_n &= \\frac{1}{\\pi} \\int_{-\\pi}^{\\pi} f(x) \\sin(nx) \\, dx \\end{align}\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "傅立叶级数"
    ]
  },
  {
    "objectID": "content/notes/理论/index.html",
    "href": "content/notes/理论/index.html",
    "title": "理论",
    "section": "",
    "text": "0. Probability Distributions (recap)\n\n\n\n\n\n\n\n\n\n\n0. Recap from Last lecture\n\n\n\n\n\n\n\n\n\n\n1. From Calculus to Manifolds\n\n\n\n\n\n\n\n\n\n\n1. Ok Honestly I Have No Idea Where He Started\n\n\n\n\n\n\n\n\n\n\n1. Parametrized curves in \\(\\mathbb{R}^3\\) (plane curves as a special case)\n\n\n\n\n\n\n\n\n\n\n1.1 Smooth map and its differential (push-forward)\n\n\n\n\n\n\n\n\n\n\n1.1 积分的定义\n\n\n\n\n\n\n\n\n\n\n6.4 可微分性的必要条件\n\n\n\n\n\n\n\n\n\n\n6.5 链式法则\n\n\n\n\n\n\n\n\n\n\n6.6 乘积法则与梯度\n\n\n\n\n\n\n\n\n\n\n6.9 泰勒公式的高维形式\n\n\n\n\n\n\n\n\n\n\n7.1 反函数定理\n\n\n\n\n\n\n\n\n\n\n7.1.1 反函数定理（证明）\n\n\n\n\n\n\n\n\n\n\n7.2 隐函数定理\n\n\n\n\n\n\n\n\n\n\n7.6 莫尔斯引理\n\n\n\n\n\n\n\n\n\n\n8.5 不定积分\n\n\n\n\n\n\n\n\n\n\n8.6 勒贝格收敛定理\n\n\n\n\n\n\n\n\n\n\n9.1 边值问题的近似\n\n\n\n\n\n\n\n\n\n\n9.2 有限差分法\n\n\n\n\n\n\n\n\n\n\n9.3 对流-扩散方程\n\n\n\n\n\n\n\n\n\n\n9.4 4.1 二维（2D）偏微分方程问题\n\n\n\n\n\n\n\n\n\n\nAgent\n\n\n\n\n\n\n\n\n\n\nAutoregressive Model (Continue)\n\n\n\n\n\n\n\n\n\n\nAutoregressive Models\n\n\n\n\n\n\n\n\n\n\nCriterion for Integrability\n\n\n\n\n\n\n\n\n\n\nEinstein求和约定\n\n\n\n\n\n\n\n\n\n\nFormula Derivation\n\n\n\n\n\n\n\n\n\n\nGaussian Integral Computation\n\n\n\n\n\n\n\n\n\n\nHeat Equation Solution\n\n\n\n\n\n\n\n\n\n\nMarkov奖励&决策过程\n\n\n\n\n\n\n\n\n\n\nOrder of Convergence in Finite Elements\n\n\n\n\n\n\n\n\n\n\nParametrized Curves in \\(\\mathbb{R}^3\\)\n\n\n\n\n\n\n\n\n\n\nProof of the Theorem\n\n\n\n\n\n\n\n\n\n\nReal Analysis II\n\n\n\n\n\n\n\n\n\n\nSolutions for Quiz 4\n\n\n\n\n\n\n\n\n\n\nT-n Levels of Separation Axiom\n\n\n\n\n\n\n\n\n\n\n习题\n\n\n\n\n\n\n\n\n\n\n偏微分方程\n\n\n\n\n\n\n\n\n\n\n傅立叶级数\n\n\n\n\n\n\n\n\n\n\n几何基础\n\n\n\n\n\n\n\n\n\n\n四维向量\n\n\n\n\n\n\n\n\n\n\n实分析\n\n\n\n\n\n\n\n\n\n\n常微分方程的数值解\n\n\n\n\n\n\n\n\n\n\n广义相对论\n\n\n\n\n\n\n\n\n\n\n广义相对论理论\n\n\n\n\n\n\n\n\n\n\n张量方程\n\n\n\n\n\n\n\n\n\n\n强化学习\n\n\n\n\n\n\n\n\n\n\n微分几何\n\n\n\n\n\n\n\n\n\n\n拉普拉斯方程\n\n\n\n\n\n\n\n\n\n\n指标\n\n\n\n\n\n\n\n\n\n\n数值方法\n\n\n\n\n\n\n\n\n\n\n概率机器学习\n\n\n\n\n\n\n\n\n\n\n波方程\n\n\n\n\n\n\n\n\n\n\n点集拓扑学基础\n\n\n\n\n\n\n\n\n\n\n热方程\n\n\n\n\n\n\n\n\n\n\n积分计算\n\n\n\n\n\n\n\n\n\n\n第七章 逆函数和隐函数定理\n\n\n\n\n\n\n\n\n\n\n第九章\n\n\n\n\n\n\n\n\n\n\n第九章\n\n\n\n\n\n\n\n\n\n\n第八章 度量理论\n\n\n\n\n\n\n\n\n\n\n第六章 可微映射\n\n\n\n\n\n\n\n\n\n\n第十章\n\n\n\n\n\n\n\n\n\n\n第十章\n\n\n\n\n\n\n\n\n\n\n第四章 有限元分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "理论"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "#\n\nErise Note\n\n这个网页笔记完全是我为己所用的【私人笔记】。我将其发布的目的并不是为了展示笔记，而是出于一种“网页版”费曼学习法的目的，在想象所有人都是自己是听众的情况下进行知识传授，从而来结构化我的数学和物理知识体系。当然，在这种刻意的展示（presentation）中，若是有人能有所受益，那更是再好不过了，所以我便理所当然地将他们发布出来。\n由于以上的原因，笔记里很多的一些证明并不完全严谨，可能会有错误，掺杂着不规整的私人语言，请酌情参考。\n这个项目受启发于Chaoskey 的微分几何学习笔记。\nYou always know where to go when nobody is nowhere.\n\nBuild Commands\nTo preview the site locally (auto-reloads on file changes):\ncd /Users/erisehe/Documents/GitHub/notebook\nquarto preview --port 4200\nThen open http://localhost:4200 in your browser.\nTo build the site (generates static files in docs/):\ncd /Users/erisehe/Documents/GitHub/notebook\nquarto render\nTo fix any empty title fields (run before building if needed):\ncd /Users/erisehe/Documents/GitHub/notebook\nnode scripts/fix-empty-titles.js\nNote: If you encounter build errors, first check for empty title: fields in markdown frontmatter and run the fix script above."
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/Heat Equation Solution.html",
    "href": "content/notes/理论/偏微分方程/Heat Equation/Heat Equation Solution.html",
    "title": "Heat Equation Solution",
    "section": "",
    "text": "[!Theorem] Since we know that \\(u_t=ku_{xx}\\) , then we know if \\(u \\in U\\) for \\(U \\subset \\mathbb{R}^n\\) solves the equation, so does \\(u(\\lambda x, \\lambda^2 t)\\) for \\(\\lambda \\in \\mathbb{R}\\) according to the scale invariance property.\n\nLet’s set that \\(\\bar{x}=\\lambda x, \\bar{t}=\\lambda^2 t\\), then it is easy to see:\n\\[ \\begin{align} u_{\\bar{t}}= \\frac{\\partial u}{\\partial \\bar{t}}\\cdot\\frac{\\partial \\bar{t}}{\\partial t} = \\frac{\\partial u}{\\partial t} \\cdot (\\lambda^2) \\\\ u_{\\bar{x}\\bar{x}} &=\\frac{\\partial}{\\partial x} \\cdot \\frac{\\partial u}{\\partial \\bar{x} } = (\\frac{\\partial}{\\partial \\bar{x}} \\cdot \\frac{\\partial \\bar{x}}{\\partial x})(\\frac{\\partial u}{\\partial \\bar{x} } \\cdot \\frac{\\partial \\bar{x}}{\\partial x})\\\\ &= \\frac{\\partial^2 u}{\\partial x^2} \\cdot (\\lambda^2) \\end{align} \\]\nwhere the equation still holds regardless the choice of \\(\\lambda\\) \\((\\lambda \\neq 0)\\)\n\nThe scaling \\(\\frac{x^2}{t}\\) or \\(\\frac{x}{\\sqrt{t}}\\) that is invariant to the equation suggests the solution is in the form of \\(u(x,t)=v(\\frac{x^2}{t})\\) f.s. function \\(v\\). That is,\n\\[ \\begin{align} u(x,t)=t^\\alpha v(\\frac{x}{t^\\beta}) \\end{align} \\]\nwhere constants \\(\\alpha, \\beta\\) and functions \\(v:\\mathbb{R}^n\\to \\mathbb{R}\\) must be found. This means the solution must be invariant under the dilation scaling \\(\\forall \\lambda &gt;0, x= \\mathbb{R}^n, t&gt;0\\) :\n\\[ u(x,t) = \\lambda^\\alpha u(\\lambda^\\beta x,\\lambda t) \\]\nSetting \\(\\lambda=t^{-1}\\), in which \\(v(y):= u(y,1)\\). We insert (1) into the original heat equation to solve for \\(v\\) with our new variable \\(y=\\cfrac{x}{t^\\beta}\\). We then take \\(\\beta = \\frac{1}{2}\\) so that the terms involved \\(t\\) are cancelled out - we hence derived an equation that is only in terms of \\(y\\):\n\\[ \\alpha v + \\frac{1}{2}\\cdot Dv + \\Delta v = 0 \\ \\ (k=1) \\]\nDifferent textbook takes different methods to find the constant \\(\\alpha=-\\frac{1}{2}\\) here:\n\nUsing conservation of heat energy in physics\nGuessing \\(v\\) to be radial and introduce \\(v(y)=w(|y|)\\)\n\n\nEventually, we reached at \\(v(y)=Ae^{-\\frac{y^2}{4k}}\\) such that\n\\[ u(x,t)=A\\frac{1}{ t^{n/2}}e^{-\\frac{|x|^2}{4kt}} \\]\nThe particular choice of normalizing constant \\(A=\\frac{1}{(4\\pi k)^{n/2}}\\) is derived from \\(\\int_{\\mathbb{R}^n} \\Phi(x,t) dx=1\\). (See p. 46 Lemma, Evans) Hence, the general solution to the heat equation for \\(n\\) dimension is\n\\[ \\Phi(x,t)=\\frac{1}{(4\\pi k t)^{n/2}} e^{-\\frac{|x|^2}{4kt}} \\]\nwhere \\(x\\in \\mathbb{R}^n, t&gt;0\\). For situation \\(t&lt;0\\), the solution is \\(\\Phi=0\\).\nFor dimension \\(n=1\\), we yield \\[ \\Phi(x,t)=\\frac{1}{\\sqrt{4\\pi k t}} e^{-\\frac{x^2}{4kt}} \\] \\[\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "Heat Equation Solution"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/Heat Equation Solution.html#scale-invariance-property",
    "href": "content/notes/理论/偏微分方程/Heat Equation/Heat Equation Solution.html#scale-invariance-property",
    "title": "Heat Equation Solution",
    "section": "",
    "text": "[!Theorem] Since we know that \\(u_t=ku_{xx}\\) , then we know if \\(u \\in U\\) for \\(U \\subset \\mathbb{R}^n\\) solves the equation, so does \\(u(\\lambda x, \\lambda^2 t)\\) for \\(\\lambda \\in \\mathbb{R}\\) according to the scale invariance property.\n\nLet’s set that \\(\\bar{x}=\\lambda x, \\bar{t}=\\lambda^2 t\\), then it is easy to see:\n\\[ \\begin{align} u_{\\bar{t}}= \\frac{\\partial u}{\\partial \\bar{t}}\\cdot\\frac{\\partial \\bar{t}}{\\partial t} = \\frac{\\partial u}{\\partial t} \\cdot (\\lambda^2) \\\\ u_{\\bar{x}\\bar{x}} &=\\frac{\\partial}{\\partial x} \\cdot \\frac{\\partial u}{\\partial \\bar{x} } = (\\frac{\\partial}{\\partial \\bar{x}} \\cdot \\frac{\\partial \\bar{x}}{\\partial x})(\\frac{\\partial u}{\\partial \\bar{x} } \\cdot \\frac{\\partial \\bar{x}}{\\partial x})\\\\ &= \\frac{\\partial^2 u}{\\partial x^2} \\cdot (\\lambda^2) \\end{align} \\]\nwhere the equation still holds regardless the choice of \\(\\lambda\\) \\((\\lambda \\neq 0)\\)\n\nThe scaling \\(\\frac{x^2}{t}\\) or \\(\\frac{x}{\\sqrt{t}}\\) that is invariant to the equation suggests the solution is in the form of \\(u(x,t)=v(\\frac{x^2}{t})\\) f.s. function \\(v\\). That is,\n\\[ \\begin{align} u(x,t)=t^\\alpha v(\\frac{x}{t^\\beta}) \\end{align} \\]\nwhere constants \\(\\alpha, \\beta\\) and functions \\(v:\\mathbb{R}^n\\to \\mathbb{R}\\) must be found. This means the solution must be invariant under the dilation scaling \\(\\forall \\lambda &gt;0, x= \\mathbb{R}^n, t&gt;0\\) :\n\\[ u(x,t) = \\lambda^\\alpha u(\\lambda^\\beta x,\\lambda t) \\]\nSetting \\(\\lambda=t^{-1}\\), in which \\(v(y):= u(y,1)\\). We insert (1) into the original heat equation to solve for \\(v\\) with our new variable \\(y=\\cfrac{x}{t^\\beta}\\). We then take \\(\\beta = \\frac{1}{2}\\) so that the terms involved \\(t\\) are cancelled out - we hence derived an equation that is only in terms of \\(y\\):\n\\[ \\alpha v + \\frac{1}{2}\\cdot Dv + \\Delta v = 0 \\ \\ (k=1) \\]\nDifferent textbook takes different methods to find the constant \\(\\alpha=-\\frac{1}{2}\\) here:\n\nUsing conservation of heat energy in physics\nGuessing \\(v\\) to be radial and introduce \\(v(y)=w(|y|)\\)\n\n\nEventually, we reached at \\(v(y)=Ae^{-\\frac{y^2}{4k}}\\) such that\n\\[ u(x,t)=A\\frac{1}{ t^{n/2}}e^{-\\frac{|x|^2}{4kt}} \\]\nThe particular choice of normalizing constant \\(A=\\frac{1}{(4\\pi k)^{n/2}}\\) is derived from \\(\\int_{\\mathbb{R}^n} \\Phi(x,t) dx=1\\). (See p. 46 Lemma, Evans) Hence, the general solution to the heat equation for \\(n\\) dimension is\n\\[ \\Phi(x,t)=\\frac{1}{(4\\pi k t)^{n/2}} e^{-\\frac{|x|^2}{4kt}} \\]\nwhere \\(x\\in \\mathbb{R}^n, t&gt;0\\). For situation \\(t&lt;0\\), the solution is \\(\\Phi=0\\).\nFor dimension \\(n=1\\), we yield \\[ \\Phi(x,t)=\\frac{1}{\\sqrt{4\\pi k t}} e^{-\\frac{x^2}{4kt}} \\] \\[\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程",
      "Heat Equation Solution"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/Heat Equation/index.html",
    "href": "content/notes/理论/偏微分方程/Heat Equation/index.html",
    "title": "热方程",
    "section": "",
    "text": "The general form of heat equation (diffusion equation) is represented as\n\\[\nu_t-k\\Delta u=0\n\\]\nwhere \\(x\\in U\\) for \\(U \\in \\R^n\\) (n-dimentional) s.t we have \\(u:\\bar{U} \\times [0,\\infty) \\to \\R\\).\n\n\\(k\\) is the thermal diffusivity of the material.\nprototype of parabolic PDEs\nnormalized heat equation where \\(k=1\\) is specified for theoretical studies (focusing on mathematical analysis)\n\nFor 1-dimentional special case:\n\\[\nu_t-ku_{xx}=0\n\\]\nwhere \\(\\{x,t\\in(-\\infty,\\infty), [0, \\infty)\\}\\).\n\n\nLecture 10\n\n下面的排序是按照推导热方程解析解的顺序来的。\n\n基本思路：\n我们先通过标度不变性（scale invariance）找到一个所有解通用的形式，并且嵌入原方程进行运算。\n最终，我们得到一维的：\n\n10.1 热传导方程的基本解\nThe Fundamental Solution to Heat Equation\n\\[\n\\Phi(x,t)=\\frac{1}{\\sqrt{4\\pi k t}} e^{-\\frac{x^2}{4kt}}\n\\]\n\n\n10.1.1 正态分布函数的属性\n以及与它作为一个正态分布函数的属性：\nProperties of The Fundamental Solution\n\n\n10.2 对于柯西问题的解\n接着，我们再用过平移不变性 （translation invariance）和卷积来进一步确定柯西问题（\\(t=0\\)）的解。\nThe Solution to Cauchy Problem\n\\[\nu(x,t) = \\frac{1}{(4\\pi k t)^{1/2}} \\int^{+\\infty}_{-\\infty} e^{-\\frac{(x-y)^2}{4kt}} g(y) \\, dy\n\\]\n并且可以用误差函数来表示这个解\n\\[\nu(x, t) = \\lim_{x \\to \\infty} \\text{erf}(x\\sqrt{4\\pi kt})\n\\]\n\n\n\n\nLecture 11\n\n11.1 三种不同的边界条件\nDifferent Types of Boundary Conditions\n\n\n11.2 分离变量法\nSeparation of Variables\n\n\n\nLecture 12\n\n12.1 傅里叶展开和变换\nThe Fourier Series\n\n\n\nLecture 13\n\n13.1 热传导公式解\nThe Fourier Expansion for Heat Equation Solution\n\n\n13.2 Dirichlet问题的解\nNon-Homogenous Dirichlet problem\n\n\n\nLecture 14\n\n14.1 解的唯一性\nUniqueness of Solution\n\n\n14.2 电梯方程\nLifting Function\n\n💡 the transformed coefficient is defined as\n\\[\n\\hat \\mu =\\dfrac{\\mu}{(b-a)^2}\n\\]\n\n\n\n\nLecture 15\n\n15.1 施图姆-刘维尔理论\nSturm Liouville Theory (SLE)\n\n\n\nLecture 16\n\n16.1 极大值原理\nThe Principle of Maximum\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHeat Equation Solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n傅立叶级数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "热方程"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "",
    "text": "The derivative approximation:\n\n\\[\n\\begin{aligned}\nf(t_i, u_i) &= \\frac{dy}{dt} \\Big|_{t_i} \\approx \\frac{y(t_{i+1}) - y(t_{i-1})}{2\\Delta t} + \\mathcal{O}(\\Delta t^2)\n\\end{aligned}\n\\]\nUpdate formula:\n\\[\n\\begin{aligned}\nu_{i+1} &= u_{i-1} + 2\\Delta t f(t_i, u_i)\n\\end{aligned}\n\\]\n\n\n\n\nInitial Condition Calculation: Given \\(y_0\\) \\[\n\\begin{aligned}\nu_2 &= y_0 + 2\\Delta t f(t_1, u_1)\n\\end{aligned}\n\\]\nPredictor-Corrector Steps:\n\\[\n\\begin{aligned}\nu_1^* &= y_0 + \\Delta t f(t_0, y_0), \\\\\nu_1 &= y_0 + \\frac{\\Delta t}{2} (f(t_0, y_0) + f(t_1, u_1^*))\n\\end{aligned}\n\\]\n\n\n\n\n\n\nHigher-order method that improves accuracy using information from two previous time steps.\nThe method achieves second-order accuracy due to the central difference approximation. *** # Absolute Stability\n\nWe consider the test equation:\n\\[\n\\begin{aligned}\n\\frac{dy}{dt} &= -\\lambda y, \\quad y(0) = y_0\n\\end{aligned}\n\\]\nwhere \\(\\lambda &gt; 0\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#formula-derivation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#formula-derivation",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "",
    "text": "The derivative approximation:\n\n\\[\n\\begin{aligned}\nf(t_i, u_i) &= \\frac{dy}{dt} \\Big|_{t_i} \\approx \\frac{y(t_{i+1}) - y(t_{i-1})}{2\\Delta t} + \\mathcal{O}(\\Delta t^2)\n\\end{aligned}\n\\]\nUpdate formula:\n\\[\n\\begin{aligned}\nu_{i+1} &= u_{i-1} + 2\\Delta t f(t_i, u_i)\n\\end{aligned}\n\\]\n\n\n\n\nInitial Condition Calculation: Given \\(y_0\\) \\[\n\\begin{aligned}\nu_2 &= y_0 + 2\\Delta t f(t_1, u_1)\n\\end{aligned}\n\\]\nPredictor-Corrector Steps:\n\\[\n\\begin{aligned}\nu_1^* &= y_0 + \\Delta t f(t_0, y_0), \\\\\nu_1 &= y_0 + \\frac{\\Delta t}{2} (f(t_0, y_0) + f(t_1, u_1^*))\n\\end{aligned}\n\\]\n\n\n\n\n\n\nHigher-order method that improves accuracy using information from two previous time steps.\nThe method achieves second-order accuracy due to the central difference approximation. *** # Absolute Stability\n\nWe consider the test equation:\n\\[\n\\begin{aligned}\n\\frac{dy}{dt} &= -\\lambda y, \\quad y(0) = y_0\n\\end{aligned}\n\\]\nwhere \\(\\lambda &gt; 0\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#discretization",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#discretization",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "Discretization",
    "text": "Discretization\nThe numerical update formula is:\n\\[\n\\begin{aligned}\nu_{n+1} &= u_{n-1} - 2\\Delta t \\lambda u_n\n\\end{aligned}\n\\]\nRearranging:\n\\[\n\\begin{aligned}\nu_{n+1} + 2\\Delta t \\lambda u_n - u_{n-1} &= 0\n\\end{aligned}\n\\]\n\nIterative Computation\nStarting with initial conditions (\\(y_0\\), \\(y_1\\)):\n\\[\n\\begin{aligned}\n   u_2 &= y_0 - 2\\Delta t \\lambda y_1, \\\\\n   u_3 &= y_1 - 2\\Delta t \\lambda u_2, \\\\\n   u_4 &= u_2 - 2\\Delta t \\lambda u_3, \\\\\n   u_5 &= u_3 - 2\\Delta t \\lambda u_4\n\\end{aligned}\n\\]\nThis formulation helps analyze the stability of the numerical scheme by checking whether the sequence \\(u_n\\) grows or decays as \\(n \\to \\infty\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#stability-analysis-of-the-numerical-scheme",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#stability-analysis-of-the-numerical-scheme",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "Stability Analysis of the Numerical Scheme",
    "text": "Stability Analysis of the Numerical Scheme\nWe assume a solution of the form:\n\\[\n\\begin{aligned}\nu_i &= C \\beta^i\n\\end{aligned}\n\\]\n\nSubstituting into the Recurrence Relation\n$$\n\\[\\begin{aligned}\n\n\\end{aligned}\\]\n\\[\n\\]\n\\[\\begin{aligned}\nC \\beta^{i+1} + C 2\\Delta t \\lambda \\beta^i - C \\beta^{i-1} &= 0\\\\\n\\beta^2 + 2\\Delta t \\lambda \\beta - 1 &= 0 \\quad \\text{devided by $C \\beta^{i-1}$.}\n\\end{aligned}\\]\n$$ This is a characteristic equation for the recurrence relation. And solving for \\(\\beta\\),\n\\[\n\\begin{aligned}\n\\beta &= \\frac{-2\\Delta t \\lambda \\pm \\sqrt{(2\\Delta t \\lambda)^2 + 4}}{2}\n\\end{aligned}\n\\] To ensure stability, we require:\n\\[\n\\begin{aligned}\n|\\beta_0|, |\\beta_1| &\\leq 1.\n\\end{aligned}\n\\]\n\n\n\nGeneral Solution\nSince the recurrence relation is second-order, the general solution is: \\[\n\\begin{aligned}\nu_i &= C_0 \\beta_0^i + C_1 \\beta_1^i.\n\\end{aligned}\n\\] From the initial conditions:\n$$\n\\[\\begin{aligned}\nu_0 &= C_0 + C_1 = y_0, \\\\\n\n\n\n\n   \\nu_1 &= C_0 \\beta_0 + C_1 \\beta_1 = y_1\n\\end{aligned}\\]\n$$ which can be solved for \\(C_0\\) and \\(C_1\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#stability-condition",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#stability-condition",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "Stability Condition",
    "text": "Stability Condition\nFor stability, the roots \\(\\beta_0, \\beta_1\\) must satisfy:\n\\[\n\\begin{aligned}|\\beta_0 \\beta_1| &= 1.\\end{aligned}\n\\]\nFrom the characteristic equation:\n\\[\n\\begin{aligned}\\beta_0 \\beta_1 &= -\\frac{1}{\\beta_1}.\n\\end{aligned}\n\\]\nEnsuring \\(|\\beta| \\leq 1\\) determines the absolute stability region.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#finite-difference-approximation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#finite-difference-approximation",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "Finite Difference Approximation",
    "text": "Finite Difference Approximation\n\\[\n\\begin{aligned}\n\\alpha u_{i+1} + \\beta u_i + \\sigma u_{i-1} + \\delta u_{i-2} &= (\\alpha + \\beta + \\sigma + \\delta) u_i + \\mathcal{O}(\\Delta t^5)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#time-discretization",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#time-discretization",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "Time Discretization",
    "text": "Time Discretization\n\\[\n\\begin{aligned}\n\\frac{du}{dt} \\Big|_{t_i} &= \\frac{u_i - u_{i-1}}{\\Delta t} + \\mathcal{O}(\\Delta t^2)\n\\end{aligned}\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#stability-analysis",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/01 Mid-Point Method.html#stability-analysis",
    "title": "Finite Difference Approximation and Stability Analysis",
    "section": "Stability Analysis",
    "text": "Stability Analysis\n\\[\n\\begin{aligned}\n\\alpha + 4\\beta &= 0, \\\\\n\\alpha &= -4\\beta, \\\\\n4\\beta - 2\\beta &= 1 \\Rightarrow \\beta = \\frac{1}{2}, \\quad \\alpha = -2.\n\\end{aligned}\n\\]\nThese constraints ensure numerical stability and proper convergence of the finite difference scheme. ### Taylor Expansions Applying Taylor expansions to express the function values at different time steps: \\[\n\\begin{aligned}\n& \\alpha\\left[u_{i+1}=u_i-\\left.\\frac{d u}{d t}\\right|_{t_i} \\Delta t+\\ldots\\right] \\\\\n& \\beta\\left[u_{i+2}=u_i-\\left.\\frac{d u}{d t}\\right|_{t_i} 2 \\Delta t+\\ldots\\right] \\\\\n& \\gamma\\left[u_{i+3}=u_i-\\left.\\frac{d u}{d t}\\right|_{t_i} 3 \\Delta t+\\ldots\\right] \\\\\n& \\delta\\left[u_{i+4}=u_i-\\left.\\frac{d u}{d t}\\right|_{t_i} 4 \\Delta t+\\ldots\\right]\n\\end{aligned}\n\\] Summing these expansions, we obtain the system of equations,\n\\[\n\\left\\{\\begin{aligned}\n-\\alpha-2 \\beta-3 \\gamma-4 \\delta & =1 \\\\\n\\alpha+4 \\beta+8 \\gamma+16 \\delta & =0\n\\end{aligned}\\right.\n\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "Formula Derivation"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html",
    "title": "常微分方程的数值解",
    "section": "",
    "text": "The subject of this Chapter is the numerical approximation of the Cauchy problem:\n\\[(1) \\quad \\frac{dy}{dt} = f(t,y) \\quad \\text{in } t &gt; 0 \\quad (I.C.)\\]\nwith \\[y(0) = y_0 \\text{ given}.\\]\nor, more in general, a system:\n\\[(2) \\quad \\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t,\\mathbf{y}) \\quad \\text{in } t &gt; 0\\]\nwith \\[\\mathbf{y}(0) = \\mathbf{y}_0.\\]\nLet’s recall some basic results on the function \\(f\\). It is said to be Lipschitz continuous in an interval \\(I\\) if there exists a positive \\(L &gt; 0\\) s.t.\n\\[|f(t,y_1) - f(t,y_2)| &lt; L |y_1 - y_2|.\\]\nClearly, if \\(f\\) is differentiable with continuity in \\(I\\), it is also Lipschitz continuous with \\(L \\leq \\max_I \\left|\\frac{\\partial f}{\\partial y}\\right|\\).\n\n\nIf \\(f\\) is Lipschitz continuous in a range \\(t \\in I_1\\) and \\(y \\in I \\subseteq \\mathbb{R}\\), then \\(\\exists\\) an interval \\(\\hat{I} \\subseteq I\\) where the solution to \\((1)\\) exists and is unique.\n\n\n\nIf the \\(f\\) is Lipschitz continuous \\(\\forall t \\in I\\) and \\(y \\in \\mathbb{R}\\), then the solution \\(\\exists\\) uniquely in \\(I\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#introduction",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#introduction",
    "title": "常微分方程的数值解",
    "section": "",
    "text": "The subject of this Chapter is the numerical approximation of the Cauchy problem:\n\\[(1) \\quad \\frac{dy}{dt} = f(t,y) \\quad \\text{in } t &gt; 0 \\quad (I.C.)\\]\nwith \\[y(0) = y_0 \\text{ given}.\\]\nor, more in general, a system:\n\\[(2) \\quad \\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(t,\\mathbf{y}) \\quad \\text{in } t &gt; 0\\]\nwith \\[\\mathbf{y}(0) = \\mathbf{y}_0.\\]\nLet’s recall some basic results on the function \\(f\\). It is said to be Lipschitz continuous in an interval \\(I\\) if there exists a positive \\(L &gt; 0\\) s.t.\n\\[|f(t,y_1) - f(t,y_2)| &lt; L |y_1 - y_2|.\\]\nClearly, if \\(f\\) is differentiable with continuity in \\(I\\), it is also Lipschitz continuous with \\(L \\leq \\max_I \\left|\\frac{\\partial f}{\\partial y}\\right|\\).\n\n\nIf \\(f\\) is Lipschitz continuous in a range \\(t \\in I_1\\) and \\(y \\in I \\subseteq \\mathbb{R}\\), then \\(\\exists\\) an interval \\(\\hat{I} \\subseteq I\\) where the solution to \\((1)\\) exists and is unique.\n\n\n\nIf the \\(f\\) is Lipschitz continuous \\(\\forall t \\in I\\) and \\(y \\in \\mathbb{R}\\), then the solution \\(\\exists\\) uniquely in \\(I\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#stability-definitions",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#stability-definitions",
    "title": "常微分方程的数值解",
    "section": "Stability Definitions",
    "text": "Stability Definitions\nFrom the practical point of view, it is important to consider also the perturbed case:\n\\[(1_\\epsilon): \\quad \\frac{dy_\\epsilon}{dt} = f(t, y_\\epsilon) + \\delta(t) \\quad t \\geq 0\\]\n\\[y^\\epsilon(0) = y_0 + \\epsilon\\]\nwith \\(|\\delta(t)| \\leq \\epsilon \\quad \\forall t \\geq 0\\)\nIf there exists a finite constant \\(C\\) such that\n\\[|y - y_\\epsilon| &lt; C\\epsilon \\quad (*)\\]\nthen we say that the solution is Lyapunov stable.\nIn general, \\(C\\) may depend on \\(t\\), so that \\((*)\\) may hold on finite intervals (and not over the entire \\([0,\\infty)\\) axis).\nTo have a stronger concept, we advocate the ASYMPTOTIC STABILITY:\n\\[\\lim_{t \\to \\infty} |y(t) - y_\\epsilon(t)| = 0.\\]\nFrom the engineering point of view, this is a central concept, as the theory of control (Automatical Control, Feedback control) relies on this definition.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#remark",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#remark",
    "title": "常微分方程的数值解",
    "section": "Remark",
    "text": "Remark\nThe Cauchy problem has a formal (quite useless) solution:\n\\[y(t) = y_0 + \\int_0^t f(\\tau, y(\\tau))d\\tau\\]\nconnecting the solution in \\(t\\) with its past.\nThis is basically an alternative formulation of the problem and, in fact, will be used to formulate possible numerical approximation alternative to the ones based on \\((1)\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#some-simple-examples",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#some-simple-examples",
    "title": "常微分方程的数值解",
    "section": "Some Simple Examples",
    "text": "Some Simple Examples\nTo begin with, we can split the time interval in subintervals, for instance with a uniform reticulation with step \\(\\Delta t\\).\n![Time discretization with points at 0, Δt, 2Δt, 3Δt…]\nThen, we can use the formula:\n\\[\\frac{dy}{dt}(t_i) \\simeq \\frac{y(t_{i+1}) - y(t_i)}{\\Delta t}\\]\nthat we know is accurate with an error scaling with \\(\\Delta t\\). In this way, we have:\n[From now on, the approximation of the solution \\(y(t)\\) in \\(t_i\\) will be denoted with \\(u_i\\)]\n\\[\\frac{u_{i+1} - u_i}{\\Delta t} = f(t_i, u_i)\\]\nIn practice, starting at \\(t = 0\\): \\[\\begin{align}\nu_1 &= u_0 + \\Delta t \\, f(t_0, u_0) \\quad \\rightsquigarrow \\quad (u_0 = y_0) \\\\\nu_2 &= u_1 + \\Delta t \\, f(t_1, u_1)\n\\end{align}\\]\nWe can easily compute the approximation \\(u_i\\) of \\(y(t_i)\\).\nOn the other hand, we could do:\n\\[\\frac{u_i - u_{i-1}}{\\Delta t} = f(t_i, u_i)\\]\nleading to:\n\\[u_1 = u_0 + \\Delta t \\, f(t_1, u_1) \\quad (u_0 = y_0)\\]\nThis is not as easy as before: it’s a NONLINEAR (ALGEBRAIC) EQUATION; we know how to solve it (first Chapter), but it is a computational additional cost. Then, similarly, we have:\n\\[u_2 = u_1 + \\Delta t \\, f(t_2, u_2)\\]\nWe have also another option:\n\\[\\frac{dy}{dt}(t_i) \\simeq \\frac{u_{i+1} - u_{i-1}}{2\\Delta t}\\]\nIn this case, the error scales with \\(O(\\Delta t^2)\\). So, in practice we have:\n\\[u_{i+1} = 2\\Delta t \\, f(t_i, u_i) + u_{i-1}\\]\nor specifically: \\(u_2 = 2\\Delta t \\, f(t_1, u_1) + u_0 \\quad (u_0 = y_0)\\)\nI need to know \\(u_1\\), not just \\(u_0\\), then we can use the method.\nWith these three examples, we have already found many possible types of methods:\nImplicit vs Explicit - Implicit: Solve a non-linear equation - Explicit: No need of solving equations\nOne Step vs Multistep - One Step: \\(u_{i+1} = g(\\Delta t, u_i)\\) - Multistep: \\(u_{i+1} = g(\\Delta t, u_i, u_{i-1}, u_{i-2}...)\\)\nAt the top of this, we have the problem of the accuracy and - even most importantly- of the CONVERGENCE.\nIn fact, the basic requirement we need is that the method is convergent:\n\\[\\lim_{\\Delta t \\to 0} |y(t_i) - u_i| = 0\\]\nThen, if we find that \\(|y(t_i) - u_i| \\sim O(\\Delta t^p)\\) then the accuracy or the order of the method is \\(p\\).\nNature (implicit/explicit), Number of steps and most important CONVERGENCE and accuracy (order) are the categories for analyzing and ranking different methods.\nBefore we embark ourselves in a general analysis, however, let’s focus on a specific case, where important concepts will be highlighted.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#analysis-of-forward-euler",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#analysis-of-forward-euler",
    "title": "常微分方程的数值解",
    "section": "Analysis of Forward Euler",
    "text": "Analysis of Forward Euler\nThe method:\n\\[\\frac{u_{i+1} - u_i}{\\Delta t} = f(t_i, u_i)\\]\nis called Forward Euler.\nLet’s consider it in detail.\nTo start with, let’s introduce the distinction of “consistency” and truncation error.\nIf we have the exact solution \\(y_{ex}(t)\\) it is easily realized that\n\\[\\frac{y_{ex}(t_{i+1}) - y_{ex}(t_i)}{\\Delta t} \\neq f(t_i, y_{ex}(t_i))\\]\nFor instance,\n\\[\\frac{dy}{dt} = \\lambda y \\quad y(0) = 1 \\implies y_{ex} = e^{\\lambda t}\\]\nthen\n\\[\\frac{e^{\\lambda(t_i+\\Delta t)} - e^{\\lambda t_i}}{\\Delta t} = e^{\\lambda t_i} \\frac{e^{\\lambda \\Delta t} - 1}{\\Delta t} \\neq \\lambda e^{\\lambda t_i} \\quad (\\lambda y(t_i))\\]\nWe can be more specific:\n\\[y_{ex}(t_{i+1}) = y_{ex}(t_i) + \\frac{dy_{ex}}{dt}(t_i)\\Delta t + \\frac{1}{2}\\frac{d^2y_{ex}}{dt^2}(t_i)\\Delta t^2 + ...\\]\nNow:\n\\[\\frac{y_{ex}(t_{i+1}) - y_{ex}(t_i)}{\\Delta t} = \\frac{dy_{ex}(t_i)}{dt} + \\frac{1}{2}\\frac{d^2y_{ex}(t_i)}{dt^2}\\Delta t + ...\\]\nThis gives us:\n\\[\\frac{y_{ex}(t_{i+1}) - y_{ex}(t_i)}{\\Delta t} = f(t_i, y_{ex}(t_i)) + \\left[\\frac{\\Delta t}{2}\\frac{d^2y_{ex}}{dt^2}\\right]\\]\nForward Euler \\(\\quad \\quad \\quad\\) Local Truncation Error (LTE)\nIn some sense, the truncation error is the residual we get when we pretend the exact solution to solve the numerical scheme.\nNow, to investigate how the error of Forward Euler works, let’s consider the following picture:\n![Error propagation diagram showing exact solution trajectory and numerical approximation]\nFrom the picture it is evident that the error:\n\\[e_{i+1} = y_{ex}(t_{i+1}) - u_{i+1}\\]\nis the result of two contributions:\n\\[e_{i+1} = \\underbrace{y_{ex}(t_{i+1}) - u^*_{i+1}}_{\\text{generated at the local step}} + \\underbrace{u^*_{i+1} - u_{i+1}}_{\\text{propagated from previous steps}}\\]\nFrom the previous definition:\n\\[y_{ex}(t_{i+1}) = y_{ex}(t_i) + \\Delta t \\, f(t_i, y_{ex}(t_i)) + \\Delta t \\, \\tau_{i+1}\\]\nwhere \\(\\tau_{i+1} = \\frac{\\Delta t}{2}\\frac{d^2y_{ex}(t_i)}{dt^2}\\) is the local TE.\n\\[u^*_{i+1} = y_{ex}(t_i) + \\Delta t \\, f(t_i, y_{ex}(t_i))\\]\n\\[y_{ex}(t_{i+1}) - u^*_{i+1} = \\Delta t \\, \\tau_i\\]\nNow, let’s focus on the other part.\nThis second component \\(u^*_{i+1} - u_{i+1}\\) is inherited from the previous errors.\n\\[u^*_{i+1} = y_{ex}(t_i) + \\Delta t \\, f(t_i, y_{ex}(t_i))\\] \\[u_{i+1} = u_i + \\Delta t \\, f(t_i, u_i)\\]\nUsing the Lipschitz assumption \\(|f(t,y) - f(t,u)| \\leq L |y-u|\\) we have:\n\\[|u^*_{i+1} - u_{i+1}| \\leq |e_i| + \\Delta t \\, L |e_i| = (1 + \\Delta t \\, L)|e_i|\\]\nwhere \\(e_i = y_{ex}(t_i) - u_i\\)\nAll together, we have:\n\\[|e_{i+1}| \\leq \\Delta t |\\tau_i| + (1 + \\Delta t \\, L)|e_i|\\]\nNow, take \\(|\\tau^*| = \\max_i |\\tau_i| = \\text{GLOBAL TRUNCATION ERROR}\\).\nThen:\n\\[|e_{i+1}| \\leq \\underbrace{\\Delta t |\\tau^*|}_{\\text{local}} + \\underbrace{(1 + \\Delta t \\, L)}_{\\text{propagated}}|e_i|\\]\nAssume that \\(e_0 = 0\\) (no errors on the initial conditions). Then we have:\n\\[|e_1| \\leq \\Delta t |\\tau^*|\\] \\[|e_2| \\leq \\Delta t |\\tau^*| + (1 + \\Delta t \\, L)|e_1| \\leq \\Delta t |\\tau^*|(1 + (1+\\Delta t \\, L))\\] \\[|e_3| \\leq \\Delta t |\\tau^*| + (1+\\Delta t \\, L)|e_2| \\leq \\Delta t |\\tau^*|(1 + (1+\\Delta t \\, L) + (1+\\Delta t \\, L)^2)\\]\nWe infer:\n\\[|e_K| \\leq \\Delta t |\\tau^*| \\sum_{j=0}^{K-1}(1+\\Delta t \\, L)^j = \\Delta t |\\tau^*|\\frac{(1+\\Delta t \\, L)^K - 1}{1 - 1 - \\Delta t \\, L} = \\frac{|\\tau^*|}{L}((1+\\Delta t \\, L)^K - 1)\\]\nNotice that:\n\\[(1 + x)^K \\leq \\exp(xK)\\]\nSo:\n\\[|e_K| \\leq \\frac{|\\tau^*|}{L}(\\exp(LKh) - 1) = \\frac{|\\tau^*|}{L}(\\exp(Lt_K) - 1)\\]\nwhere \\(K\\Delta t = t_K\\)\nNow, if we want to have a bound on the error in the interval \\([0,T]\\), we have:\n\\[|e| \\leq \\frac{|\\tau^*|}{L}(\\exp(LT) - 1)\\]\nWe have proved the following Theorem:",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#convergence-of-forward-euler",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#convergence-of-forward-euler",
    "title": "常微分方程的数值解",
    "section": "Convergence of Forward Euler",
    "text": "Convergence of Forward Euler\nIf the initial data are exact, and \\(f\\) is Lipschitz continuous with respect to the \\(y\\)-argument, with a solution \\(\\in C^2(0,T)\\), then FE converges.\nIn fact:\n\\[|\\tau^*| = \\frac{1}{2}\\Delta t \\max_i |y^{''}| \\xrightarrow{\\Delta t \\to 0} 0\\]\nand \\(|e| \\leq |\\tau^*|\\frac{\\exp(LT) - 1}{L} \\xrightarrow{\\Delta t \\to 0} 0\\) is bounded.\nFE is convergent with order 1.\nBeyond the Theorem per se (we will generalize it to other methods), it is important to notice that the convergence is the consequences of two peculiarities:\n(1) \\(\\tau^* \\xrightarrow{\\Delta t \\to 0} 0\\) the LTE/GTE vanishes as \\(\\Delta t \\to 0\\), so locally the error is under control.\nThis property is called CONSISTENCY.\n(2) The factor \\(\\frac{\\exp(LT) - 1}{L}\\) is independent of \\(\\Delta t\\) (or, in general, doesn’t blow up for \\(\\Delta t \\to 0\\)). This is related to the way the error propagates so it is a “global” property through the constant \\(L\\).\nThe control of the error in time is called STABILITY.\nIn some sense, we can say that:\nCONVERGENCE = CONSISTENCY + STABILITY\nIn spite of the intuitive arguments we used here, we will see that this is a good representation of general results (Lax-Richtmyer equivalence Theorem) holding for method using linear combinations of the function \\(f\\) evaluated in the points \\((t_i, u_i)\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#crank-nicolson",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#crank-nicolson",
    "title": "常微分方程的数值解",
    "section": "Crank-Nicolson",
    "text": "Crank-Nicolson\nFrom \\(y(t) = y_0 + \\int_0^t f(\\tau, y(\\tau))d\\tau\\) we can organize the following method:\n![Timeline showing points \\(t_0, t_1, t_2, t_3, t_4, t_5, t_6, t_7\\)]\nLocalize: \\(y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(\\tau, y(\\tau)) d\\tau\\)\nDiscretize: approximate the integral with the trapezoidal rule:\n\\[u_{n+1} = u_n + \\frac{f(t_{n+1}, u_{n+1}) + f(t_n, u_n)}{2} \\Delta t\\]\nThis is a Second Order (EXERCISE) one-step implicit method.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#heun",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#heun",
    "title": "常微分方程的数值解",
    "section": "Heun",
    "text": "Heun\nLet’s start from Crank-Nicolson and make it “explicit”.\nOn the right hand side of CN we set:\n\\[u_{n+1} \\simeq u_n + \\Delta t \\, f(t_n, u_n) \\quad \\text{(Explicit Euler)}\\]\nWe obtain the scheme:\n\\[u_{n+1} = u_n + \\Delta t \\frac{f(t_{n+1}, u_n+\\Delta t f(t_n, u_n)) + f(t_n, u_n)}{2}\\]\nThis is called Heun. It is One-step, still 2nd order (EXERCISE).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#the-concept-of-zero-stability",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#the-concept-of-zero-stability",
    "title": "常微分方程的数值解",
    "section": "The Concept of Zero-Stability",
    "text": "The Concept of Zero-Stability\nLet’s start applying the concept to one-step methods in the form:\n\\[u_{n+1} = u_n + \\Delta t \\, \\Phi(u_n, t_n, f_n; \\Delta t)\\]\nLet’s consider the perturbed scheme:\n\\[\\begin{cases}\nw_{n+1} = w_n + \\Delta t (\\Phi(z_n, t_n, f(t_n, z_n); \\Delta t) + \\delta_n) \\\\\nw_0 = y_0 + \\delta_0 & \\text{with } |\\delta_i| \\leq \\varepsilon\n\\end{cases}\\]\nWe say that the method is zero-stable if for \\(\\Delta t &lt; \\Delta t_0\\), there exists a constant \\(C &gt; 0\\) such that\n\\[|u_n - z_n| \\leq C\\varepsilon\\]\nfor \\(\\varepsilon &gt; 0\\) sufficiently small. (\\(C\\) and \\(\\Delta t_0\\) depend on problem data, \\(T_{fin}\\), \\(f\\)).\nIt is possible to prove the following theorem:\nTheorem: If \\(\\Phi\\) is Lipschitz continuous with respect to the dependence on \\(u_n\\) (\\(\\exists \\Delta &gt; 0\\): \\(|\\Phi(u_n) - \\Phi(z_n)| \\leq \\Delta |u_n - z_n|\\)), then the One-step method is zero-stable.\nLipschitz continuity in this case is enough for zero-stability (and it is generally a consequence of Lipschitz continuity of \\(f\\)).\nThen, we have another theorem. It generalizes the theorem for the explicit Euler.\nTheorem: If \\(\\Phi\\) is like in the previous theorem, then:\n\\[|y(t_n) - u_n| \\leq \\left(|y_0 - u_0| + t_n \\, \\tau(\\Delta t)\\right) e^{L t_n}.\\]\nTherefore, if: - \\(\\tau(\\Delta t) \\to 0\\) with \\(\\Delta t\\) - \\(y_0 - u_0 \\to 0\\) with \\(\\Delta t\\)\nthe method is convergent\n(and the order is \\(\\Delta t^p\\), with \\(p = \\min(p_1, p_2)\\) where: - \\(\\tau(\\Delta t) \\sim O(\\Delta t^{p_1})\\) - \\(y_0 - u_0 \\sim O(\\Delta t^{p_2})\\) (generally \\(p = p_1\\)).\nIn other terms:\nFor one-step method (not true for multi-step):\n\\[\\Phi \\text{ Lipschitz continuous } \\Rightarrow \\text{ Method zero-stable} + \\text{Consistency} \\Rightarrow \\text{CONVERGENCE}\\]\n\\(\\Rightarrow\\) If \\(\\Phi\\) is Lipschitz continuous, consistency \\(\\Rightarrow\\) convergence.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#the-concept-of-absolute-stability",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#the-concept-of-absolute-stability",
    "title": "常微分方程的数值解",
    "section": "The Concept of Absolute Stability",
    "text": "The Concept of Absolute Stability\nThe zero-stability is a property of the numerical scheme, required by the presence of roundoff errors and other possible perturbations.\nHowever, there is another (maybe more engineering) concept of stability related to the nature of the problem to solve.\nIn simple words, we want that, if a problem is asymptotically stable, the numerical approximation is asymptotically stable too.\nIs this happening? Let’s consider the prototype of asymptotically stable problem (Model Problem).\nLet’s consider the Cauchy problem:\n\\[\\begin{cases}\n\\frac{dy}{dt} = \\lambda y & t &gt; 0 \\\\\ny(0) = y_0\n\\end{cases}\\]\nWe know that the solution is asymptotically stable for \\(\\lambda &lt; 0\\) \\((y_{ex} = y_0 e^{\\lambda t} \\xrightarrow{t \\to \\infty} 0 \\text{ for } \\lambda &lt; 0)\\)\nIn fact: \\(\\frac{dz}{dt} = \\lambda z\\) with \\(z(0) = y_0 + \\varepsilon \\Rightarrow z - y = \\varepsilon e^{\\lambda t} \\xrightarrow{t\\to\\infty} 0\\) for \\(\\lambda &lt; 0\\).\n\nRemark\nFor a system: \\(\\begin{cases} \\frac{d\\mathbf{y}}{dt} = A\\mathbf{y} & \\mathbf{y} \\in \\mathbb{R}^n \\\\ \\mathbf{y}(0) = \\mathbf{y}_0 & A \\in \\mathbb{R}^{n \\times n} \\end{cases}\\)\nthe asymptotic stability is guaranteed if THE REAL PART OF ALL THE EIGENVALUES is negative.\nTo be general, from now on we will consider \\(\\lambda \\in \\mathbb{C}\\) also for the scalar case. In particular, the left-plane \\(\\text{Real}(\\lambda) &lt; 0\\) is the region of the complex plane where the original problem is asymptotically stable.\n\nQuestion: is the solution of the model problem with Explicit Euler asymptotically vanishing as the exact solution?\nNotice that the question is not related to the behavior of the solution for \\(\\Delta t \\to 0\\), but for \\(\\Delta t\\) given and \\(t \\to +\\infty\\).\nLet’s see: \\[\\frac{dy}{dt} = \\lambda y \\quad \\text{EE}: \\frac{u_{i+1} - u_i}{\\Delta t} = \\lambda u_i\\]\n\\[u_{i+1} = (1 + \\lambda \\Delta t) u_i \\quad (\\text{Re}(\\lambda) &lt; 0)\\]\n\\[|u_{i+1}| = |1 + \\lambda \\Delta t| |u_i| \\Rightarrow |u_{i+1}| = |1 + \\lambda \\Delta t|^{i+1} |u_0|\\]\nThe solution asymptotically vanishes if \\(|1 + \\lambda \\Delta t| &lt; 1\\)\nIntuitively, if \\(\\lambda\\) is Real and negative:\n\\[|1 + \\lambda \\Delta t| &lt; 1\\] \\[\\Downarrow\\] \\[-1 &lt; 1 + \\lambda \\Delta t &lt; 1\\] \\[\\Downarrow\\] \\[-2 &lt; \\lambda \\Delta t &lt; 0\\] \\[\\Downarrow\\] \\[\\Delta t &lt; \\frac{2}{|\\lambda|}\\]\nSo, if \\(\\Delta t &gt; \\frac{2}{|\\lambda|}\\) the numerical solution is not stable.\nFor \\(\\lambda\\) complex, we can draw the region of the plane \\(\\lambda \\Delta t\\) where the solution is stable.\n![Complex plane diagram showing unit circle with center at (-1,0)]\nUnit circle with center in \\((-1, 0)\\)\n(In magenta the region of stability of the problem).\nSo, the method is reproducing the asymptotic behavior of the exact solution ONLY UNDER THE CONDITION THAT:\n\\[\\lambda \\Delta t \\in \\text{Unit Circle centered in } (-1, 0).\\]\n\n\nWhat happens with Implicit Euler?\n\\[\\frac{1}{|1 - \\lambda \\Delta t|} &lt; 1 \\quad \\forall \\Delta t,\\]\nso \\(u^{n+1} \\xrightarrow{n \\to \\infty} 0 \\quad \\forall \\Delta t\\)\nThere is a big difference between the two Eulers: one is stable under some conditions, the other is unconditionally stable.\n\n\nWhat about Crank-Nicolson?\n\\[u^{n+1} = u^n + \\Delta t \\frac{\\lambda u^{n+1} + \\lambda u^n}{2} \\Rightarrow u^{n+1} = \\frac{1 + \\frac{\\Delta t}{2}\\lambda}{1 - \\frac{\\Delta t}{2}\\lambda} u^n\\]\nAgain, for \\(\\lambda \\in \\mathbb{C}\\) we have:\n\\[\\left|\\frac{1 + \\frac{\\Delta t}{2}\\lambda}{1 - \\frac{\\Delta t}{2}\\lambda}\\right| &lt; 1 \\quad \\forall \\Delta t\\]\nso also CN is stable with no condition.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#definition",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#definition",
    "title": "常微分方程的数值解",
    "section": "DEFINITION",
    "text": "DEFINITION\nA method is said to be ABSOLUTELY STABLE if the solution of the model problem \\(\\frac{dy}{dt} = \\lambda y\\) vanishes asymptotically when \\(t \\to +\\infty\\).\nWe say that the method is UNCONDITIONALLY ABSOLUTELY STABLE if this happens \\(\\forall \\Delta t &gt; 0\\). On the contrary, it is said to be CONDITIONALLY STABLE if we have limitations on \\(\\Delta t\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#another-example-heun",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#another-example-heun",
    "title": "常微分方程的数值解",
    "section": "Another Example: Heun",
    "text": "Another Example: Heun\n\\[u^{n+1} = u^n + \\frac{\\Delta t}{2}(\\lambda(u^n + \\Delta t \\lambda u^n) + \\lambda u^n) = \\left(1 + \\Delta t \\lambda + \\frac{\\Delta t^2 \\lambda^2}{2}\\right) u^n\\]\nNow, consider the curve \\(\\frac{\\Delta t^2 \\lambda^2}{2} + \\Delta t \\lambda + 1\\) for \\(\\lambda &lt; 0\\)\nWe see that we need:\n\\[0 &lt; \\Delta t &lt; \\frac{2}{|\\lambda|}\\]\n(as for Explicit Euler).\nIn the complex plane, the region is slightly larger than for Explicit Euler.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#remark-we-found-that-the-explicit-methods-are-conditionally-stable-while-the-implicit-ones-are-unconditionally-stable.",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#remark-we-found-that-the-explicit-methods-are-conditionally-stable-while-the-implicit-ones-are-unconditionally-stable.",
    "title": "常微分方程的数值解",
    "section": "REMARK: We found that the explicit methods are conditionally stable, while the implicit ones are unconditionally stable.",
    "text": "REMARK: We found that the explicit methods are conditionally stable, while the implicit ones are unconditionally stable.\nIn general, we do not have unconditionally stable explicit methods, but we do have implicit methods that are only conditionally stable.\nThe region of absolute stability is the portion of \\(\\mathbb{C}^-\\) for \\(\\lambda \\Delta t\\) to belong to such that the method is absolutely stable. Unconditional absolute stability (a.k.a A-stability) is when this region is the entire left plane \\(\\mathbb{C}^-\\).\nThe concept of absolute stability somehow clarifies what are the criteria to select a method for a problem.\nIn fact, let’s first consider the general case(s):\n\n\\(\\frac{dy}{dt} = f(t,y) \\simeq f(t,y_0) + \\frac{\\partial f}{\\partial t}(t-t_0) + \\frac{\\partial f}{\\partial y}(t,y_0)(y-y_0)\\)\nso we can locally take \\(\\lambda \\simeq \\frac{\\partial f}{\\partial y}(t,y_0)\\)\nFor a system: \\(\\frac{d\\mathbf{y}}{dt} = A \\mathbf{y} \\Rightarrow \\lambda = eig(A)\\)\n\\(\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}(t,\\mathbf{y})\\) (nonlinear system)\n\\(\\Rightarrow \\lambda = eig\\left(\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{y}}(t_0, y_0) \\right)\\) - Jacobian\n\nNow, for a general problem, we have:\n\n\n\nMethod\nNature\nAccuracy\nLimitations on \\(\\Delta t\\)\n\n\n\n\nFE\nExplicit\n1\n\\(\\Delta t &lt; \\frac{2}{|\\lambda|}\\)\n\n\nBE\nImplicit\n1\nNO\n\n\nCN\nImplicit\n2\nNO\n\n\nH\nExplicit\n2\n\\(\\Delta t &lt; \\frac{2}{|\\lambda|}\\)\n\n\n\nImplicit Methods are more computationally expensive.\nIn an extreme synthesis:\n![Comparison of FE and BE with timeline]\nWith FE each step is low-cost (Explicit) but we may need to do many for the conditional stability.\nWith BE each step is more expensive, but we need to do (generally) fewer steps.\n\\(\\Rightarrow\\) The optimal choice is largely problem dependent.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#example",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#example",
    "title": "常微分方程的数值解",
    "section": "Example:",
    "text": "Example:\n\\[y(t_{n+1}) = y(t_{n-1}) + \\int_{t_{n-1}}^{t_{n+1}} f(\\tau, y(\\tau)) d\\tau\\]\n\\[\\Downarrow \\text{ SIMPSON}\\]\n\\[u_{n+1} = u_{n-1} + 2\\Delta t \\frac{f(t_{n+1}, u_{n+1}) + 4f(t_n, u_n) + f(t_{n-1}, u_{n-1})}{6} =\\]\n\\[= u_{n-1} + \\frac{\\Delta t}{3}(f(t_{n+1}, u_{n+1}) + 4f(t_n, u_n) + f(t_{n-1}, u_{n-1}))\\]\n\\[\\mathbf{a} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} a_0, a_1 \\quad \\mathbf{b} = \\begin{bmatrix} \\frac{1}{3} \\\\ \\frac{4}{3} \\\\ \\frac{1}{3} \\end{bmatrix} b_{-1}, b_0, b_1\\]\nIn general, we have two approaches for deriving a Multi-step methods:",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#bdf-backward-difference-formulas",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#bdf-backward-difference-formulas",
    "title": "常微分方程的数值解",
    "section": "BDF (Backward Difference Formulas)",
    "text": "BDF (Backward Difference Formulas)\n\\[\\frac{dy}{dt}(t_{n+1}) = f(t_{n+1}, u_{n+1})\\] \\[\\downarrow\\] approximate this with a backward finite difference, e.g.,\n\\[\\frac{dy}{dt}(t_{n+1}) \\simeq \\frac{\\frac{3}{2}u_{n+1} - 2u_n + \\frac{1}{2}u_{n-1}}{\\Delta t}\\]\n\\[\\Rightarrow u_{n+1} = \\frac{4}{3}u_n - \\frac{1}{3}u_{n-1} + \\Delta t f(t_{n+1}, u_{n+1})\\]\nThey are all in the form:\n\\[\\mathbf{b} = \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#adams",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#adams",
    "title": "常微分方程的数值解",
    "section": "Adams",
    "text": "Adams\nIn this case, we start from:\n\\[y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(\\tau, y(\\tau)) d\\tau\\]\nNow, we replace \\(f\\) with an interpolation:\n\nWe interpolate \\(f\\) over the nodes: \\(n-p, n-p+1, ... n\\) so to have an explicit method (Adams-Bashforth)\nWe interpolate \\(f\\) over the nodes: \\(n-p, n-p+1, ... n, n+1\\)\n\nAdams methods have always:\n\\[\\mathbf{a} = \\begin{bmatrix} 1 \\\\ 0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#a-rapid-recall-of-difference-equations-theory",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#a-rapid-recall-of-difference-equations-theory",
    "title": "常微分方程的数值解",
    "section": "A Rapid Recall of Difference Equations Theory",
    "text": "A Rapid Recall of Difference Equations Theory\nA linear difference equation is an equation in the form:\n\\[u_{n+p} + a_{n+p-1}u_{n+p-1} + a_{n+p-2}u_{n+p-2} + \\ldots + a_0u_n = \\varphi_{n+p}\\]\nwhere the solution is the set \\(\\{u_j\\}\\) and initial conditions \\(u_0, u_1, \\ldots u_{p-1}\\) are given.\nThe theory on difference equations has several similarities with the theory on differential equations. In particular, the general solution of a linear difference equation is the linear combination of a particular solution of the equation and the general solution of the homogeneous one.\nThe general solution of the homogeneous takes the form:\n\\[u_n = \\sum_{j=0}^{N}\\left(\\sum_{s=0}^{m_j-1} V_{js}n^s \\right)r_j^n\\]\nwhere \\(r_j\\) are the roots of:\n\\[r^p + a_{p-1}r^{p-1} + a_{p-2}r^{p-2} + \\ldots + a_0 = 0\\]\nand - \\(N\\) is the number of distinct roots - \\(m_j\\) is the multiplicity of \\(r_j\\)\nWe will see a strong connection between this theory and the analysis of the linear multi-step methods.\nIn fact, a LMM reads like:\n\\[u_{n+1} - \\sum_{j=0}^p a_j u_{n-j} = \\Delta t \\sum_{j=-1}^p b_j f_{n-j}\\]\nIf we consider the model problem, we are lead to the linear difference equation:\n\\[u_{n+1} - \\sum_{j=0}^p a_j u_{n-j} - \\Delta t \\lambda \\sum_{j=-1}^p b_j u_{n-j} = 0\\]\nso we need to solve exactly a linear difference equation.\nMore precisely, we still define the LTE as the residual of the exact solution in the numerical scheme:\n\\[\\Delta t \\, \\tau_{n+1} = y_{ex}(t_{n+1}) - \\sum_{j=0}^p a_j y_{ex}(t_{n-j}) - \\Delta t \\sum_{j=-1}^p b_j \\frac{dy_{ex}}{dt}(t_{n-j})\\]\nThe method is CONSISTENT when \\(\\tau_{n+1} \\xrightarrow{\\Delta t \\to 0} 0 \\quad \\forall n\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#zero-stability-definition",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#zero-stability-definition",
    "title": "常微分方程的数值解",
    "section": "Zero-Stability Definition",
    "text": "Zero-Stability Definition\nThe definition of zero-stability is similar to the one for One-step Methods.\nAlso, we define:\nFirst characteristic polynomial:\n\\[\\rho(z) = z^{p+1} - \\sum_{j=0}^p a_j z^{p-j}\\]\nSecond characteristic polynomial:\n\\[\\sigma(z) = b_{-1}z^{p+1} - \\sum_{j=0}^p b_j z^{p-j}\\]\nand the polynomial: \\(\\Pi(z) = \\rho(z) - \\Delta t \\lambda \\sigma(z)\\) (this is the polynomial found for the model problem)\nBased on this we define:\nRoot Condition: Call \\(r_i\\) the roots of \\(\\rho(z)\\). The polynomial (or the associated LMM) fulfills the root condition when:\n\n\\(|r_i| \\leq 1 \\quad \\forall i\\)\nThe roots with \\(|r| = 1\\) have multiplicity 1.\n\nStrong Root Condition: In addition to the R.C., only \\(r_0\\) is s.t. \\(|r_0| = 1\\), all the other roots \\(|r_j| &lt; 1\\) \\((j &gt; 1, \\ldots, p)\\).\nAbsolute R.C.: \\(\\exists \\Delta t \\leq \\overline{\\Delta t}\\) s.t. all the roots \\(r_j(\\Delta t)\\) of \\(\\Pi_{\\Delta t}(z)\\) are s.t. \\(|r_j(\\Delta t)| &lt; 1\\), \\(j = 0, \\ldots, p\\), \\(\\Delta t \\leq \\overline{\\Delta t}\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#analysis-of-multistep-methods",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#analysis-of-multistep-methods",
    "title": "常微分方程的数值解",
    "section": "Analysis of Multistep Methods",
    "text": "Analysis of Multistep Methods\nWe have a sequence of theorems (no proofs):\n\nA LMM is consistent if and only if:\n\\[\\sum_{j=0}^p a_j = 1 \\quad -\\sum_{j=0}^p j a_j + \\sum_{j=-1}^p b_j = 1\\]\nAlso, the method is at least of order \\(p\\) if the solution is \\(\\in C^{p+1}(I)\\) and\n\\[(*)\\ \\sum_{j=0}^p (j)^k a_j + k \\sum_{j=-1}^p (j)^{k-1} b_j = 1 \\quad k = 1, 2, \\ldots q\\]\nRemark: The condition \\(\\sum_{j=0}^p a_j = 1\\) means that the first characteristic polynomial \\(\\rho(z)\\) has at least one root in 1.\nA consistent method is zero-stable if and only if it fulfills the root condition.\n\nWith Theorems (1) + (2) we have the convergence and order analysis.\n\n\n(2): If the LMM method falls into (1) and (2) with condition (*) (not true for q+1) and the initial conditions (\\(u_i \\to y_{ex}(t_i)\\) \\(i = 0, \\ldots, p\\)) converge to the exact ones with order \\(q\\), the resulting method is convergent with order \\(q\\).\n\n\nRemark (First Dahlquist Barrier): There is no zero-stable \\(p\\)-LMM with order - \\(&gt; p+1\\) for \\(p\\) odd - \\(&gt; p+2\\) for \\(p\\) even\nLet’s turn now to the Absolute stability.\n\nThe absolute root condition is necessary and sufficient for the absolute stability. In fact, if \\(\\overline{\\Delta t} = +\\infty\\), the absolute stability is unconditional.\n\nThe analysis of a LMM is completed by analyzing the coefficients of the method and the roots of the two polynomials \\(\\rho\\) and \\(\\Pi\\).\nThe roots of \\(\\Pi\\) can be analyzed numerically (and are tabulated for most of the methods) by Matlab/Python subroutines.\nSEE EXAMPLES (NODEPY library in Python, QSS in Matlab)\nRemark (Second Dahlquist Barrier): There are no explicit LMM absolutely unconditionally stable. There are no LMM absolutely unconditionally stable with order \\(q &gt; 2\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#a-clarification-on-stability-concepts",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#a-clarification-on-stability-concepts",
    "title": "常微分方程的数值解",
    "section": "A Clarification on Stability Concepts",
    "text": "A Clarification on Stability Concepts\nTo clarify the different stability concepts:\n\nZero-stability:\n\\[|u_j| \\leq C_{T_{fin}} (|u_0| + \\ldots |u_p|)\\]\nwhere the \\(C\\) may depend on \\(T_{fin}\\)\nAbsolute stability:\n\\[C_{T_{fin}} \\xrightarrow{T_{fin} \\to \\infty} 0\\]\n\\(C\\) is bounded independently of \\(T_{fin}\\)\nWe call this “relative stability”\n\n\\[\\text{for a consistent scheme} \\quad \\text{R.C.} \\Leftarrow \\text{Strong R.C.} \\Leftarrow\\text{A.R.C.}\\] \\[\\text{CONVERGENCE} \\Leftarrow \\text{Zero-Stability} \\Leftarrow \\text{Relative Stability} \\Leftarrow \\text{Absolute Stability}\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#example-extreme",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#example-extreme",
    "title": "常微分方程的数值解",
    "section": "Example (Extreme)",
    "text": "Example (Extreme)\nMid-point:\n\\[u_{n+1} = u_{n-1} + 2\\Delta t \\, f(t_n, u_n)\\]\n\\[a_0 = 0 \\quad a_1 = 1 \\quad \\Rightarrow \\rho(z) = z^2 - 1 = 0 \\quad \\Rightarrow \\rho = \\pm 1\\]\nR.C.: OK\n\\[\\Pi_{\\Delta t}(z) = z^2 - 2\\lambda z - 1\\]\nThe product of the two roots is always -1, if one root is &lt; 1 in magnitude, the other is &gt; 1.\nUnconditionally Absolutely UNSTABLE",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#predictor-corrector-methods",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#predictor-corrector-methods",
    "title": "常微分方程的数值解",
    "section": "Predictor-Corrector Methods",
    "text": "Predictor-Corrector Methods\nA clear message from the previous examples is that, in general, explicit methods are less absolutely stable, they are never unconditionally stable and have smaller regions of stability.\nHowever, let’s reconsider implicit methods too.\nFor instance, let’s consider a generic LMM:\n\\[u_{n+1} - \\sum_{j=0}^p a_j u_{n-j} = b_{-1} \\Delta t \\, f(t_{n+1}, u_{n+1}) + \\Delta t \\sum_{j=0}^p b_j f(t_{n-j}, u_{n-j})\\]\nTo solve this nonlinear equation, we could use a Newton method but also a fixed-point method and a natural candidate is the following:\n\\[u_{n+1}^{(m)} = \\sum_{j=0}^p a_j u_{n-j} + \\Delta t \\sum_{j=0}^p b_j f_{n-j} + \\Delta t b_{-1} f(t_{n+1}, u_{n+1}^{(m-1)})\\]\nNotice that this method converges if:\n\\[\\left|\\Delta t \\, b_{-1} \\, f'(t_{n+1}, u_{n+1}) \\right| &lt; 1\\]\nSo we have the condition:\n\\[\\Delta t &lt; \\frac{1}{|b_{-1}||f'|}\\]\nEven if the method is unconditionally stable, we may have a condition on \\(\\Delta t\\) for the convergence of the fixed-point.\nIn any case, a good initial condition is required, because with a good \\(u^{(0)}\\) the number of iterations can be reduced: an explicit method can be used to this.\nThese considerations lead to the design of a new class of methods, Heun being one of the possible examples.\nPredictor [P] is an explicit method of order \\(q_P\\)\nCorrector [C] is an implicit method of order \\(q_C\\)\nPredictor Corrector method:\nP: do one step of P \\(\\Rightarrow u_{n+1}^{(0)}\\)\nE: evaluate \\(f(t_{n+1}, u_{n+1}^{(0)})\\)\nC: compute \\(m\\) fixed-point iterations of C\nOptional: E: compute \\(f_{n+1} = f(t_{n+1}, u_{n+1}^{(m)})\\)\nThese methods go under the name of \\(\\text{PEC}^m\\) or \\(\\text{PEC}^m\\text{E}\\) if the last step is taken.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#examples",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#examples",
    "title": "常微分方程的数值解",
    "section": "Examples:",
    "text": "Examples:\nP = Adams-Bashforth of order 2 C = Adams-Moulton of order 3 \\(m = 1\\)\nPEC: \\[\\begin{cases}\nu_{n+1}^{(0)} = u_n^{(1)} + \\frac{\\Delta t}{2}(3f_n^{(0)} - f_{n-1}^{(0)}) \\\\\nf_{n+1}^{(0)} = f(t_{n+1}, u_{n+1}^{(0)}) \\\\\nu_{n+1}^{(1)} = u_n^{(1)} + \\frac{\\Delta t}{12}(5f_{n+1}^{(0)} + 8f_n^{(0)} - f_{n-1}^{(0)})\n\\end{cases}\\]\nPECE: \\[\\begin{cases}\nu_{n+1}^{(0)} = u_n^{(1)} + \\frac{\\Delta t}{2}(3f_n^{(1)} - f_{n-1}^{(1)}) \\\\\nf_{n+1}^{(0)} = f(t_{n+1}, u_{n+1}^{(0)}) \\\\\nu_{n+1}^{(1)} = u_n^{(1)} + \\frac{\\Delta t}{12}(5f_{n+1}^{(0)} + 8f_n^{(1)} - f_{n-1}^{(1)}) \\\\\nf_{n+1}^{(1)} = f(t_{n+1}, u_{n+1}^{(1)})\n\\end{cases}\\]\nA natural question is: what is the accuracy of \\(\\text{PEC}^m\\) or \\(\\text{PECE}^m\\)? What is the region of absolute stability?\nTheorem (Accuracy): \\(\\text{PECE}\\) methods have (under regularity assumptions on the solution) order of accuracy:\n\\[q_{PC} = min(q_P + m, q_C)\\]\nFor the region of absolute stability, in general:\n\\[\\text{Region}(P) \\subseteq \\text{Region}(\\text{PECE}) \\subseteq \\text{Region}(C)\\]\nand \\(\\text{Region}(\\text{PECE}) \\xrightarrow{m \\to +\\infty} \\text{Region}(C)\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#runge-kutta-methods",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#runge-kutta-methods",
    "title": "常微分方程的数值解",
    "section": "Runge-Kutta Methods",
    "text": "Runge-Kutta Methods\nHeun is also an RK method:\n\\[u_{n+1} = u_n + \\Delta t\\left(f_n + f(t_{n+1}, u_n + \\Delta t f_n)\\right)\\]\nThis is a 2nd order method but the accuracy is not obtained using more steps, but giving up the linearity of the method.\nIn general, RK are in the form:\n\\[u_{n+1} = u_n + \\Delta t \\, \\mathbf{K} \\cdot \\mathbf{b}\\]\nwhere \\(\\mathbf{K}, \\mathbf{b} \\in \\mathbb{R}^s\\)\nand \\([\\mathbf{K}]_i = f(t_n + c_i \\Delta t, u_n + \\Delta t[A\\mathbf{K}]_i)\\)\nwhere \\([\\mathbf{A}\\mathbf{K}]_i\\) is the \\(i^{th}\\) entry of the vector \\(\\mathbf{A}\\mathbf{K}\\)\nThe method is characterized by: \\(s\\) (stages), \\(\\mathbf{b}\\), \\(\\mathbf{c}\\) and \\(\\mathbf{A} \\in \\mathbb{R}^{s \\times s}\\)\nIn particular, the three “ingredients” are generally written as:\n\\[\\frac{\\mathbf{c} | \\mathbf{A}}{\\mathbf{b}^T} \\quad \\text{(Butcher array)}\\]\nIt is assumed that \\(c_i = \\sum_{j=1}^s a_{ij} \\quad \\forall i = 1, \\ldots s\\)\nIf \\(\\mathbf{A}\\) is such that \\(a_{ij} = 0 \\quad \\forall j \\geq i\\) then:\n\\[K_i = [\\mathbf{K}]_i = f(t_n + \\Delta t c_i, u_n + \\Delta t \\sum_{j &lt; i} a_{ij} K_j)\\]\nso the computation of \\(K_i\\) is immediate. We call this case an explicit RK scheme.\nIf \\(a_{ij} = 0 \\quad \\forall j &gt; i\\), then:\n\\[K_i = [\\mathbf{K}]_i = f(t_n + \\Delta t c_i, u_n + \\Delta t \\sum_{j &lt; i} a_{ij} K_j + \\Delta t a_{ii} K_i)\\]\nso we need to solve a non-linear equation to obtain \\(K_i\\). We call this a semi-implicit method.\nIn general, computing \\(\\mathbf{K}\\) requires the solution of a non-linear system (implicit method).\nClearly, the computational cost increases in the three cases.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#derivation-of-an-explicit-rk-method",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#derivation-of-an-explicit-rk-method",
    "title": "常微分方程的数值解",
    "section": "Derivation of an Explicit RK Method",
    "text": "Derivation of an Explicit RK Method\nA possible strategy to devise an explicit method is to maximize the order of the LTE with Taylor expansion analysis.\nFor instance, for \\(s = 2\\):\n\\[\\begin{pmatrix} 0 & 0 & 0 \\\\ c_2 & a_{21} & 0 \\\\ \\hline & b_1 & b_2 \\end{pmatrix}\\]\nWe have three parameters, but we set \\(a_{21} = c_2\\).\n\\[u_{n+1} = u_n + \\Delta t(b_1 f(t_n, u_n) + b_2 f(t_n + c_2 \\Delta t, u_n + \\Delta t c_2 f(t_n, u_n)))\\]\n\\[y_{ex}(t_n) = y_{ex}(t_n) + \\Delta t \\frac{dy_{ex}}{dt}(t_n) + \\frac{\\Delta t^2}{2}\\frac{d^2y_{ex}}{dt^2}(t_n) + \\frac{\\Delta t^3}{3!}\\frac{d^3y_{ex}}{dt^3}(t_n) + H.O.T.\\]\n\\[f(t_n + c_2 \\Delta t, u_n + \\Delta t c_2 f(t_n, u_n)) =\\]\n\\[= f(t_n, u_n) + \\frac{\\partial f}{\\partial t}(t_n, y_n)c_2 \\Delta t + \\frac{\\partial f}{\\partial y}(t_n, y_n)c_2 \\Delta t f(t_n, u_n) =\\]\nNotice that: \\[\\frac{d^2y}{dt^2} = \\frac{df}{dt} = \\frac{\\partial f}{\\partial t} + \\frac{\\partial f}{dy}\\frac{dy}{dt} = \\frac{\\partial f}{\\partial t} + \\frac{\\partial f}{\\partial y}f\\]\n\\[\\Rightarrow f(t_n, u_n) + c_2 \\Delta t \\frac{d^2y}{dt^2}(t_n)\\]\nThe Taylor expansion applied to the scheme reads:\n\\[u_{n+1} = u_n + \\Delta t(b_1 + b_2)f + c_2 b_2 \\Delta t^2 \\frac{d^2y}{dt^2}\\]\nWe match therefore the first terms of the Taylor expansion for:\n\\[\\begin{align}\nb_1 + b_2 &= 1 \\\\\nb_2 c_2 &= \\frac{1}{2}\n\\end{align}\\]\nFor \\(b_2 = \\frac{1}{2}\\) we obtain the Heun method.\nThe L.T.E is \\(\\Delta t \\, \\tau \\sim O(\\Delta t^3)\\)\nso the method is 2nd order.\nImplicit methods can be devised from Gaussian quadratures.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#analysis-of-rk",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#analysis-of-rk",
    "title": "常微分方程的数值解",
    "section": "Analysis of RK",
    "text": "Analysis of RK\nCONSISTENCY: As the previous example shows, we need \\(\\sum b_i = 1\\). This is necessary and sufficient for the consistency.\nZERO-STABILITY: RK are One-Step methods, if \\(f\\) is Lipschitz-Continuous, they are zero-stable.\nORDER: In general, the order we can obtain depends on the number of stages in a (non-trivial) way:\n\n\n\nExplicit RK:\nORDER\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n\\(s_{min}\\)\n\n1\n2\n3\n4\n6\n7\n9\n11\n\n\n\n\\(s_{min}\\) = minimum number of stages to obtain the corresponding order.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#absolute-stability",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#absolute-stability",
    "title": "常微分方程的数值解",
    "section": "ABSOLUTE STABILITY",
    "text": "ABSOLUTE STABILITY\nIf we write the method for the model problem, we can write:\n\\[u_{n+1} = \\mathcal{R}(\\Delta t \\lambda) u_n\\]\nThe region of absolute stability is, in general, the non-trivial region where \\(|\\mathcal{R}(\\Delta t \\lambda)| &lt; 1\\) (in \\(\\mathbb{C}\\)).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#why-are-rk-so-popular",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#why-are-rk-so-popular",
    "title": "常微分方程的数值解",
    "section": "Why are RK so popular?",
    "text": "Why are RK so popular?\nRK are extremely popular, because they can be high order with “only” one-step.\nOne-step means that: - we do not need high-order approximation of the initial data needed by LMM (the initial condition is enough) - we can easily perform the time-step ADAPTIVITY (much more difficult with LMM).\nFor the adaptivity, there are smart combinations of RK that obtain the adaptivity (i.e. an error estimate to adapt the step) in an efficient way.\nOne of the most popular is: RK45 Fehlberg: smart combination of an explicit method of order 4 and an explicit of order 5 to adapt the step.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#a-final-note-on-stiff-problems",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#a-final-note-on-stiff-problems",
    "title": "常微分方程的数值解",
    "section": "A Final Note on Stiff problems",
    "text": "A Final Note on Stiff problems\nMany of the concepts used here can be extended to systems of ODEs:\n\\[\\begin{cases}\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{F}(t, \\mathbf{y}) \\\\\n\\mathbf{y}(0) = \\mathbf{y}_0\n\\end{cases}\\]\nIn the case of a linear ODE system:\n\\[\\mathbf{F} = A \\, \\mathbf{y} \\quad \\downarrow \\quad \\text{matrix}\\]\nThere is, however, an important concept to clarify.\nConsider a simple 2×2 problem:\n\\[\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}\\]\nwhere \\(A\\) has the two eigenvalues: \\(\\begin{cases} \\lambda_1 = -10^6 \\\\ \\lambda_2 = -1 \\end{cases}\\)\nIf we use Explicit Euler:\n\\[\\mathbf{y}^{n+1} = \\mathbf{y}^n + \\Delta t \\, A \\mathbf{y}^n\\]\nthe region of absolute stability is:\n\\[\\Delta t \\leq \\min\\left(\\frac{2}{10^6}, \\frac{2}{1}\\right) = 2 \\cdot 10^{-6}\\]\nThe solution, on the other hand, is the linear combination of the two functions:\n\\[e^{-10^6 t}, e^{-t}\\]\n[Graph showing rapid decay of \\(e^{-10^6 t}\\) vs slower decay of \\(e^{-t}\\)]\nTo capture the fast dynamics (\\(\\lambda = 10^{-6}\\)), that fades away immediately, we need to take \\(\\Delta t \\sim 10^{-6}\\)!!!\nAn explicit method is certainly not a good choice here.\nIn general, we say that a problem is “stiff” when it may require very stringent time-step in a non-efficient way. The name “stiff” originates from the coupling of springs with different stiffness:\n[Simple diagram of a mass connected to two springs with different spring constants]\nto study the dynamics of the two real balls, one can write an ODE system.\nIf \\(K_1 &lt;&lt; K_2\\) this is a stiff problem.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#exercise-on-lmm",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/03 Numerical Solution of Ordinary Differential Equations.html#exercise-on-lmm",
    "title": "常微分方程的数值解",
    "section": "EXERCISE on LMM",
    "text": "EXERCISE on LMM\nConsider the following family of methods (LMM):\n\\[u_{n+1} = \\alpha u_n + (1-\\alpha)u_{n-1} + \\Delta t \\, \\gamma f_{n+1}\\]\n\nInvestigate the convergence properties of the method as function of \\(\\alpha\\) and \\(\\gamma\\).\n\nSol: For \\(\\alpha \\neq 1\\), the method is 2-step. For \\(\\gamma \\neq 0\\), the method is implicit.\nIt’s a LMM with: \\(\\mathbf{a} = \\begin{bmatrix} \\alpha \\\\ 1-\\alpha \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\end{bmatrix}\\), \\(\\mathbf{b} = \\begin{bmatrix} \\gamma \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} -1 \\\\ 0 \\\\ 1 \\end{bmatrix}\\)\nConsistency: \\(\\sum a_j = 1\\): \\(\\alpha + (1-\\alpha) = 1\\) ✓OK \\(-\\sum j a_j + \\sum b_j = 1\\): \\(0 \\cdot \\alpha - 1 \\cdot (1-\\alpha) + \\gamma = 1\\) \\(\\Rightarrow \\gamma = 2 - \\alpha\\)\nThe methods: \\(u_{n+1} = \\alpha u_n + (1-\\alpha)u_{n-1} + \\Delta t (2-\\alpha)f_{n+1}\\) are consistent.\nOrder: \\(\\sum (j)^2 a_j + 2\\sum (-j)^1 b_j = 1\\) ? \\(\\Rightarrow (1-\\alpha) + 2(2-\\alpha) = 1 \\Rightarrow \\alpha = \\frac{4}{3}, \\gamma = \\frac{2}{3}\\)\n\nInvestigate the absolute stability of the method with order 2.\n\nThe method: \\(u_{n+1} = \\frac{4}{3}u_n - \\frac{1}{3}u_{n-1} + \\Delta t \\frac{2}{3}f_{n+1}\\)\nis of order 2 (it is, in fact, a BDF of order 2).\n\\(\\rho(z) = z^2 - \\frac{4}{3}z + \\frac{1}{3} = 0 \\quad r_{1,2} = \\frac{\\frac{4}{3} \\pm \\sqrt{\\frac{16}{9} - \\frac{4}{3}}}{2} = \\frac{4 \\pm 2}{6} = \\frac{2 \\pm 1}{3}\\)\nR.C. ✓\n\\(\\Pi_{\\Delta t}(z) = z^2 - \\frac{4}{3}z + \\frac{1}{3} - \\Delta t \\lambda \\frac{2}{3}z^2 = 0\\)\nLet’s consider \\(\\lambda \\in \\mathbb{R}^-\\):\n\\((3 - \\Delta t \\lambda 2)z^2 - 4z + 1 = 0\\)\n\\(z^2 - \\frac{4z}{3 + 2\\Delta t|\\lambda|} + \\frac{1}{3 + 2\\Delta t|\\lambda|} = 0\\)\n\\(r_1 \\cdot r_2 = \\frac{1}{3 + 2\\Delta t|\\lambda|}\\)\n\\(r_1 = \\frac{2 + \\sqrt{1 - 2\\Delta t|\\lambda|}}{3 + 2\\Delta t|\\lambda|} \\xrightarrow{\\Delta t \\to 0} 1\\)\n\\(|r_1(\\Delta t)| &lt; 1 \\quad \\forall \\Delta t &gt; 0\\)\n\\(r_2 = \\frac{2 - \\sqrt{1 - 2\\Delta t|\\lambda|}}{3 + 2\\Delta t|\\lambda|} \\xrightarrow{\\Delta t \\to 0} \\frac{1}{3}\\)\n\\(|r_2(\\Delta t)| &lt; \\frac{1}{3}\\)\nMethod unconditionally stable (Verify with Python/Matlab).\n\nSolve \\[\\begin{cases}\n\\frac{dy}{dt} = -(1 + t_g(t))y & t \\in [0, 1] \\\\\ny(0) = 1\n\\end{cases}\\]\n\nwith the BDF2 method found and verify your results, knowing that the exact solution is \\(y_{ex} = e^{-x}\\cos(x)\\).\nUsing MATLAB, the problem is easily solved with the QSS subroutines:\nqssstab.m (draws the region of absolute stability) qssmulti.m (solves with a generic LMM)\nWith Python there are many libraries: SciPy, odeint that uses RK, ode, and allows the selection of BDF methods, but generally with adaptive time step.\nNODEPY is potentially an excellent library but buggy.\nIt’s excellent for drawing the stability region (see hmm.py on Canvas)\nI have written a simple LMM solver with fixed-point iterations for implicit methods.\nUsing my-hmm.py you can verify that our method is 2nd order:\n\n\n\n\n\n\n\n\n\nmax error\n\\(3 \\cdot 10^{-4}\\)\n\\(8 \\cdot 10^{-5}\\)\n\\(2 \\cdot 10^{-5}\\)\n\n\n\n\n\\(\\Delta t\\)\n0.05\n0.025\n0.0125\n\n\n\n[Graph showing exact vs numerical solution]\n[Stability region diagram showing a circle in the complex plane] Red = Region of Stability",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "常微分方程的数值解"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html",
    "title": "9.1 边值问题的近似",
    "section": "",
    "text": "我们可以写 \\[\n\\begin{align}\n-\\frac{d^2u}{dx^2} &= f(x), \\quad x \\in (0,1) \\\\\nu(0) &= \\alpha, \\quad \\frac{du}{dx}(0) = \\beta\n\\end{align}\n\\]\n记\\(w = \\frac{du}{dx}\\)，那么 \\(\\frac{dw}{dx} = f(x)\\)。因此，我们知道\n\\[\\frac{d}{dt} = \\begin{bmatrix} 0 & 0 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} w \\\\ u \\end{bmatrix}\\]\n\n\n边值问题（boundary-value problem）的定义为 &gt; [!definition|*] &gt; \\[\\begin{align}\n-\\mu\\frac{d^2u}{dx^2} &= f(x), \\quad x\\in (0,1), \\quad \\mu &gt; 0 \\\\\nu(0) &= \\alpha, \\quad u(1) = \\beta\n\\end{align}\n&gt; \\] ## 1.2 泊松方程（Poisson Equation） 此类方程的二维形态为：\n\\[\\begin{align}\n-\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) &= f(x,y) \\\\\nu|_{\\text{boundary of }\\Omega} &= 0\n\\end{align}\\]\n用拉普拉斯算子来表示：\n\\[\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = \\Delta u, \\quad \\text{where }\\Delta = \\nabla^2 u = \\sum_{i=1}^{n} \\frac{\\partial^2}{\\partial x_i^2}\\]\n所以，广义的泊松方程可以写为\n\n[!definition] A general (\\(n\\)-dimentional) poisson equation is written as \\[\\Delta u = f(\\mathbf{x})\\] where \\(\\mathbf{x}=(x_{1},x_{2},x_{3}\\dots x_{n})\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.1 边值问题的近似"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html#set-up-string-with-fixed-endpoints",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html#set-up-string-with-fixed-endpoints",
    "title": "9.1 边值问题的近似",
    "section": "",
    "text": "我们可以写 \\[\n\\begin{align}\n-\\frac{d^2u}{dx^2} &= f(x), \\quad x \\in (0,1) \\\\\nu(0) &= \\alpha, \\quad \\frac{du}{dx}(0) = \\beta\n\\end{align}\n\\]\n记\\(w = \\frac{du}{dx}\\)，那么 \\(\\frac{dw}{dx} = f(x)\\)。因此，我们知道\n\\[\\frac{d}{dt} = \\begin{bmatrix} 0 & 0 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} w \\\\ u \\end{bmatrix}\\]\n\n\n边值问题（boundary-value problem）的定义为 &gt; [!definition|*] &gt; \\[\\begin{align}\n-\\mu\\frac{d^2u}{dx^2} &= f(x), \\quad x\\in (0,1), \\quad \\mu &gt; 0 \\\\\nu(0) &= \\alpha, \\quad u(1) = \\beta\n\\end{align}\n&gt; \\] ## 1.2 泊松方程（Poisson Equation） 此类方程的二维形态为：\n\\[\\begin{align}\n-\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) &= f(x,y) \\\\\nu|_{\\text{boundary of }\\Omega} &= 0\n\\end{align}\\]\n用拉普拉斯算子来表示：\n\\[\\left(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}\\right) = \\Delta u, \\quad \\text{where }\\Delta = \\nabla^2 u = \\sum_{i=1}^{n} \\frac{\\partial^2}{\\partial x_i^2}\\]\n所以，广义的泊松方程可以写为\n\n[!definition] A general (\\(n\\)-dimentional) poisson equation is written as \\[\\Delta u = f(\\mathbf{x})\\] where \\(\\mathbf{x}=(x_{1},x_{2},x_{3}\\dots x_{n})\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.1 边值问题的近似"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html#back-to-the-string-example-how-can-we-get-a-bvp",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html#back-to-the-string-example-how-can-we-get-a-bvp",
    "title": "9.1 边值问题的近似",
    "section": "1.3 Back to the String Example: How can we get a BVP?",
    "text": "1.3 Back to the String Example: How can we get a BVP?\n考虑以下经典力学中很常见的弦的能量泛函（energy functional）：\n\\[J(u) = \\frac{1}{2}\\int_0^1 \\mu\\left(\\frac{du}{dx}\\right)^2 dx - \\int_0^1 f \\cdot u \\, dx \\quad \\text{(Energy of string)}\\]\nBoundary condition: \\(u(0) = u(1) = 0\\).\n作为自然界的基本趋势中，最小作用量原理解释了自然系统倾向于采取能量消耗最小的路径或状态，也就是说，自然会沿着\\(\\min J(u)\\)的路径发展。\n最简单的方法是直接用 欧拉-拉格朗日方程（Euler–Lagrange equation）搞定，但是这毕竟是个数学课，那么我们用最暴力的原始方法解决：\n大致思路为： 1. 把 \\(u\\) 加入扰动（perturbation）变成 \\(u+εv\\)：\n\\[u_{\\epsilon}(x) = u(x) + \\epsilon v(x)\\]\n\n\\(J(u+εv)\\) 进行显式展开：\n\n\\[J(u + \\epsilon v) = J(u) + \\epsilon \\underbrace{\\delta J(u; v)}_{\\text{一阶变分}} + \\frac{1}{2} \\epsilon^2 \\underbrace{\\delta^2 J(u; v)}_{\\text{二阶变分}} + \\cdots\\]\n\n在变分法或力学的语言里：通常是指在能量或作用量（action）等泛函意义下的驻点（stationary point）：也就是对任意“小扰动” \\(εv\\)，该函数 \\(u\\) 都使得泛函的一阶变化量为 0。\n\n\n求导，来找\\(J\\)的最小值\n\n\\[\\lim_{\\varepsilon \\to 0} \\frac{J(u + \\varepsilon v) - J(u)}{\\varepsilon} = 0, \\quad \\varepsilon \\in \\mathbb{R}\\]\n显然易见：\n\\[\n\\begin{align}\n&\\frac{1}{2}\\int_0^1 \\mu\\left(\\frac{du}{dx} + \\varepsilon\\frac{dv}{dx}\\right)^2 dx - \\int_0^1 f(u+\\varepsilon v) \\, dx - \\frac{1}{2}\\int_0^1 \\mu\\left(\\frac{du}{dx}\\right)^2 dx - \\int_0^1 f \\cdot u \\, dx \\\\\n&= \\frac{1}{2}\\int_0^1 \\mu\\left(\\frac{du}{dx}\\right)^2 dx + \\frac{1}{2} \\cdot 2\\varepsilon \\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx + \\frac{1}{2}\\varepsilon^2 \\int_0^1 \\mu\\left(\\frac{dv}{dx}\\right)^2 dx \\\\\n&\\quad - \\int_0^1 f \\cdot u \\, dx - \\varepsilon\\int_0^1 f \\cdot v \\, dx - \\frac{1}{2}\\int_0^1 \\mu\\left(\\frac{du}{dx}\\right)^2 dx - \\int_0^1 f \\cdot u \\, dx \\\\\n&= \\varepsilon \\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx + \\frac{1}{2}\\varepsilon^2 \\int_0^1 \\mu\\left(\\frac{dv}{dx}\\right)^2 dx - \\varepsilon\\int_0^1 f \\cdot v \\, dx\\end{align}\n\\]\n\n这实际上正是欧拉–拉格朗日方程最早的“原始变分法”推导，也正是 E-L 方程的来龙去脉。只不过 E-L 方程把这个过程“公式化”了，让我们不必每次都展开一大堆项、再分部积分去凑出那个通用形式。\n\n然后\n\\[\\frac{J(u+\\varepsilon v) - J(u)}{\\varepsilon} = \\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx + \\frac{1}{2} \\varepsilon \\int_0^1 \\mu\\left(\\frac{dv}{dx}\\right)^2 dx - \\int_0^1 f \\cdot v \\, dx\\]\n极限为：\n\\[\\lim_{\\varepsilon \\to 0} \\frac{J(u+\\varepsilon v) - J(u)}{\\varepsilon} = \\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx - \\int_0^1 f \\cdot v \\, dx = 0\\]\n一个“平衡解”（equilibrium solution）。\n\n变分形式或弱形式（Variational/Weak）:\n由此我们得到了一个泛函的“变分条件”：\n\n[!claim|*] \\[\\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx - \\int_0^1 f \\cdot v \\, dx = 0\\]\n\n分部积分:\n\\[\n\\begin{align}\n\\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx &= \\mu\\left[\\frac{du}{dx}v\\right]_0^1 - \\mu\\int_0^1 \\frac{d^2u}{dx^2} v \\, dx \\\\\n&= -\\mu\\int_0^1 \\frac{d^2u}{dx^2} v \\, dx\n\\end{align}\n\\]\nSince \\(v(0) = v(1) = 0\\)\n\\[\\frac{d}{dx}\\left(\\frac{du}{dx}\\right) = \\frac{d^2u}{dx^2}\\]\n\\[\\int \\frac{dv}{dx} \\, dx = v\\]\n边界项因为BC而消失，所以弱形式\\(\\rightarrow\\)强形式:\n\\[-\\mu\\int_0^1 \\frac{d^2u}{dx^2} v \\, dx - \\int_0^1 f \\cdot v \\, dx = 0\\]\n\\[-\\int_0^1 \\left(\\mu\\frac{d^2u}{dx^2} + f\\right) \\cdot v \\, dx = 0\\]\nWe want it to be true \\(\\forall v\\). So, it must be: \\[\\mu\\frac{d^2u}{dx^2} + f = 0\\]\n我们得到一个常见的附带边界条件的强形式常微分方程(ODE)。\n\n[!claim|*] We obtain a Boundary Value Problem (BVP): \\[\n\\begin{align}\n\\mu u''(x) +f&= 0 \\\\\nu(0) &= u(1) = 0\n\\end{align}\n\\]\n\n\nAssumption: \\(u\\) is at least \\(C^2\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.1 边值问题的近似"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html#两种表述边值问题bvp的方式",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.1 Boundary Value Problems.html#两种表述边值问题bvp的方式",
    "title": "9.1 边值问题的近似",
    "section": "1.4 两种表述边值问题（BVP）的方式",
    "text": "1.4 两种表述边值问题（BVP）的方式\n\n寻找函数 \\(u\\)，使得对所有满足 \\(v(0) = v(1) = 0\\) 的 \\(v\\)，均有\n\n\\[\n   \\int_0^1 \\mu \\frac{du}{dx} \\cdot \\frac{dv}{dx} \\, dx \\;=\\; \\int_0^1 f \\cdot v \\, dx\n\\]\n\n\\(\\Rightarrow\\) \\(u\\) 只需保证“一阶可微”\n\\(\\Rightarrow\\) 通常采用 有限元法 (Finite Element)\n\n\n寻找函数 \\(u\\)，使得\n\n\\[\n   \\begin{aligned}\n   -\\mu \\frac{\\partial^2 u}{\\partial x^2} &= f, \\quad x \\in (0,1),\\\\\n   u(0) &= 0,\\quad u(1) = 0\n   \\end{aligned}\n   \\]\n\n\\(\\Rightarrow\\) \\(u\\) 需要至少“二阶可微”\n\\(\\Rightarrow\\) 通常采用 有限差分法 (Finite Difference)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.1 边值问题的近似"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html",
    "title": "9.3 对流-扩散方程",
    "section": "",
    "text": "对流-扩散方程是一种描述物质或热量在流体中同时受到对流（也称为平流）和扩散作用影响的偏微分方程。这个方程在流体力学、传热学和物质传输等领域有广泛应用。\n\\[\n\\begin{align}\n-\\mu\\frac{\\partial^2 u}{\\partial x^2} + \\beta\\frac{\\partial u}{\\partial x} &= f \\\\\n\\text{diffusion} \\quad & \\text{advection}\n\\end{align}\n\\]\n\\[u(0) = u_L, \\quad u(1) = u_R\\]\n\n\n\n\n\n\n$$ \\[\\begin{align}\n\n\nu(x_{j+1})  & = u(x_j) + \\frac{\\partial u}{\\partial x}(x_j)\\Delta x + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x^2  \\\\\n&\\quad\\quad\\quad\\quad-\\frac{1}{6}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^3 + \\frac{1}{12}\\frac{\\partial^4 u}{\\partial x^4}(x_j)\\Delta x^4 + \\mathcal{O}(||x||^5)\\\\\n\\frac{\\partial u}{\\partial x}(x_j)\\Delta x  & = u(x_{j+1}) - u(x_j) + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x^2\\\\\n\\frac{\\partial u}{\\partial x}(x_j)  & = \\frac{u_{j+1} - u_j}{\\Delta x} + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x\n\\end{align}\\]$$\n\n\n\n\\[u(x_{j-1}) = u(x_j) - \\frac{\\partial u}{\\partial x}(x_j)\\Delta x + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x^2 - \\frac{1}{6}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^3 + \\frac{1}{12}\\frac{\\partial^4 u}{\\partial x^4}(x_j)\\Delta x^4 + \\mathcal{O}(||x||^5)\\]\n我们取(forward) - (backward)两者差值\n\\[u(x_{j+1}) - u(x_{j-1}) = 2\\frac{\\partial u}{\\partial x}(x_j)\\Delta x + \\frac{1}{3}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^3 + \\mathcal{O}(||\\Delta x||^5)\\]\n接着\n\\[\\frac{\\partial u}{\\partial x}(x_j) = \\frac{u(x_{j+1}) - u(x_{j-1})}{2\\Delta x} - \\frac{1}{6}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^2 + \\mathcal{O}\\left(\\frac{||\\Delta x||^4}{2}\\right)\\]\n\n\n\n\n这都还不会吗？退群吧。\n\n\n\n\n[!claim|*] Final numerical solution: \\[-\\mu\\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} = f_j\\] with second-order accuracy: \\[\\sim \\mathcal{O}(\\Delta x^2)\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.3 对流-扩散方程"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#对流-扩散方程",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#对流-扩散方程",
    "title": "9.3 对流-扩散方程",
    "section": "",
    "text": "对流-扩散方程是一种描述物质或热量在流体中同时受到对流（也称为平流）和扩散作用影响的偏微分方程。这个方程在流体力学、传热学和物质传输等领域有广泛应用。\n\\[\n\\begin{align}\n-\\mu\\frac{\\partial^2 u}{\\partial x^2} + \\beta\\frac{\\partial u}{\\partial x} &= f \\\\\n\\text{diffusion} \\quad & \\text{advection}\n\\end{align}\n\\]\n\\[u(0) = u_L, \\quad u(1) = u_R\\]\n\n\n\n\n\n\n$$ \\[\\begin{align}\n\n\nu(x_{j+1})  & = u(x_j) + \\frac{\\partial u}{\\partial x}(x_j)\\Delta x + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x^2  \\\\\n&\\quad\\quad\\quad\\quad-\\frac{1}{6}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^3 + \\frac{1}{12}\\frac{\\partial^4 u}{\\partial x^4}(x_j)\\Delta x^4 + \\mathcal{O}(||x||^5)\\\\\n\\frac{\\partial u}{\\partial x}(x_j)\\Delta x  & = u(x_{j+1}) - u(x_j) + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x^2\\\\\n\\frac{\\partial u}{\\partial x}(x_j)  & = \\frac{u_{j+1} - u_j}{\\Delta x} + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x\n\\end{align}\\]$$\n\n\n\n\\[u(x_{j-1}) = u(x_j) - \\frac{\\partial u}{\\partial x}(x_j)\\Delta x + \\frac{1}{2}\\frac{\\partial^2 u}{\\partial x^2}(x_j)\\Delta x^2 - \\frac{1}{6}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^3 + \\frac{1}{12}\\frac{\\partial^4 u}{\\partial x^4}(x_j)\\Delta x^4 + \\mathcal{O}(||x||^5)\\]\n我们取(forward) - (backward)两者差值\n\\[u(x_{j+1}) - u(x_{j-1}) = 2\\frac{\\partial u}{\\partial x}(x_j)\\Delta x + \\frac{1}{3}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^3 + \\mathcal{O}(||\\Delta x||^5)\\]\n接着\n\\[\\frac{\\partial u}{\\partial x}(x_j) = \\frac{u(x_{j+1}) - u(x_{j-1})}{2\\Delta x} - \\frac{1}{6}\\frac{\\partial^3 u}{\\partial x^3}(x_j)\\Delta x^2 + \\mathcal{O}\\left(\\frac{||\\Delta x||^4}{2}\\right)\\]\n\n\n\n\n这都还不会吗？退群吧。\n\n\n\n\n[!claim|*] Final numerical solution: \\[-\\mu\\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} = f_j\\] with second-order accuracy: \\[\\sim \\mathcal{O}(\\Delta x^2)\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.3 对流-扩散方程"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#例子精确解与数值解在对流主导问题中的差异",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#例子精确解与数值解在对流主导问题中的差异",
    "title": "9.3 对流-扩散方程",
    "section": "3.2 例子：精确解与数值解在对流主导问题中的差异",
    "text": "3.2 例子：精确解与数值解在对流主导问题中的差异\n我们现在考虑一个特殊情况的对流-扩散方程，其中源项（Source Term）为零，具有以下边界条件：\n\\[\n\\begin{align}\n-\\mu\\frac{\\partial^2 u}{\\partial x^2} + \\beta\\frac{\\partial u}{\\partial x} &= 0 \\\\\nu(0) &= 0 \\\\\nu(a) &= 1\n\\end{align}\n\\]\n\n3.2.1 精确解\n这个方程的精确解是：\n\\[u_{ex} = \\frac{e^{\\frac{\\beta}{\\mu}x} - 1}{e^{\\frac{\\beta}{\\mu}a} - 1}\\]\n这个解的特点是：当比值 \\(\\frac{|\\beta|}{\\mu} \\gg 1\\) 时（即advection远大于diffusion），解在边界 \\(x=a\\) 附近会形成一个陡峭的边界层。这被称为“对流主导问题”（advection-dominated problem）。\n在对流主导的情况下，解在大部分区域接近于0，只在接近 \\(x=a\\) 的小区域内快速上升到1。这对数值方法的解法是很大的麻烦。\n\n\n3.2.2 数值解\n当我们使用标准的中心差分（central difference）方法离散化这个方程时：\n\\[-\\mu\\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} = 0\\]\n重新整理这个方程：\n\\[\\left(-\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)u_{i+1} + \\left(\\frac{2\\mu}{\\Delta x^2}\\right)u_i - \\left(\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)u_{i-1} = 0\\]\n数值实验表明，当 \\(|\\beta|\\) 较大时，数值解会出现不一致，非物理的振荡。为什么呢？\n\n数学解释\n为了理解这一现象，我们可以对差分方程进行深入分析。我们假设差分方程的解具有形式 \\(u_j = C\\rho^j\\)，其中 \\(C\\) 是常数，\\(\\rho\\) 是待定参数。将这个假设代入到差分方程中：\n\\[\\left(-\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)C\\rho^{j+1} + \\left(\\frac{2\\mu}{\\Delta x^2}\\right)C\\rho^j - \\left(\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)C\\rho^{j-1} = 0\\]\n消去 \\(C\\) 并整理：\n\\[\\left(-\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)\\rho^2 + \\left(\\frac{2\\mu}{\\Delta x^2}\\right)\\rho - \\left(\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right) = 0\\]\n这是关于 \\(\\rho\\) 的二次方程，它有两个解 \\(\\rho_1\\) 和 \\(\\rho_2\\)。差分方程的一般解是这两个特解的线性组合：\n\\[u_j = C_1\\rho_1^j + C_2\\rho_2^j\\]\n其中 \\(C_1\\) 和 \\(C_2\\) 是由边界条件确定的常数。\n\n\n振荡解的条件\n根据二次方程的性质，两个根的乘积等于常数项与二次项系数的比值：\n\\[\\rho_1\\rho_2 = \\frac{-\\left(\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)}{\\left(-\\frac{\\mu}{\\Delta x^2} + \\frac{\\beta}{2\\Delta x}\\right)} = \\frac{1 + \\frac{\\beta\\Delta x}{2\\mu}}{1 - \\frac{\\beta\\Delta x}{2\\mu}}\\]\n这里引入了一个重要的无量纲参数，称为网格佩克莱数（Grid Péclet number）：\n\\[\\text{Pe} = \\frac{|\\beta|\\Delta x}{2\\mu}\\]\n佩克莱数表示对流传输与扩散传输的相对强度。\n当 \\(\\text{Pe} &gt; 1\\)（即 \\(\\frac{|\\beta|\\Delta x}{2\\mu} &gt; 1\\)）时，我们有 \\(\\rho_1\\rho_2 &lt; 0\\)，这意味着两个根一正一负。当一个解包含负的幂时，会导致解在空间上呈现振荡特性，这与物理直觉相违背，因为扩散过程应该是平滑的。\n\n\n\n物理解释与改进方法\n\n为什么会出现振荡？\n物理角度看：信息主要沿着流动方向传播。Central Difference 方法对上游和下游的信息给予相同权重，所以对流主导的情况下不合适，除非极细的网格才能准确解析。即使数值方法在数学上具有二阶精度，其准确度依旧是要取决于特定的物理问题中。理解数值方法的稳定性条件才可以选择合适的求解策略。\n\n\n解决方案？\n\n网格细化：最直接的方法是减小 \\(\\Delta x\\)，使 \\(\\text{Pe} &lt; 1\\)。但这会大大增加计算成本。\n迎风方法：（详细见下文）使用偏向上游的差分格式，如前向或后向差分，取决于 \\(\\beta\\) 的符号。例如，当 \\(\\beta &gt; 0\\) 时，可以使用： \\[\\frac{\\partial u}{\\partial x}(x_j) \\approx \\frac{u_j - u_{j-1}}{\\Delta x}\\]\n人工扩散：增加一个数值扩散项，使有效的佩克莱数小于1。\n高阶格式：使用更高阶的差分格式，如QUICK、TVD或ENO/WENO方案，这些方法可以更好地捕捉强梯度区域。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.3 对流-扩散方程"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#另一种方法迎风法upwind-method",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#另一种方法迎风法upwind-method",
    "title": "9.3 对流-扩散方程",
    "section": "3.3 另一种方法：迎风法（Upwind Method）",
    "text": "3.3 另一种方法：迎风法（Upwind Method）\n\n3.3.1 信息流动分析 (Information Flow)\n就像刚刚的对流主导问题，现实中经常存在明确的物理信息流动方向，使得这个问题本质上是非对称的。\n对于对流项（advection），当流动方向已知时 &gt; [!assumption|*] &gt; \\(\\beta &gt; 0\\)，meaning that the information flows from left to right.\n我们可以使用式子：\n\n[!claim|*] \\[\\beta\\frac{\\partial u}{\\partial x} \\approx \\beta\\frac{u_i - u_{i-1}}{\\Delta x} \\quad (\\beta &gt; 0) \\quad \\text{(upwind)}\\]\n\n这种差分格式考虑了信息流动的方向，使用”上游”的节点来计算导数，而不是像中心差分那样平等对待上下游节点（注意这个只有一阶精度）。\n\n\n3.3.2 迎风法的稳定性分析 (Stability Analysis)\n接下来，我们来证明迎风方法是稳定的。将迎风差分重写为：\n\\[\\beta\\frac{u_i - u_{i-1}}{\\Delta x} = \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} - \\beta\\frac{u_{i+1}}{2\\Delta x} - \\beta\\frac{2u_i}{2\\Delta x} + \\beta\\frac{u_{i-1}}{2\\Delta x}\\]\n整理一下上式：\n\\[= \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} - \\frac{\\beta\\Delta x}{2} \\cdot \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\\]\n这个表达式可以分解为两项： - 中心差分项 (Central mean): \\(\\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x}\\) - 二阶导数近似项 (Approximation of 2nd derivative): \\(-\\frac{\\beta\\Delta x}{2} \\cdot \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\\)\n这说明迎风方法等价于对原始方程进行中心差分，但增加了一个额外的扩散项（人工扩散，artificial diffusion）。\n\n\n等价表述：扰动方程 (Perturbed Equation)\n因此，我们可以将原始问题的迎风方法看作是下面这个扰动方程的中心差分解法：\n\\[-\\left(\\mu + \\frac{|\\beta|\\Delta x}{2}\\right)\\frac{\\partial^2 u}{\\partial x^2} + \\beta\\frac{\\partial u}{\\partial x} = 0\\]\n对这个扰动方程应用中心差分近似：\n\\[-\\mu\\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} = 0\\]\n这正是原始问题的迎风解法。换句话说： - 对扰动问题使用中心差分 (Central for Perturbed) = 对原始问题使用迎风差分 (Upwind for Original)\n\n[!claim|*] \\[\\text{Central (Perturbed) }= \\text{Upwind (Original)}\\]\n\n这个等价关系揭示了迎风法的本质：它隐含地向原始方程中添加了一个数值扩散项。这个额外的扩散项是迎风法能够抑制数值振荡的关键原因。\n\n\n佩克莱数分析 (Péclet Number Analysis)\n回顾一下佩克莱数的定义：\\(\\text{Pe} = \\frac{|\\beta|\\Delta x}{2\\mu}\\)。\n对于扰动系统，扩散系数变为 \\(\\mu^* = \\mu + \\frac{|\\beta|\\Delta x}{2} = \\mu(1 + \\text{Pe})\\)。\n扰动系统的佩克莱数为：\n\\[\\text{Pe}^* = \\frac{|\\beta|\\Delta x}{2\\mu^*} = \\frac{|\\beta|\\Delta x}{2\\mu(1+\\text{Pe})} = \\frac{\\text{Pe}}{1+\\text{Pe}} &lt; 1 \\quad \\forall |\\beta| \\text{ 和 } \\Delta x\\]\n这表明无论 \\(|\\beta|\\) 和 \\(\\Delta x\\) 的值如何，扰动系统的佩克莱数永远小于1，因此迎风方法始终是稳定的。\n\n\n一致性分析 (Consistency Analysis)\n当 \\(\\Delta x \\to 0\\) 时，\\(\\mu^* \\to \\mu\\)，扰动方程趋近于原始方程，这保证了方法的一致性。\n对于扰动系统，我们使用了二阶精度的中心差分方法，但对于原始问题，由于引入了人工扩散项，它只是一阶精度的方法。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.3 对流-扩散方程"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#详细解释与物理意义",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/9.3 Advection-Diffusion Equation.html#详细解释与物理意义",
    "title": "9.3 对流-扩散方程",
    "section": "详细解释与物理意义",
    "text": "详细解释与物理意义\n迎风方法的核心思想是考虑物理信息的传播方向。在流体流动中，当某点的特性（如温度、浓度）受到上游点的影响更大时，迎风方法使用上游点来计算导数，从而更好地反映物理现实。\n从数值分析的角度看，迎风方法引入了”人工扩散”(artificial diffusion)，增强了数值方法的稳定性。这种人工扩散恰好能够抵消中心差分在高佩克莱数情况下产生的数值振荡。\n然而，这种稳定性是以精度为代价的——迎风方法的精度降低到一阶（误差与 \\(\\Delta x\\) 成正比），而中心差分是二阶精度（误差与 \\(\\Delta x^2\\) 成正比）。这在数值方法中是一个常见的权衡：更高的稳定性往往伴随着更低的精度。\n在对流主导的问题中，稳定性通常比高精度更重要，因为不稳定的解会产生严重的非物理振荡，使结果完全无用。因此，对于高佩克莱数流动，迎风方法尽管精度较低，但往往是更实用的选择。\n更高阶的方法，如TVD (Total Variation Diminishing)、ENO (Essentially Non-Oscillatory) 和 WENO (Weighted Essentially Non-Oscillatory) 方案，试图在保持稳定性的同时提高精度，但它们的实现更为复杂。\nOur previous computation relies on symmetry. However, there is a clear physical information flow. So, this problem is asymmetric in reality. We don’t want as fancy as \\(\\sim \\mathcal{O}(\\Delta x^2)\\) solutions, but we can use a \\(\\sim \\mathcal{O}(\\Delta x)\\) method.\n\\[\\beta\\frac{\\partial u}{\\partial x} \\approx \\beta\\frac{u_i - u_{i-1}}{\\Delta x} \\quad (\\beta &gt; 0) \\quad \\text{(upwind)}\\]\nNow, let’s show (upwind) is stable.\n\\[\\beta\\frac{u_i - u_{i-1}}{\\Delta x} = \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} - \\beta\\frac{u_{i+1}}{2\\Delta x} - \\beta\\frac{2u_i}{2\\Delta x} + \\beta\\frac{u_{i-1}}{2\\Delta x}\\]\n\\[= \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} - \\frac{\\beta\\Delta x}{2} \\cdot \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}\\]\nCentral mean \\(\\quad\\) Approx. of 2nd derivative\nSo, we can consider the equation: \\[-\\left(\\mu + \\frac{|\\beta|\\Delta x}{2}\\right)\\frac{\\partial^2 u}{\\partial x^2} + \\beta\\frac{\\partial u}{\\partial x} = 0\\]\nApply a central approximation: \\[-\\mu\\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\beta\\frac{u_{i+1} - u_{i-1}}{2\\Delta x} = 0\\]\nUpwind solution of the original problem.\nRecall Péclet: \\(Pe = \\frac{|\\beta|\\Delta x}{2\\mu}\\). Then, \\(\\mu^* = \\mu(1 + Pe)\\).\nPéclet of this perturbed system: \\[Pe^* = \\frac{|\\beta|\\Delta x}{2\\mu^*} = \\frac{|\\beta|\\Delta x}{2\\mu(1+Pe)} = \\frac{Pe}{1+Pe} &lt; 1 \\quad \\forall |\\beta| \\text{ and } \\Delta x\\]\nSo, this upwind method is always stable.\nConsistency: when \\(\\Delta x \\to 0\\), \\(\\mu^* \\to \\mu\\).\nFor the perturbed system, we have a 2nd order approach, but with the original problem, it is only a 1st order method.\n\n3.4 Design a Better Method\n\\[\\mu^{smart} = \\mu(1 + \\Phi(Pe))\\]\ns.t. 1. \\(\\Phi(Pe) \\to 0 \\quad \\text{as} \\quad \\Delta x \\to 0\\) 2. \\(Pe^{smart} = \\frac{|\\beta|\\Delta x}{2\\mu^{smart}} &lt; 1\\)\nOur upwind method takes \\(\\Phi(Pe) = Pe \\sim \\mathcal{O}(\\Delta x)\\). But can we take some \\(\\Phi(Pe) \\sim \\mathcal{O}(\\Delta x^2)\\)?\n\\(\\Rightarrow\\) Scharfetter-Gummel Method: \\(\\Phi(Pe) = Pe - 1 + \\frac{2Pe}{e^{2Pe} - 1}\\)\n\\(\\Phi(Pe) \\uparrow\\)\n\\(\\Phi(Pe) = Pe\\)\n\\(\\Phi(Pe) \\sim \\mathcal{O}(\\Delta x)\\)\nThe worst case order of Scharfetter-Gummel is \\(\\sim \\mathcal{O}(\\Delta x^2)\\).\nScharfetter-Gummel is also a special \\(\\Phi(Pe)\\) that produces exact solutions.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "9.3 对流-扩散方程"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html",
    "title": "习题",
    "section": "",
    "text": "We wish to discretize and solve the boundary-value problem\n\\[-\\mu\\frac{d^2u}{dx^2} + \\beta\\frac{du}{dx} = f(x),\\quad x\\in(0,1),\\quad u(0)=u(1)=0\\]\nOr equivalently:\n\\[\\begin{cases}\n-\\mu u''(x) + \\beta u'(x) = f(x), & 0&lt;x&lt;1,\\\\\nu(0)=0,\\; u(1)=0.\n\\end{cases}\\]\nWhere \\(\\mu&gt;0\\) and \\(\\beta\\) is a constant (possibly negative), and \\(f\\in C^0(0,1)\\).\n\n\nDivide \\([0,1]\\) into \\(N\\) equal subintervals so that \\(\\Delta x = \\frac{1}{N}\\). Let\n\\[x_j = j\\Delta x,\\quad j=0,1,2,\\dots,N,\\]\nso that \\(x_0=0\\) and \\(x_N=1\\). We approximate \\(u(x_j)\\approx u_j\\). The boundary conditions become \\(u_0=0\\) and \\(u_N=0\\).\n\n\nA standard centered second-difference for \\(u''(x)\\) at \\(x_j\\) is:\n\\[u''(x_j) \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}.\\]\nA standard centered first-difference for \\(u'(x)\\) at \\(x_j\\) is:\n\\[u'(x_j) \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}.\\]\nHence, the PDE \\(-\\mu u''(x) + \\beta u'(x)=f(x)\\) becomes for \\(j=1,\\dots,N-1\\):\n\\[-\\mu\\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} = f(x_j).\\]\nWe impose \\(u_0 = 0\\) and \\(u_N=0\\).\n\n\n\n\n\nThe second-order central difference for \\(u''\\) is \\(O((\\Delta x)^2)\\) accurate.\nThe central difference for \\(u'\\) is also \\(O((\\Delta x)^2)\\) accurate.\n\nHence the local truncation error of the combined scheme is \\(O((\\Delta x)^2)\\).\n\n\n\nCollect unknowns \\(u_1,u_2,\\dots,u_{N-1}\\) into a vector \\(\\mathbf{u}=(u_1,\\dots,u_{N-1})^T\\). The boundary values \\(u_0=0\\) and \\(u_N=0\\) are known.\nRewrite the finite-difference equation for an interior index \\(j\\):\n\\[-\\mu\\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} = f(x_j).\\]\nWe can factor out coefficients: - Let \\(\\alpha \\equiv \\frac{\\mu}{(\\Delta x)^2}\\). - Let \\(\\gamma \\equiv \\frac{\\beta}{2\\Delta x}\\).\nThen the coefficient of \\(u_j\\) is \\(2\\alpha\\), the coefficient of \\(u_{j+1}\\) is \\(-\\alpha + \\gamma\\), and the coefficient of \\(u_{j-1}\\) is \\(-\\alpha - \\gamma\\). Thus, in matrix form:\n\\[\\begin{pmatrix}\n2\\alpha & -\\alpha+\\gamma & 0 & \\cdots & 0\\\\\n-\\alpha-\\gamma & 2\\alpha & -\\alpha+\\gamma & \\cdots & 0\\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots\\\\\n\\vdots & & -\\alpha-\\gamma & 2\\alpha & -\\alpha+\\gamma\\\\\n0 & \\cdots & 0 & -\\alpha-\\gamma & 2\\alpha\n\\end{pmatrix}\n\\begin{pmatrix}\nu_1\\\\ u_2\\\\ \\vdots \\\\ u_{N-2}\\\\ u_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf(x_1)\\\\ f(x_2)\\\\ \\vdots \\\\ f(x_{N-2})\\\\ f(x_{N-1})\n\\end{pmatrix}.\\]\nThis is a tridiagonal linear system, solvable by standard methods (e.g., Thomas algorithm).\n\n\n\nThe ratio \\(\\frac{\\beta}{\\mu}\\) often plays the role of a Péclet-type number in advection-diffusion problems.\n\nIf \\(\\frac{\\beta}{\\mu}\\) is small (diffusion-dominated), the solution is usually smooth and well-behaved under central differencing.\nIf \\(\\frac{\\beta}{\\mu}\\) is large (advection-dominated), pure central differences may produce spurious oscillations unless \\(\\Delta x\\) is refined or upwinding techniques are used to stabilize the discrete solution.\n\n\n\n\nWhen \\(\\beta&lt;0\\), the “flow” is from right to left, so an upwind difference for the first derivative \\(\\beta u'(x)\\) uses values on the “right” side at each \\(j\\). Concretely, for \\(\\beta&lt;0\\), we replace:\n\\[u'(x_j) \\approx \\frac{u_{j+1} - u_j}{\\Delta x} \\quad \\text{(a \"backward\" upwind if flow is leftward)}.\\]\nHence, the difference equation becomes:\n\\[-\\mu\\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1} - u_j}{\\Delta x} = f(x_j), \\quad j=1,\\dots,N-1.\\]\n(This replaces the central difference in the advective term by a one-sided upwind difference.)\n\n\nThe first-order upwind scheme for linear advection-diffusion is known to be monotone for any \\(\\Delta x&gt;0\\) when \\(\\beta&lt;0\\) (or, more generally, for any sign of \\(\\beta\\) if we choose the correct upwind direction). Monotonicity prevents nonphysical oscillations. In short:\n\nCentral difference can oscillate if \\(|\\beta|\\) is large relative to \\(\\mu\\).\nUpwind difference sacrifices some accuracy (only first order in \\(\\Delta x\\) for the advective term) but remains stable and nonoscillatory for any step size \\(\\Delta x\\).\n\nThus, with \\(\\beta&lt;0\\), the upwind approach \\(u'(x_j)\\approx (u_{j+1}-u_j)/\\Delta x\\) ensures a stable, physically plausible solution without oscillations.\n\n\n\n\n\nEquation & Discretization\n\\[-\\mu u'' + \\beta u' = f(x), \\quad u(0)=u(1)=0 \\longrightarrow \\begin{cases}\n-\\mu\\frac{u_{j+1}-2u_j+u_{j-1}}{(\\Delta x)^2} +\\beta\\frac{u_{j+1}-u_{j-1}}{2\\Delta x} = f(x_j),\\\\\nu_0=0,\\;u_N=0.\n\\end{cases}\\]\nLocal Truncation Error is \\(O((\\Delta x)^2)\\) for the centered scheme.\nMatrix Form: A standard tridiagonal system with bands \\(-\\alpha\\mp \\gamma\\), \\(2\\alpha\\), \\(-\\alpha\\pm \\gamma\\).\nEffect of \\(\\beta/\\mu\\): If \\(|\\beta|\\) is large relative to \\(\\mu\\), central differences can produce oscillatory solutions; upwind methods help.\nUpwind Method (for \\(\\beta&lt;0\\)): \\[-\\mu\\frac{u_{j+1}-2u_j+u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1}-u_j}{\\Delta x} = f(x_j)\\] prevents oscillations for any \\(\\Delta x\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#finite-difference-discretization",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#finite-difference-discretization",
    "title": "习题",
    "section": "",
    "text": "Divide \\([0,1]\\) into \\(N\\) equal subintervals so that \\(\\Delta x = \\frac{1}{N}\\). Let\n\\[x_j = j\\Delta x,\\quad j=0,1,2,\\dots,N,\\]\nso that \\(x_0=0\\) and \\(x_N=1\\). We approximate \\(u(x_j)\\approx u_j\\). The boundary conditions become \\(u_0=0\\) and \\(u_N=0\\).\n\n\nA standard centered second-difference for \\(u''(x)\\) at \\(x_j\\) is:\n\\[u''(x_j) \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}.\\]\nA standard centered first-difference for \\(u'(x)\\) at \\(x_j\\) is:\n\\[u'(x_j) \\approx \\frac{u_{j+1} - u_{j-1}}{2\\Delta x}.\\]\nHence, the PDE \\(-\\mu u''(x) + \\beta u'(x)=f(x)\\) becomes for \\(j=1,\\dots,N-1\\):\n\\[-\\mu\\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} = f(x_j).\\]\nWe impose \\(u_0 = 0\\) and \\(u_N=0\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#local-truncation-error",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#local-truncation-error",
    "title": "习题",
    "section": "",
    "text": "The second-order central difference for \\(u''\\) is \\(O((\\Delta x)^2)\\) accurate.\nThe central difference for \\(u'\\) is also \\(O((\\Delta x)^2)\\) accurate.\n\nHence the local truncation error of the combined scheme is \\(O((\\Delta x)^2)\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#matrix-form",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#matrix-form",
    "title": "习题",
    "section": "",
    "text": "Collect unknowns \\(u_1,u_2,\\dots,u_{N-1}\\) into a vector \\(\\mathbf{u}=(u_1,\\dots,u_{N-1})^T\\). The boundary values \\(u_0=0\\) and \\(u_N=0\\) are known.\nRewrite the finite-difference equation for an interior index \\(j\\):\n\\[-\\mu\\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1} - u_{j-1}}{2\\Delta x} = f(x_j).\\]\nWe can factor out coefficients: - Let \\(\\alpha \\equiv \\frac{\\mu}{(\\Delta x)^2}\\). - Let \\(\\gamma \\equiv \\frac{\\beta}{2\\Delta x}\\).\nThen the coefficient of \\(u_j\\) is \\(2\\alpha\\), the coefficient of \\(u_{j+1}\\) is \\(-\\alpha + \\gamma\\), and the coefficient of \\(u_{j-1}\\) is \\(-\\alpha - \\gamma\\). Thus, in matrix form:\n\\[\\begin{pmatrix}\n2\\alpha & -\\alpha+\\gamma & 0 & \\cdots & 0\\\\\n-\\alpha-\\gamma & 2\\alpha & -\\alpha+\\gamma & \\cdots & 0\\\\\n0 & \\ddots & \\ddots & \\ddots & \\vdots\\\\\n\\vdots & & -\\alpha-\\gamma & 2\\alpha & -\\alpha+\\gamma\\\\\n0 & \\cdots & 0 & -\\alpha-\\gamma & 2\\alpha\n\\end{pmatrix}\n\\begin{pmatrix}\nu_1\\\\ u_2\\\\ \\vdots \\\\ u_{N-2}\\\\ u_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nf(x_1)\\\\ f(x_2)\\\\ \\vdots \\\\ f(x_{N-2})\\\\ f(x_{N-1})\n\\end{pmatrix}.\\]\nThis is a tridiagonal linear system, solvable by standard methods (e.g., Thomas algorithm).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#quality-of-the-solution-vs.-betamu",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#quality-of-the-solution-vs.-betamu",
    "title": "习题",
    "section": "",
    "text": "The ratio \\(\\frac{\\beta}{\\mu}\\) often plays the role of a Péclet-type number in advection-diffusion problems.\n\nIf \\(\\frac{\\beta}{\\mu}\\) is small (diffusion-dominated), the solution is usually smooth and well-behaved under central differencing.\nIf \\(\\frac{\\beta}{\\mu}\\) is large (advection-dominated), pure central differences may produce spurious oscillations unless \\(\\Delta x\\) is refined or upwinding techniques are used to stabilize the discrete solution.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#upwind-method-first-order-for-beta0",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#upwind-method-first-order-for-beta0",
    "title": "习题",
    "section": "",
    "text": "When \\(\\beta&lt;0\\), the “flow” is from right to left, so an upwind difference for the first derivative \\(\\beta u'(x)\\) uses values on the “right” side at each \\(j\\). Concretely, for \\(\\beta&lt;0\\), we replace:\n\\[u'(x_j) \\approx \\frac{u_{j+1} - u_j}{\\Delta x} \\quad \\text{(a \"backward\" upwind if flow is leftward)}.\\]\nHence, the difference equation becomes:\n\\[-\\mu\\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1} - u_j}{\\Delta x} = f(x_j), \\quad j=1,\\dots,N-1.\\]\n(This replaces the central difference in the advective term by a one-sided upwind difference.)\n\n\nThe first-order upwind scheme for linear advection-diffusion is known to be monotone for any \\(\\Delta x&gt;0\\) when \\(\\beta&lt;0\\) (or, more generally, for any sign of \\(\\beta\\) if we choose the correct upwind direction). Monotonicity prevents nonphysical oscillations. In short:\n\nCentral difference can oscillate if \\(|\\beta|\\) is large relative to \\(\\mu\\).\nUpwind difference sacrifices some accuracy (only first order in \\(\\Delta x\\) for the advective term) but remains stable and nonoscillatory for any step size \\(\\Delta x\\).\n\nThus, with \\(\\beta&lt;0\\), the upwind approach \\(u'(x_j)\\approx (u_{j+1}-u_j)/\\Delta x\\) ensures a stable, physically plausible solution without oscillations.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#summary",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#summary",
    "title": "习题",
    "section": "",
    "text": "Equation & Discretization\n\\[-\\mu u'' + \\beta u' = f(x), \\quad u(0)=u(1)=0 \\longrightarrow \\begin{cases}\n-\\mu\\frac{u_{j+1}-2u_j+u_{j-1}}{(\\Delta x)^2} +\\beta\\frac{u_{j+1}-u_{j-1}}{2\\Delta x} = f(x_j),\\\\\nu_0=0,\\;u_N=0.\n\\end{cases}\\]\nLocal Truncation Error is \\(O((\\Delta x)^2)\\) for the centered scheme.\nMatrix Form: A standard tridiagonal system with bands \\(-\\alpha\\mp \\gamma\\), \\(2\\alpha\\), \\(-\\alpha\\pm \\gamma\\).\nEffect of \\(\\beta/\\mu\\): If \\(|\\beta|\\) is large relative to \\(\\mu\\), central differences can produce oscillatory solutions; upwind methods help.\nUpwind Method (for \\(\\beta&lt;0\\)): \\[-\\mu\\frac{u_{j+1}-2u_j+u_{j-1}}{(\\Delta x)^2} + \\beta\\frac{u_{j+1}-u_j}{\\Delta x} = f(x_j)\\] prevents oscillations for any \\(\\Delta x\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#derivation-of-the-laxwendroff-scheme",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#derivation-of-the-laxwendroff-scheme",
    "title": "习题",
    "section": "1) Derivation of the Lax–Wendroff Scheme",
    "text": "1) Derivation of the Lax–Wendroff Scheme\nA succinct way to derive Lax–Wendroff is via a second-order Taylor expansion in time about \\(t^n\\):\n\\[u^{n+1}_i \\;\\approx\\; u(x_i,\\,t_n + \\Delta t)\n\\;=\\;\nu(x_i,t_n)\n\\;+\\;\\Delta t\\,\\frac{\\partial u}{\\partial t}\n\\;+\\;\\tfrac{(\\Delta t)^2}{2}\\,\\frac{\\partial^2 u}{\\partial t^2}\\;\\bigg|_{(x_i,t_n)}.\\]\nFrom the PDE \\(\\partial_t u = -\\,a\\,\\partial_x u\\), we can replace time-derivatives by spatial derivatives:\n\nFirst derivative in time: \\[\\frac{\\partial u}{\\partial t}\n\\;=\\;\n-\\,a\\,\\frac{\\partial u}{\\partial x}.\\]\nSecond derivative in time: \\[\\frac{\\partial^2 u}{\\partial t^2}\n\\;=\\;\n\\frac{\\partial}{\\partial t}\\Bigl(-\\,a\\,\\frac{\\partial u}{\\partial x}\\Bigr)\n\\;=\\;\n-\\,a\\,\\frac{\\partial}{\\partial x}\\Bigl(\\frac{\\partial u}{\\partial t}\\Bigr)\n\\;=\\;\n-\\,a\\,\\frac{\\partial}{\\partial x}\\Bigl(-\\,a\\,\\frac{\\partial u}{\\partial x}\\Bigr)\n\\;=\\;\na^2\\,\\frac{\\partial^2 u}{\\partial x^2}.\\]\n\nHence,\n\\[u^{n+1}_i\n\\;\\approx\\;\nu^{n}_i\n\\;-\\;\na\\,\\Delta t \\,\\frac{\\partial u}{\\partial x}\n\\;+\\;\n\\frac{a^2(\\Delta t)^2}{2}\\,\\frac{\\partial^2 u}{\\partial x^2}\n\\;\\Bigg|_{(x_i,t_n)}.\\]\n\nDiscretizing the spatial derivatives\nWe replace the first and second spatial derivatives by standard centered finite differences:\n\\[\\frac{\\partial u}{\\partial x}\\bigg|_{x_i}\n\\approx\n\\frac{u_{i+1}^n - u_{i-1}^n}{2\\,\\Delta x},\n\\qquad\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_i}\n\\approx\n\\frac{u_{i+1}^n - 2\\,u_i^n + u_{i-1}^n}{(\\Delta x)^2}.\\]\nPutting this all together:\n\\[u_{i}^{n+1}\n\\;=\\;\nu_{i}^{n}\n\\;-\\;\na\\,\\Delta t \\,\\frac{u_{i+1}^{n} - u_{i-1}^{n}}{2\\,\\Delta x}\n\\;+\\;\n\\frac{a^2\\,(\\Delta t)^2}{2}\\,\n\\frac{u_{i+1}^{n} - 2\\,u_{i}^{n} + u_{i-1}^{n}}{(\\Delta x)^2}.\\]\nIt is common to set \\(\\displaystyle \\nu \\;=\\;\\frac{a\\,\\Delta t}{\\Delta x}\\). Then the scheme reads\n\\[\\boxed{\nu_{i}^{n+1}\n\\;=\\;\nu_{i}^{n}\n\\;-\\;\\frac{\\nu}{2}\\,\\bigl(u_{i+1}^{n} - u_{i-1}^{n}\\bigr)\n\\;+\\;\\frac{\\nu^{2}}{2}\\,\n\\bigl(u_{i+1}^{n} \\;-\\;2\\,u_{i}^{n} \\;+\\;u_{i-1}^{n}\\bigr).\n}\\]\nThis is the Lax–Wendroff scheme for the linear advection equation.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#the-cfl-stability-condition",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#the-cfl-stability-condition",
    "title": "习题",
    "section": "2) The CFL Stability Condition",
    "text": "2) The CFL Stability Condition\nA standard von Neumann (Fourier) stability analysis, or the usual Lax–Richtmyer theory for hyperbolic PDEs, shows that Lax–Wendroff is stable if and only if the Courant number satisfies\n\\[\\bigl|\\,\\nu\\,\\bigr|\n\\;=\\;\n\\biggl|\\frac{a\\,\\Delta t}{\\Delta x}\\biggr|\n\\;\\le\\;\n1.\\]\nTherefore among the multiple-choice options, the correct condition is\n\\[\\boxed{\\;\\; \\bigl|\\tfrac{a\\,\\Delta t}{\\Delta x}\\bigr| \\;\\le\\; 1.}\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#motivation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#motivation",
    "title": "习题",
    "section": "3) Motivation",
    "text": "3) Motivation\n\nDomain of dependence argument. For the PDE \\(\\partial_t u + a\\,\\partial_x u = 0,\\) characteristics travel with speed \\(a\\). Numerically, we must ensure that information from these characteristics is captured on the grid from one time step to the next; that is the essence of the CFL condition. If \\(|a|\\Delta t &gt; \\Delta x\\), the method “jumps over” grid cells and fails to remain stable.\nVon Neumann analysis. Substituting \\(u_i^n = \\lambda^n e^{ikx_i}\\) into the scheme shows that the amplification factor \\(|\\lambda|\\) is \\(\\le 1\\) if and only if \\(\\bigl|\\frac{a\\Delta t}{\\Delta x}\\bigr|\\le 1.\\)\n\nHence the short answer is: 1. Lax–Wendroff has the form \\[u_{i}^{n+1}\n   =\n   u_{i}^{n}\n   -\n   \\frac{\\nu}{2}\\,(u_{i+1}^{n} - u_{i-1}^{n})\n   +\n   \\frac{\\nu^{2}}{2}\\,(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}),\\] 2. The method is stable if and only if \\(\\displaystyle \\bigl|\\frac{a\\Delta t}{\\Delta x}\\bigr|\\le 1.\\) 3. This condition is exactly the usual CFL requirement ensuring the numerical domain of dependence covers the PDE’s domain of dependence.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#the-cranknicolson-discretization",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#the-cranknicolson-discretization",
    "title": "习题",
    "section": "1. The Crank–Nicolson Discretization",
    "text": "1. The Crank–Nicolson Discretization\nLet \\(\\Delta x = \\frac{1}{M}\\) partition \\([0,1]\\) into \\(M+1\\) grid points \\(x_i = i\\,\\Delta x\\), \\(i=0,\\dots,M\\), and let \\(\\Delta t\\) be a time step, so \\(t^n = n\\,\\Delta t\\). We write \\(u_i^n\\approx u(x_i,t^n)\\). The standard second‐order central difference for \\(u_{xx}\\) is\n\\[u_{xx}(x_i,t^n)\n\\;\\approx\\;\n\\frac{u_{i+1}^n - 2\\,u_i^n + u_{i-1}^n}{(\\Delta x)^2}.\\]\nA \\(\\theta\\)‐method (also called the \\(\\theta\\)-scheme) for \\(u_t = u_{xx} + f\\) in time is:\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n\\;=\\;\n\\theta\\Bigl[\\underbrace{\\tfrac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2} \\;+\\; f_i^{n+1}}_{\\text{“implicit” part}}\\Bigr]\n\\;+\\;\n\\bigl(1-\\theta\\bigr)\\Bigl[\\underbrace{\\tfrac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{(\\Delta x)^2}\\;+\\; f_i^{n}}_{\\text{“explicit” part}}\\Bigr].\\]\nCrank–Nicolson is the special case \\(\\theta = \\tfrac12\\). Substituting \\(\\theta=\\tfrac12\\), we get\n\\[\\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n\\;=\\;\n\\tfrac12\\Bigl[\\tfrac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2} + f_i^{n+1}\\Bigr]\n\\;+\\;\n\\tfrac12\\Bigl[\\tfrac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{(\\Delta x)^2} + f_i^n\\Bigr].\\]\nRearranging terms gives \\[u_i^{n+1}\n\\;-\\;\n\\frac{\\Delta t}{2\\,(\\Delta x)^2}\\,\\bigl(u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}\\bigr)\n\\;=\\;\nu_i^{n}\n\\;+\\;\n\\frac{\\Delta t}{2\\,(\\Delta x)^2}\\,\\bigl(u_{i+1}^{n} - 2u_i^n + u_{i-1}^{n}\\bigr)\n\\;+\\;\n\\frac{\\Delta t}{2}\\,\\bigl(f_i^{n+1} + f_i^n\\bigr).\\] One may think of this as the linear system \\[\\bigl[I + \\tfrac{\\Delta t}{2\\,(\\Delta x)^2}\\,A\\bigr]\\,\\mathbf{u}^{n+1}\n\\;=\\;\n\\bigl[I - \\tfrac{\\Delta t}{2\\,(\\Delta x)^2}\\,A\\bigr]\\,\\mathbf{u}^{n}\n\\;+\\;\\frac{\\Delta t}{2}\\,\\bigl(\\mathbf{f}^{n+1} + \\mathbf{f}^n\\bigr),\\] where \\(A\\) is the usual tridiagonal matrix corresponding to the second‐difference operator (and where \\(\\mathbf{u}^n\\) is the vector of \\(u_i^n\\)). After applying boundary conditions \\(u_0^n = u_M^n = 0\\), one solves this tridiagonal system at each time step.\n\nBoundary Conditions\nBecause \\(u(0,t)=u(1,t)=0\\), we set \\(u_0^n=0\\) and \\(u_M^n=0\\) for all \\(n\\). The updates are applied only for \\(i=1,\\dots,M-1\\).\n\n\nSummary of the CN Update\nIn “index form,” the Crank–Nicolson scheme is: \\[\\boxed{\n\\begin{aligned}\n&\\text{For }i=1,\\dots,M-1:\\quad\nu_i^{n+1}\n\\;-\\;\n\\tfrac{\\Delta t}{2\\,(\\Delta x)^2}\\,\\bigl(u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}\\bigr)\n\\\\\n&\\qquad\\quad\\;=\\;\nu_i^{n}\n\\;+\\;\n\\tfrac{\\Delta t}{2\\,(\\Delta x)^2}\\,\\bigl(u_{i+1}^{n} - 2u_i^n + u_{i-1}^{n}\\bigr)\n\\;+\\;\\frac{\\Delta t}{2}\\,\\bigl(f_i^{n+1} + f_i^n\\bigr).\n\\end{aligned}\n}\\] This is solved simultaneously for all \\(i\\), respecting \\(u_0^{n+1}=u_M^{n+1}=0\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#properties-stability-accuracy",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#properties-stability-accuracy",
    "title": "习题",
    "section": "2. Properties: Stability & Accuracy",
    "text": "2. Properties: Stability & Accuracy\n\nStability:\n\nUnconditional stability for the heat equation. In other words, there is no restriction on \\(\\Delta t\\) relative to \\(\\Delta x\\) needed solely for stability (unlike the explicit forward‐Euler method, which requires \\(\\Delta t \\le \\tfrac12 (\\Delta x)^2\\)).\n\nMore precisely, CN is A‐stable as an ODE solver applied to the linear diffusion operator. One can show by a von Neumann analysis or standard Lax–Richtmyer theory that errors do not grow unboundedly for any \\(\\Delta t&gt;0\\).\n\nAccuracy:\n\nIn time, Crank–Nicolson is second‐order accurate, because it is essentially the trapezoidal rule in time (it uses \\(\\frac12\\) of the “new” time‐level’s spatial derivative plus \\(\\frac12\\) of the “old” time‐level’s spatial derivative).\n\nIn space, if we use the standard second‐difference approximation, the scheme is also second‐order in \\(\\Delta x\\).\n\nOverall, we often say “CN is second‐order in both space and time (for sufficiently smooth solutions).”",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#bonus-discontinuous-initial-condition",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#bonus-discontinuous-initial-condition",
    "title": "习题",
    "section": "3. BONUS: Discontinuous Initial Condition",
    "text": "3. BONUS: Discontinuous Initial Condition\nEven if \\(u_0(x)\\) is not continuous, the heat equation itself is smoothing: for \\(t&gt;0\\), the exact solution becomes infinitely differentiable in \\(x\\). Numerically:\n\nThe scheme remains stable and convergent.\n\nBecause it is a diffusion‐type PDE, any jump discontinuity in the initial data gets smoothed out instantly as \\(t\\) increases.\n\nCrank–Nicolson will faithfully capture that smoothing. You may see large gradients at early time steps near the discontinuity, but the method will not become unstable.\n\nHence having a discontinuous initial condition does not cause instability for the heat equation with Crank–Nicolson. The scheme still converges (second‐order in both space and time) to the unique smooth solution that the parabolic PDE defines for \\(t&gt;0\\).",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#建立网格",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#建立网格",
    "title": "习题",
    "section": "1. 建立网格",
    "text": "1. 建立网格\n令 \\(N_x\\) 和 \\(N_y\\) 分别表示在 \\(x\\) 和 \\(y\\) 方向上的网格划分数目（仅指内部节点数，不含边界），则步长为 \\[\\delta x \\;=\\;\\frac{1}{N_x+1},\n\\quad\n\\delta y \\;=\\;\\frac{1}{N_y+1}.\\] 我们在区间 \\([0,1]\\times[0,1]\\) 内取离散网格点 \\[x_i \\;=\\; i\\,\\delta x,\n\\quad\ny_j \\;=\\; j\\,\\delta y,\\] 其中 \\(i=0,1,2,\\dots,N_x+1\\), \\(j=0,1,2,\\dots,N_y+1\\)。\n在内部节点 \\((x_i,y_j)\\) 上，我们用 \\(u_{i,j}\\) 表示对真解 \\(u(x_i,y_j)\\) 的数值近似。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#五点差分格式",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#五点差分格式",
    "title": "习题",
    "section": "2. 五点差分格式",
    "text": "2. 五点差分格式\n方程 \\(-\\Delta u = f\\) 可写成 \\[-\\left(\n\\frac{\\partial^2 u}{\\partial x^2}\n\\;+\\;\n\\frac{\\partial^2 u}{\\partial y^2}\n\\right)\n\\;=\\;\nf,\\] 即 \\[\\frac{\\partial^2 u}{\\partial x^2}\n\\;+\\;\n\\frac{\\partial^2 u}{\\partial y^2}\n\\;=\\;\n-\\,f.\\]\n在网格上，二阶导数的中心差分近似分别为：\n\n在 \\(x\\) 方向： \\[\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i,y_j)}\n\\;\\approx\\;\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\delta x)^2},\\]\n在 \\(y\\) 方向： \\[\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i,y_j)}\n\\;\\approx\\;\n\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\delta y)^2}.\\]\n\n因此，\\(\\Delta u\\) 在离散化后可写为 \\[\\Delta u_{i,j}\n\\;=\\;\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\delta x)^2}\n\\;+\\;\n\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\delta y)^2}.\\]\n由于方程是 \\(-\\Delta u = f\\)，则对应的五点差分格式为\n\\[-\\left[\\,\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\delta x)^2}\n\\;+\\;\n\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\delta y)^2}\n\\right]\n\\;=\\;\nf_{i,j},\\] 或等价地写成 \\[\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\delta x)^2}\n\\;+\\;\n\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\delta y)^2}\n\\;=\\;\n-\\,f_{i,j}.\\]\n这里 \\(f_{i,j} = f(x_i,y_j)\\) 表示在网格点处的函数取值。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#精度阶次",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#精度阶次",
    "title": "习题",
    "section": "3. 精度阶次",
    "text": "3. 精度阶次\n上述中心差分格式对二阶导数在空间步长上具有 二阶精度。也就是说，如果我们将 \\(\\delta x\\) 和 \\(\\delta y\\) 同步缩小（假设网格等距），则离散解相对于真解的误差在 \\(\\delta x, \\delta y \\to 0\\) 时满足 \\[\\mathcal{O}\\bigl((\\delta x)^2 + (\\delta y)^2\\bigr).\\]\n简而言之，对拉普拉斯方程采用这种五点中心差分格式，在均匀网格下是二阶精度。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#最终形成的线性方程组",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#最终形成的线性方程组",
    "title": "习题",
    "section": "4. 最终形成的线性方程组",
    "text": "4. 最终形成的线性方程组\n对所有内部节点 \\((i,j)\\)（即 \\(1\\le i\\le N_x\\), \\(1\\le j\\le N_y\\)）应用上述离散方程，我们便得到一个关于所有未知量 \\(\\{u_{i,j}\\}\\) 的线性方程组。若再结合边界条件（例如已知边界上的 \\(u_{0,j},u_{N_x+1,j},u_{i,0},u_{i,N_y+1}\\)），即可完全求解。\n在实际应用中，可以用各种迭代法（如 Jacobi、Gauss-Seidel、SOR 等）或直接法（如 LU 分解等）来求解这个离散方程组。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#总结",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第九章/Exercise.html#总结",
    "title": "习题",
    "section": "5. 总结",
    "text": "5. 总结\n\n五点差分格式的离散方程（在二维情况下）是： \\[\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{(\\delta x)^2}\n\\;+\\;\n\\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{(\\delta y)^2}\n\\;=\\;\n-\\,f_{i,j}.\\]\n在标准的（均匀）网格下，该方法的空间离散精度是二阶。",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第九章",
      "习题"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html",
    "title": "Erise Note",
    "section": "",
    "text": "The order of convergence of finite element:\n\nDenote \\(p\\) as the number of points we use to do Lagrange interpolation\nDenote \\(s\\) as the order of space we search for solution: \\(u \\in H^s(\\Omega)\\)\n\nThe relation is denoted as follows:\n\n\n\n\\(q\\)  \\(s\\)\n1\n2\n3\n\n\n\n\n1\n1\n1\n1\n\n\n2\n1\n2\n2\n\n\n3\n1\n2\n3\n\n\n\noptimal",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#order-of-convergence-in-finite-elements",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#order-of-convergence-in-finite-elements",
    "title": "Erise Note",
    "section": "",
    "text": "The order of convergence of finite element:\n\nDenote \\(p\\) as the number of points we use to do Lagrange interpolation\nDenote \\(s\\) as the order of space we search for solution: \\(u \\in H^s(\\Omega)\\)\n\nThe relation is denoted as follows:\n\n\n\n\\(q\\)  \\(s\\)\n1\n2\n3\n\n\n\n\n1\n1\n1\n1\n\n\n2\n1\n2\n2\n\n\n3\n1\n2\n3\n\n\n\noptimal",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#error-estimation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#error-estimation",
    "title": "Erise Note",
    "section": "Error Estimation",
    "text": "Error Estimation\nWe have:\n\\[||u_{ex} - u_h|| \\leq h^{\\min(s,p)}\\]\nHow to determine which space \\(u_h\\) is in: - If \\(u_h\\), \\(u'_h\\), \\(u''_h\\) \\(\\in L^2(\\Omega)\\) but \\(u'''_h \\not\\in L^2(\\Omega)\\) - We can say the function \\(u_h \\in H^2(\\Omega)\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#finite-element-for-2d-poisson-equation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#finite-element-for-2d-poisson-equation",
    "title": "Erise Note",
    "section": "Finite Element for 2D Poisson Equation",
    "text": "Finite Element for 2D Poisson Equation\n\\[\\begin{cases}\n-\\Delta u = f \\quad \\text{in } \\Omega \\\\\nu = 0 \\quad \\text{on } \\partial\\Omega\n\\end{cases}\\]\n\nWeak Formulation\nLet \\(v \\in H^1_0(\\Omega)\\), then:\n\\[a(u,v) = F(v) \\quad \\forall v \\in V\\]\nwhere:\n\\[a(u,v) = \\int_\\Omega \\nabla u \\cdot \\nabla v \\, dx \\quad \\text{and} \\quad F(v) = \\int_\\Omega f v \\, dx\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#step-2-triangulation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#step-2-triangulation",
    "title": "Erise Note",
    "section": "Step 2: Triangulation",
    "text": "Step 2: Triangulation\nConforming triangulation of \\(\\Omega\\) is a finite family: \\(T_h = \\{K\\}\\)\nRemind: \\(\\Omega = \\cup_{K \\in T_h} K\\) and \\(K \\cap K' = \\emptyset\\) if \\(K \\neq K'\\)\nShould have no overlap and share vertex and edge. - No hanging node.\nFor each element: \\[h_K = \\text{diameter}(K) = \\sup_{x,y \\in K} ||x-y||_2\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#step-3-interpolation",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#step-3-interpolation",
    "title": "Erise Note",
    "section": "Step 3: Interpolation",
    "text": "Step 3: Interpolation\nFor different polynomial orders: - \\(p=1 \\Rightarrow\\) use 3 nodes (corners) - \\(p=2 \\Rightarrow\\) use 6 nodes - \\(p=3 \\Rightarrow\\) use 10 nodes\nThen we have basis functions: - \\(\\phi_{(2,0,0)} = 2\\lambda_1^2\\) - \\(\\phi_{(1,1,0)} = 2\\lambda_1\\lambda_2\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#step-4-map-basis-function-to-physical-triangle",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#step-4-map-basis-function-to-physical-triangle",
    "title": "Erise Note",
    "section": "Step 4: Map Basis Function to Physical Triangle",
    "text": "Step 4: Map Basis Function to Physical Triangle\nDefine \\(\\hat{K} = \\{(\\hat{x}_1, \\hat{x}_2) \\in \\mathbb{R}^2 | \\hat{x}_1, \\hat{x}_2 \\geq 0, \\hat{x}_1+\\hat{x}_2 \\leq 1\\}\\)\n\\(\\hat{\\lambda}_1 = \\hat{x}_1\\), \\(\\hat{\\lambda}_2 = \\hat{x}_2\\), \\(\\hat{\\lambda}_3 = 1-\\hat{x}_1-\\hat{x}_2\\)\nThen we have:\nDefine \\(v_1, v_2, v_3 \\in \\mathbb{R}^2\\) that be triangle \\(K\\)\n\\(x = F_K(\\hat{x}) = A_K\\hat{x} + b_K\\) for\n\\(A_K = (v_1-v_3, v_2-v_3) \\in \\mathbb{R}^{2\\times 2}\\), \\(b_K = v_3\\)\nThen we have: \\(\\phi^K_\\alpha(x) = A_K^{-T} \\hat{\\phi}_\\alpha(F_K^{-1}(x))\\)\nAnd \\(\\nabla x = A_K^T \\nabla_{\\hat{x}}\\)\n\\(F_K\\) can be viewed as:\n\\((\\lambda_1, \\lambda_2, \\lambda_3) = (\\hat{x}_1, \\hat{x}_2, 1-\\hat{x}_1-\\hat{x}_2)\\) define a triangle in canonical coordinate.\nLet \\(v_1 = (x_1, y_1)\\), \\(v_2 = (x_2, y_2)\\), \\(v_3 = (x_3, y_3)\\)\n\\(\\lambda_1, \\lambda_2, \\lambda_3\\) is the solution of:\n\\(x = \\lambda_1 v_1 + \\lambda_2 v_2 + \\lambda_3 v_3\\), \\(\\lambda_1 + \\lambda_2 + \\lambda_3 = 1\\)\nThen \\(\\lambda_1 = \\frac{(x_2-x_3)(y-y_3)-(y_2-y_3)(x-x_3)}{det}\\)\n$_2 = $ same idea\n\\(\\lambda_3 = 1-\\lambda_2-\\lambda_1\\)\n\nBasis Function Properties\n\\(\\phi_{i,j,k}(\\lambda_1, \\lambda_2, \\lambda_3) = \\frac{p!}{i!j!k!} \\lambda_1^i \\lambda_2^j \\lambda_3^k\\)\n\\(\\phi_{i,j,k}^K\\) (at node) = 1 and \\(\\phi_{i,j,k}^K\\) (other node) = 0\n\\(\\phi_{i,j,k}^K\\) (other node) = 0\nThe after the map we have:\n\\(F_K(\\hat{x}) = A_K\\hat{x} + b_K = x\\) … change of variable\nThen \\(F(v) = \\sum_{a=1}^{node} a_i \\phi_i^K(x) \\phi_j^K(x) \\cdot u\\)\nFor which:\n\\[a(\\phi_i^K(x), \\phi_j^K(x)) = \\int \\nabla \\phi_j^K \\nabla \\phi_i^K \\, dx_1dx_2\\]\n\\[= \\int A^{-T} \\nabla \\phi_i \\cdot A^{-T} \\nabla \\phi_j \\cdot |det(A)| \\, d\\hat{x}_1d\\hat{x}_2\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#convection-diffusion-in-1d-finite-element",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#convection-diffusion-in-1d-finite-element",
    "title": "Erise Note",
    "section": "Convection-Diffusion in 1D Finite Element",
    "text": "Convection-Diffusion in 1D Finite Element\n\\[\\frac{\\mu}{2} \\frac{\\partial^2 u}{\\partial x^2} + v \\frac{\\partial u}{\\partial x} = f(x,t) \\quad \\text{for } u(0) = u(L) = 0\\]\nChoose test function and make weak formulation: \\(H_0^1(0,L)\\)\n\\[\\int_0^L (\\frac{\\mu}{2} u_{xx} + v u_x) w \\, dx = \\int_0^L f w \\, dx\\]\n\\[\\frac{\\mu}{2} \\int_0^L u_{xx} \\cdot w \\, dx + v \\int_0^L u_x \\cdot w \\, dx = \\int_0^L f w \\, dx\\]\nFinite element approximation:\n\\[u(x) \\approx u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x)\\]\nWe can plug into weak form:\n\\[\\sum_j \\frac{\\mu}{2} \\int_0^L \\phi_j' \\phi_i' \\, dx \\, U_j + \\sum_j v \\int_0^L \\phi_j' \\phi_i \\, dx \\, U_j = \\int_0^L \\phi_i f \\, dx\\]\n\nExploring the Integral\nSuppose \\(\\phi_i'(x) = \\frac{1}{h}\\), \\(\\phi_{i+1}'(x) = \\frac{1}{h}\\), \\(\\phi_{i-1}'(x) = -\\frac{1}{h}\\)\n\nFor \\(i=j\\): \\[\\int_{x_{i-1}}^{x_i} \\phi_i'^2 = \\frac{1}{h^2} \\text{ on } [x_{i-1}, x_i]\\]\nFor \\(i=j+1\\): \\[\\int_{x_{i-1}}^{x_i} \\phi_i' \\phi_j' = -\\frac{1}{h^2} \\text{ on } [x_{i-1}, x_i]\\]\nFor range \\([x_i, x_{i+1}]\\): \\[\\int_{x_i}^{x_{i+1}} \\phi_i'^2 = \\frac{1}{h^2} \\text{ for } i=j\\] \\[\\int_{x_i}^{x_{i+1}} \\phi_i' \\phi_j' = -\\frac{1}{h^2} \\text{ for } i=j+1\\]\n\nCombine together, we get:\n\\[\\int_{x_{i-1}}^{x_{i+1}} \\phi_i' \\phi_j' = \\frac{2}{h^2} [-1, 2, -1]\\]\nSame idea for \\(\\int \\phi_i' \\phi_j\\) but don’t have \\(v\\) because only have one \\(\\phi_j'\\).\nThen the equation for FEM:\n\\[-\\frac{\\mu}{2} \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + v \\frac{u_{i+1} - u_{i-1}}{2} = 0\\]\n\n\nRemind\n\\(\\frac{1}{\\Delta x}\\) (finite element) = finite difference\n\n\nStability\nWe also require Peclet &lt; 1:\n\\[\\frac{|v| \\Delta x}{2\\mu} &lt; 1\\]",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#reaction-diffusion-problems",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#reaction-diffusion-problems",
    "title": "Erise Note",
    "section": "Reaction-Diffusion Problems",
    "text": "Reaction-Diffusion Problems\nWe can also apply upwind method and we can achieve absolute stability.\n\nReaction-Diffusion Problem\n\\[-\\mu u'' + \\sigma u = f \\quad f \\in L^2(\\Omega)\\]\nFinite difference method:\n\\[-\\mu \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\sigma u_i = f(x_i)\\]\n\\[(A\\mu + \\sigma I) \\cdot u_i = f_i\\]\nThis is absolutely stable.\n\n\nFinite Element Equation\n\\[A_{ij} = \\frac{\\mu}{2} \\int_0^1 \\phi_i' \\phi_j' \\, dx + \\sigma \\int_0^1 \\phi_i \\phi_j \\, dx\\]\n\\[F_i = \\int_0^1 f \\phi_i \\, dx \\quad \\text{then we have } AU = F\\]\nWe can write in this form:\n\\[-\\mu \\cdot \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\frac{\\sigma \\Delta x}{6}(u_{i+1} + 4u_i + u_{i-1}) = \\int f v\\]\nIn this case the Peclet number is:\n\\[\\frac{\\sigma \\Delta x^2}{6\\mu} &lt; 1 \\quad \\Delta x &lt; \\sqrt{\\frac{6\\mu}{\\sigma}} \\ldots \\text{much more acceptable}\\]\n\n\nExplore the Integral\n\\[\\sigma \\int_0^1 \\phi_i \\phi_j = \\begin{cases}\n\\frac{\\sigma}{6}\\Delta x & \\text{if } j = i \\pm 1 \\\\\n\\frac{\\sigma}{3}\\Delta x & \\text{if } j = i\n\\end{cases}\\]\n\n\nMass Lumping Technique\nIdea: treat \\(x_i = x_{i-1} = x_{i+1}\\) [trapezoid rule]\nThen we have:\n\\[\\frac{\\sigma}{6}(u_{i+1} + 4u_i + u_{i-1}) = \\sigma u_i\\]\nAnd equation becomes:\n\\[-\\mu \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2} + \\sigma u_i \\Delta x = \\int f v\\]\nThis method is stable.",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#upwind-method-and-strong-consistency",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/Finite Element Method.html#upwind-method-and-strong-consistency",
    "title": "Erise Note",
    "section": "Upwind Method and Strong Consistency",
    "text": "Upwind Method and Strong Consistency\nBefore we have:\n\\[a(u-u_h, v_h) = 0 \\quad \\text{for } v_h \\in V_h\\]\nHowever if we use upwind method, we lose the strong consistency for Galerkin method:\nWe have:\n\\[a_h(u_h, v_h) = a(u_h, v_h) + \\frac{|B|h}{2\\mu} \\int_0^1 u_h' v_h'\\]\n\\[B_h(u_h) = B(u_h)\\]\nWTF: \\(u_h \\in V_h\\) s.t. \\(a_h(u_h, v_h) = B_h(v_h)\\)\nIf we use mass lumping:\n\\[a_h(u_h, v_h) = a(u_h, v_h) + \\int_0^1 - \\int_0^1 \\text{[trapezoid rule]}\\]\nRemind \\(a_h(u-u_h, v_h) \\neq 0\\) for not strong consistent.\nWe can use general Galerkin method:\n\nStrong Lemma\n\n\\(||u-u_h||_{H^1} \\leq C_1 \\inf_{v_h \\in V_h} ||u-v_h||_{H^1} + C_2 \\inf_{v_h \\in V_h} \\sup_{v_h \\in V_h} \\frac{|a_h(u_h, v_h) - a(u_h, v_h)|}{||v_h||_{V_h}}\\)\n\\(C_3 \\sup_{v_h \\in V_h, v_h \\in V_h} \\frac{|a_h(u_h, v_h) - a(u_h, v_h)|}{||v_h||_{V_h}} \\neq 0\\)\n\\(C_3 \\sup_{v_h \\in V} ||B_h(v_h) - B(v_h)|| \\quad \\text{for } v_h \\to 0\\)\n\n\n\nOrder of Convergence\nUpwind: \\(O(h^p)\\) for \\(p = \\min(s,k)\\)",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章",
      "Order of Convergence in Finite Elements"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/index.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第十章/index.html",
    "title": "第十章",
    "section": "",
    "text": "Order of Convergence in Finite Elements\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolutions for Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第十章"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第四章/index.html",
    "href": "content/notes/理论/偏微分方程/MATH 352 PDE in Action/第四章/index.html",
    "title": "第四章 有限元分析",
    "section": "",
    "text": "无匹配项",
    "crumbs": [
      "Notes",
      "偏微分方程",
      "数值方法",
      "第四章 有限元分析"
    ]
  },
  {
    "objectID": "content/notes/理论/偏微分方程/index.html",
    "href": "content/notes/理论/偏微分方程/index.html",
    "title": "偏微分方程",
    "section": "",
    "text": "1. Ok Honestly I Have No Idea Where He Started\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.1 边值问题的近似\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.2 有限差分法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.3 对流-扩散方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n9.4 4.1 二维（2D）偏微分方程问题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFormula Derivation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHeat Equation Solution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrder of Convergence in Finite Elements\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSolutions for Quiz 4\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n习题\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n傅立叶级数\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n常微分方程的数值解\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n拉普拉斯方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数值方法\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n波方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n热方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第九章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第十章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第四章 有限元分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "偏微分方程"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/Homework 11.html",
    "href": "content/notes/理论/实分析/Homework/Homework 11.html",
    "title": "Erise Note",
    "section": "",
    "text": "HW 11: 9.2: 1, [2], 3, 4; 9.3: [5]; 9.4: 1, [2], 3; 9.5: 1, [2], 3, 4, [5]; Chapter 9: 1, 3, 5(a,b,c, [d]), 7, 10.",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II",
      "Homework 11"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/Homework 7.html",
    "href": "content/notes/理论/实分析/Homework/Homework 7.html",
    "title": "Erise Note",
    "section": "",
    "text": "HW 7: 7.6: 1, 2, 3, [4,5]; 7.7: 1, 2, 3, [4], 5, [6]; Chapter 7: [25], 36, [38], 39.\nProblem 7.6.4 Let \\(f(x,y) = x^2 + y^2 + 3y^3 + 8x^4 + x^2e^x \\sin x + 6\\). Show that there exist new coordinates \\(\\xi, \\eta\\), where \\[\\xi = \\xi(x,y), \\quad \\eta = \\eta(x,y),\\] for which \\[f(x,y) = \\xi^2 + \\eta^2 + 6\\] in a neighborhood of \\((0, 0)\\).\nProblem 7.6.5 (a). If \\(f\\) has a nondegenerate critical point at \\(x_0 \\in \\mathbb{R}^n\\), show that there is a neighborhood of \\(x_0\\) containing no other critical points.\n(b). What are the critical points of the function \\(f(x,y) = x^2y^2\\)?\nProblem 7.7.4. \\(f(x, y, z) = x + y + z, x^2 - y^2 = 1, 2x + z = 1\\).\nProblem 7.7.6. Supranational Sludge Corporation produces sludge using equipment and material costing \\(p = \\$243\\) per unit and labor at a wage of \\(w = \\$16\\) per hour. If \\(x\\) units of equipment/material and \\(y\\) hours of labor are used, then \\(20x^{3/4}y^{1/4}\\) liters of sludge are produced. If the company has a budget of \\(B = \\$51,840,000\\) to spend, find the maximum amount of sludge that can be produced and the amounts of equipment/material and of labor used to produce it.\nProblem 7.25\nLet \\(B(0, r) = \\{x \\in \\mathbb{R}^n \\mid \\|x\\| \\leq r\\}\\). Let \\(f : B(0, r) \\to \\mathbb{R}^n\\) be a map with\n\n\\(\\|f(x) - f(y)\\| \\leq \\frac{1}{3}\\|x - y\\|\\)\n\\(\\|f(0)\\| \\leq \\frac{2}{3}r\\)\n\nProve that there is a unique \\(x \\in B(0, r)\\) such that \\(f(x) = x\\).\nProblem 7.38\nA rectangular box with no top is to have a surface area of 16 square meters. Find the dimensions that maximize the volume.",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II",
      "Homework 7"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/Homework/Homework 9.html",
    "href": "content/notes/理论/实分析/Homework/Homework 9.html",
    "title": "Erise Note",
    "section": "",
    "text": "8.5: 1, [2, 3], 4, [5]; Chapter 8: [21, 22].\nProblem 8.5.2 Establish formula \\(\\mathbf{c}\\) of Example 8.5.7 as follows. Prove that \\(e^{-x} x^{p+2} \\rightarrow 0\\) as \\(x \\rightarrow \\infty\\), and then compare the integral with \\(\\int_1^{\\infty}\\left(1 / x^2\\right) d x\\).\n\n[!definition|*]\nLet \\(\\epsilon &gt; 0\\) be arbitrary. We want to show that \\(\\exists N &gt; 0\\) such that for all \\(x &gt; N\\),\n\\[\\left|e^{-x}x^{p+2} - 0\\right| = e^{-x}x^{p+2} &lt; \\epsilon.\\] Since \\(e^{-x}x^{p+2} = \\exp\\Bigl(-x + (p+2)\\ln x\\Bigr)\\), and \\(\\displaystyle\\lim_{x\\to\\infty}\\frac{(p+2)\\ln x}{x} = 0,\\) there exists a number \\(N_1&gt;0\\) such that for all \\(x &gt; N_1\\) we have\n\\[\\frac{(p+2)\\ln x}{x} &lt; \\frac{1}{2}\\Longrightarrow (p+2)\\ln x &lt; \\frac{x}{2}\\] It follows that for all \\(x &gt; N_1\\),\n\\[-x + (p+2)\\ln x &lt; -\\frac{x}{2}.\\] Taking exponentials to get:\n\\[e^{-x}x^{p+2} = \\exp\\Bigl(-x + (p+2)\\ln x\\Bigr) &lt; \\exp\\Bigl(-\\frac{x}{2}\\Bigr) = e^{-x/2}.\\] For \\(e^{-x/2} &lt; \\epsilon,\\) we simply need \\(-\\frac{x}{2}  &lt; \\ln \\epsilon\\), which is \\(x  &gt; -2\\ln \\epsilon\\). We define \\(N_2 = -2\\ln \\epsilon\\). Let \\(N = \\max\\{N_1, N_2\\}\\). Then, \\(\\forall x &gt; N\\) we have both\n\\[e^{-x}x^{p+2} &lt; e^{-x/2} \\quad \\text{and} \\quad e^{-x/2} &lt; \\epsilon,\\] so that \\(e^{-x}x^{p+2} &lt; \\epsilon\\). By the definition of the limit we have: \\[\\lim_{x\\to\\infty} e^{-x}x^{p+2} = 0.\\] Next, we use this to compare the integral \\(\\int_1^\\infty e^{-x}x^p\\,dx\\) with the convergent integral \\(\\int_1^\\infty \\frac{1}{x^2}\\,dx\\). Note that for \\(x \\ge 1\\) and a fixed \\(p\\), it is always true that \\[x^{p} \\le x^{p+2}\\Longrightarrow e^{-x}x^p \\le e^{-x}x^{p+2}\\] As already demonstrated above, for sufficiently large \\(x\\) , we can have \\[0 \\leq e^{-x} x^p \\leq e^{-x} x^{p+2}&lt;\\frac{1}{x^2}\\] Hence, there exists some \\(M\\) such that for all \\(x &gt; M\\), \\[0 \\le e^{-x}x^p \\le \\frac{1}{x^2}.\\] Given that the tail integral \\[\\int_1^{\\infty} e^{-x} x^p d x=\\int_1^M e^{-x} x^p d x+\\int_M^{\\infty} e^{-x} x^p d x\\] converges, so \\(\\int_M^{\\infty} e^{-x} x^p d x\\) converges. By the Comparison Test, the integral \\[\\int_{M}^\\infty e^{-x}x^p\\,dx\\] must also converges. Finally, note that integral over any finite interval \\([1,M]\\) is finite, so the entire integral \\[\\int_{1}^\\infty e^{-x}x^p\\,dx\\] converges.\n\nProblem 8.5.3 Let \\(f:[a, \\infty[\\rightarrow \\mathbb{R}\\) be Riemann integrable on bounded intervals. Show that \\(\\int_a^{\\infty} f\\) (conditional convergence) exists iff for every \\(\\varepsilon&gt;0\\), there is a \\(T\\) such that \\(t_1, t_2 \\geq T\\) implies\n\\[\n\\left|\\int_{t_1}^{t_2} f(x) d x\\right|&lt;\\varepsilon\n\\]\n\n[!definition|*]\nLet \\(f : [a,\\infty) \\to \\mathbb{R}\\) be a such function, we say the improper integral \\[\\int_a^\\infty f(x)\\,dx\\] exists (or converges) if the limit \\[\\lim_{t \\to \\infty} \\int_a^t f(x)\\,dx\\] exists for some number \\(L\\). We want to show that this is equivalent to this Cauchy condition: For every \\(\\varepsilon &gt; 0\\), there exists \\(T \\ge a\\) such that for all \\(t_1, t_2 \\ge T,\\) we have \\(\\left|\\int_{t_1}^{t_2} f(x)\\,dx\\right| &lt; \\varepsilon\\).\n(\\(\\implies\\)) First, by assumption, the improper integral \\(\\int_a^\\infty f(x)\\,dx\\) converges a \\(L\\in \\mathbb{R}\\) s.t: \\[\\lim_{t \\to \\infty} \\int_a^t f(x)\\,dx = L\\] By definition of the limit, this means for any given \\(\\varepsilon&gt;0\\), there exists \\(T\\) s.t. for all \\(t \\ge T,\\) we can have \\[\\left|\\int_a^t f(x)\\,dx - L\\right| &lt; \\frac{\\varepsilon}{2}.\\]Let \\(t_1, t_2 \\ge T\\). Without loss of generality, assume \\(t_1 &lt; t_2\\), then we can write: \\[\n\\int_{t_1}^{t_2} f(x) d x=\\left(\\int_a^{t_2} f(x) d x-L\\right)-\\left(\\int_a^{t_1} f(x) d x-L\\right)\n\\] By the triangle inequality: \\[\n\\left|\\int_{t_1}^{t_2} f(x) d x\\right| \\leq\\left|\\int_a^{t_2} f(x) d x-L\\right|+\\left|\\int_a^{t_1} f(x) d x-L\\right|\n\\] By our choice of \\(T\\), for both \\(t_1, t_2 \\ge T\\), \\[\\left|\\int_a^{t_i} f(x)\\,dx - L\\right| &lt; \\frac{\\varepsilon}{2}\\quad \\] Hence, \\[\n\\left|\\int_{t_1}^{t_2} f(x) d x\\right| \\leq \\frac{\\varepsilon}{2}+\\frac{\\varepsilon}{2}=\\varepsilon\n\\] Thus, for every \\(\\varepsilon&gt;0\\), we always have a \\(T\\) such that the integral is less than \\(\\varepsilon\\) whenever \\(t_1,t_2 \\ge T\\).\n(\\(\\Longleftarrow\\)) Conversely, suppose that for every \\(\\varepsilon &gt; 0\\), there is a \\(T\\) such that for all \\(t_1,t_2 \\ge T\\), \\[\\left|\\int_{t_1}^{t_2} f(x)\\,dx\\right| &lt; \\varepsilon\\]We want to prove that limit \\(\\lim_{t\\to\\infty}\\int_a^t f(x)\\,dx\\) exists as a real number. For convenience, we set \\[I(t)=\\int_a^t f(x)\\,dx\\] Then, by the given standard Cauchy condition, \\(\\forall\\varepsilon&gt;0\\), \\(\\exists \\,T\\ge a\\) s.t. whenever \\(t_1,t_2\\ge T\\), we have \\[|I(t_2)-I(t_1)|&lt;\\varepsilon.\\] Fix any \\(t \\geq T\\). Then, for every \\(t_{0} \\geq T\\), we always have \\(|I(t_{0})-I(t)|&lt;\\varepsilon\\), so this mean that implies that \\(I(t_{0})\\in (I(t)-\\varepsilon, I(t)+\\varepsilon)\\) for any \\(t_{0} \\geq T\\). We set upper and lower limits of the function \\(I(t)\\) as \\(t\\to\\infty\\): \\[L_{\\text {sup }}=\\lim _{T \\rightarrow \\infty} \\sup \\{I(t_{0}): t_{0}\\geq T\\}\\quad \\text{and} \\quad L_{\\mathrm{inf}}=\\lim _{T \\rightarrow \\infty} \\inf \\{I(t_{0}): t_{0} \\geq T\\}\\] This, by definition, gives us: \\[I(t)-\\varepsilon \\leq L_{\\inf}\\leq L_{\\sup}\\leq I(t)+\\varepsilon.\\] In particular, choosing any \\(t\\ge T\\) and writing these two inequalities together, we get: \\[ L_{\\sup}-L_{\\inf}\\leq  (I(t)+\\varepsilon) - (I(t)-\\varepsilon)=2\\varepsilon.\\] Because \\(\\varepsilon&gt;0\\) is arbitrary, it shows it is indeed in fact \\[L_{\\sup}-L_{\\inf}=0\\,\\Longrightarrow L_{\\sup}=L_{\\inf}=L\\] Now, by the definitions of \\(\\limsup\\) and \\(\\liminf\\), it follows that for every \\(\\epsilon_{1}&gt;0\\) there exists some \\(T_{1}\\ge a\\) such that for all \\(t\\ge T_{1}\\), \\[L-\\epsilon &lt; I(t) &lt; L+\\epsilon\\] which is the definition of the limit. We have shown that \\(\\epsilon_{1}&gt;0\\) there exists \\(T_{1}\\) s.t for all \\(t\\ge T_{1}\\), \\[|I(t)-L|&lt;\\epsilon.\\] Thus, we conclude that \\[\\lim_{t\\to\\infty} I(t)=L,\\] which, by definition, means that the improper integral \\[\\int_a^\\infty f(x)\\,dx = \\lim_{t\\to\\infty}\\int_a^t f(x)\\,dx\\]exists.\n\nProblem 8.5.5 For what \\(\\alpha\\) is \\(\\int_0^{\\infty} \\frac{x^\\alpha}{1+x^\\alpha} d x\\) convergent?\n\n[!definition|*] To fine \\(\\alpha\\), notice that \\[\\int_0^{\\infty} \\frac{x^\\alpha}{1+x^\\alpha} d x=\\int_0^1 \\frac{x^\\alpha}{1+x^\\alpha} d x+\\int_1^{\\infty} \\frac{x^\\alpha}{1+x^\\alpha} d x\\] can be split into two regions separately: interval \\((0,1]\\)) and \\([1,\\infty)\\). So, first, we examine the behavior near \\(x=0\\). We consider \\[\\int_{0}^{1} \\frac{x^{\\alpha}}{1 + x^{\\alpha}}\\,dx.\\] We must check whether the integrand create any problems as \\(x\\to0\\). 1. \\(\\alpha &gt; 0\\): As \\(x \\to 0\\), \\(x^{\\alpha}\\) becomes very small, so \\[\\frac{x^{\\alpha}}{1 + x^{\\alpha}} \\;\\approx\\; x^{\\alpha}\\]Since \\(x^{\\alpha}\\) near \\(0\\) is integrable if \\(\\alpha &gt; -1\\), and here \\(\\alpha &gt; 0\\) definitely satisfies \\(\\alpha &gt; -1\\), there is no divergence issue at \\(0\\) in this case. 2. \\(\\alpha = 0\\): Since \\(x^{\\alpha} = x^0 = 1\\), and the integrand becomes \\(\\tfrac12\\), which is a constant. 3. \\(\\alpha &lt; 0\\): As \\(x \\to 0\\), \\(x^{\\alpha}  =\\frac{1}{x^{|\\alpha|}}\\to \\infty\\). Thus, \\[\\frac{x^{\\alpha}}{1 + x^{\\alpha}} \\approx1\\]which is integrable. Therefore, near \\(x=0\\), the integrand is always integrable for every real \\(\\alpha\\).\nNext, we check behavior near \\(x=\\infty\\). We examine the behavior for \\(\\int_1^{\\infty} \\frac{x^\\alpha}{1+x^\\alpha} d x\\) as \\(x\\to\\infty\\):\n\n\\(\\alpha &gt; 0\\): As \\(x \\to \\infty\\), \\(x^{\\alpha}\\) is very large, so \\(\\frac{x^{\\alpha}}{1 + x^{\\alpha}} \\;\\approx\\; 1\\). This means that \\(\\int_{1}^{\\infty} 1\\,dx\\) diverges for all \\(\\alpha &gt; 0\\).\n\\(\\alpha = 0\\): similarly, \\(x^{\\alpha} = x^{0} = 1\\) implies that the integrand is \\(\\frac{1}{2}\\), and \\(\\int_{1}^{\\infty} \\tfrac12 \\,dx\\) also diverges. So it fails to converge for \\(\\alpha=0\\).\n\\(\\alpha &lt; 0\\): As \\(x\\to\\infty\\), \\(x^\\alpha\\) tends to \\(0\\). So \\[\\frac{x^{\\alpha}}{1 + x^{\\alpha}} \\;\\approx\\; x^{\\alpha}.\\] By example 8.5.7(a), we know \\(\\int_{1}^{\\infty} x^{p}\\,dx\\) converges if and only if \\(p &lt; -1\\). Therefore, if \\(\\alpha &lt; -1\\), then \\(\\int_{1}^{\\infty} x^{\\alpha}\\,dx\\) converges, and consequently \\[\\int_{1}^{\\infty} \\frac{x^{\\alpha}}{1 + x^{\\alpha}}\\,dx\\;\\text{converges}\\] by comparison test. Hence, the only way to have convergence at \\(x = \\infty\\) is to require alpha to be less that \\(-1\\). We have shown that the integral is finite if and only if \\(\\alpha &lt; -1\\).\n\n\nChatper 8.21 Show that \\(\\int_1^{\\infty} x^{-p} \\sin x d x\\) converges if \\(p&gt;1\\). Show that if \\(0&lt;p \\leq 1\\), then the convergence is conditional.\n\n[!definition|*] Absolute Convergence for \\(p&gt;1\\) To show that the integral converges absolutely when \\(p&gt;1\\), we consider the absolute value of the integrand: \\[\\int_{1}^{\\infty} \\bigl| x^{-p}\\sin x \\bigr|\\,dx.\\] Since \\(| \\sin x| \\le 1,\\) for all \\(x\\ge 1\\) we have \\[\\bigl| x^{-p}\\sin x \\bigr| \\le x^{-p}.\\] Thus, by the Comparison Test we know: \\[\\int_{1}^{\\infty} \\bigl| x^{-p}\\sin x \\bigr|\\,dx \\le \\int_{1}^{\\infty} x^{-p}\\,dx.\\] We now compute or recall the convergence of this integral. 1. For \\(p\\neq 1\\), \\[\\int_{1}^{a} x^{-p}\\,dx = \\left[\\frac{x^{1-p}}{1-p}\\right]_{x=1}^{x=a}\n=\\frac{a^{1-p}-1}{1-p}\\] 2. For \\(p&gt;1\\), then \\(1-p&lt;0\\) and therefore \\[\\lim_{a\\to\\infty} a^{1-p} = 0\\] which means: \\[\\int_{1}^{\\infty} x^{-p}\\,dx = \\frac{0-1}{1-p}=\\frac{1}{p-1}&lt;\\infty\\] and we further conclude that: \\[\\int_{1}^{\\infty} \\bigl| x^{-p}\\sin x \\bigr|\\,dx &lt; \\infty\\] and hence the integral \\(I(p)\\) converges absolutely when \\(p&gt;1\\).\nConditional Convergence for \\(0 &lt; p\\le 1\\) To show that the integral converges conditionally, we use integration by parts to show that it converges conditionally. Let \\[I(b)=\\int_{1}^{b} x^{-p}\\sin x\\,dx\\] By the integration by parts formula, we obtain: \\[I(b) = \\left[-x^{-p}\\cos x\\right]_{1}^{b} -\\left( -\\int_{1}^{b} (-\\cos x)(p\\,x^{-p-1})\\,dx\\right)\\] Then, evaluate the boundary term, we have \\[\\left[-x^{-p}\\cos x\\right]_{1}^{b} = -b^{-p}\\cos b + 1^{-p}\\cos 1 = -b^{-p}\\cos b + \\cos 1\\]Since \\(p&gt;0\\), as \\(b\\to\\infty\\) we have \\(b^{-p}\\to 0\\), and so \\(\\lim_{b\\to\\infty} \\left(-b^{-p}\\cos b\\right)=0\\). Hence, the boundary contribution tends to \\(\\cos 1\\). Then, the remaining term becomes \\[I(b) = \\cos 1 + p\\int_1^b x^{-p-1}\\cos x\\,dx=\\cos 1 + pI_{1}(b)\\]where we define \\(I_{1}(b)=\\int_{1}^{b} x^{-p-1}\\cos x\\,dx\\). Note that, again we have: \\[\\bigl|x^{-p-1}\\cos x\\bigr|\\le x^{-p-1}\\]since \\(p&gt;0\\) by the assumption, we know \\(-p-1&lt;-1\\). Therefore, \\(I_{1}(b)\\) converges absolutely as \\(b\\to\\infty\\). Let’s denote it as \\(\\lim_{b\\to\\infty} I_{1}(b)=L\\). Then, as \\(b\\to\\infty\\), we obtain: \\[\\lim_{b\\to\\infty} I(b)= \\cos 1 + p\\,L.\\] Here the integral \\(I(b)\\) converges to the finite value \\(\\cos 1 + p\\,L\\) while the absolute integral diverges for \\(0&lt;p\\le1\\). Hence, the original integral \\[\\int_{1}^{\\infty} x^{-p}\\sin x\\,dx\\] converges conditionally for \\(0&lt;p\\leq1\\)\n\nChapter 8.22 The gamma function is defined to be the function given by the improper integral \\(\\Gamma(p)=\\int_1^{\\infty} e^{-x} x^{p-1} d x\\). Show that the integral is convergent for \\(p&gt;0\\).\n\n[!definition|*] We want to show that the improper integral \\[\\Gamma(p)=\\int_1^{\\infty} e^{-x}x^{p-1}\\,dx\\] converges for \\(p&gt;0\\). Observe that \\[e^{-x}x^{p-1} \\Longrightarrow \\lim_{x\\to\\infty} \\frac{x^{p-1}}{e^x} =\\lim_{x\\to\\infty} \\frac{x^q}{e^x}= 0.\\] where \\(q=p-1\\) (with \\(p&gt;0\\)). And since we know that for \\(n\\ge1\\) and \\(x&gt;0\\), we always have \\[e^x \\ge \\frac{x^n}{n!}\\] so, for any integer \\(n\\) s.t. \\(n&gt;p\\), \\(\\forall x\\ge1\\), we can have \\[e^{-x} = \\frac{1}{e^{x}} \\le \\frac{n!}{x^{n}}\\Longrightarrow e^{-x}x^{p-1} \\le n! \\, x^{p-1-n}\\] Then, we verify the convergence of the this integral: \\[I=\\int_1^\\infty x^{p-1-n}\\,dx=\\int_1^\\infty x^{r}\\,dx\\] where \\(r=p-1-n\\). We know such integral converges if and only if \\(r&lt;-1\\). Since we have chosen \\(n&gt;p\\), it follows that \\[p-1-n &lt; -1 \\quad \\] Thus, the exponent \\(r\\) satisfies the convergence criterion. Consequently, \\[I= \\int_1^\\infty x^{p-1-n}\\,dx &lt; \\infty.\\] Next, since for all \\(x\\ge1\\) we have \\[0 \\le e^{-x}x^{p-1} \\le n!\\,x^{p-1-n},\\] and integral \\(I\\) converges, so the Comparison Test implies that \\[\\int_1^{\\infty} e^{-x}x^{p-1}\\,dx \\;\\;\\text{ also converges}\\] Thus, we have shown that the gamma function integral \\[\\Gamma(p)=\\int_1^\\infty e^{-x} x^{p-1}\\,dx\\] converges for every \\(p&gt;0\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "Real Analysis II",
      "Homework 9"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/index.html",
    "href": "content/notes/理论/实分析/index.html",
    "title": "实分析",
    "section": "",
    "text": "1.1 积分的定义\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.4 可微分性的必要条件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5 链式法则\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.6 乘积法则与梯度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.9 泰勒公式的高维形式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.1 反函数定理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.1.1 反函数定理（证明）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.2 隐函数定理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.6 莫尔斯引理\n\n\n\n\n\n\n\n\n2025年3月22日\n\n\n\n\n\n\n\n\n\n\n\n\n8.5 不定积分\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n8.6 勒贝格收敛定理\n\n\n\n\n\n\n\n\n2025年3月27日\n\n\n\n\n\n\n\n\n\n\n\n\nCriterion for Integrability\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGaussian Integral Computation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProof of the Theorem\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nReal Analysis II\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n积分计算\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第七章 逆函数和隐函数定理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第九章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第八章 度量理论\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第六章 可微映射\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第十章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "实分析"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html",
    "href": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html",
    "title": "7.1.1 反函数定理（证明）",
    "section": "",
    "text": "Theorem 7.1.1: Let \\(y = f(x): A \\subset \\mathbb{R}^n \\to \\mathbb{R}^n\\) be of class \\(C^1\\). Suppose \\(x_0 \\in A\\) with: \\[\nJ_f(x_0) = \\det(Df(x_0)) \\ne 0\n\\] Then there exist neighborhoods \\(U\\) of \\(x_0\\) in \\(A\\) and \\(W\\) of \\(y_0 = f(x_0)\\) such that:\n\n\\(f(U) = W\\) and \\(f: U \\to W\\) has an inverse \\(f^{-1}: W \\to U\\).\n\\(f^{-1} \\in C^1\\) (If \\(f \\in C^r\\), then \\(f^{-1} \\in C^r\\)).\n\\(Df^{-1}(y) = [Df(x)]^{-1}\\) for \\(x \\in U\\) and \\(y = f(x)\\).\n\n\n\n\n\n\nWe may assume \\(Df(x_0) = I\\) and \\(x_0 = 0\\), \\(y_0 = f(x_0)\\).\n\n\n\nConsider the function \\(g(x) = x - f(x)\\).\n\nUsing continuity of \\(Dg(x)\\) at \\(0\\) and Mean Value Theorem, one can show there exists \\(\\delta &gt; 0\\) such that for \\(x \\in B(0, \\delta)\\): \\[\n\\|g(x)\\| \\le \\frac{\\delta}{2}\n\\]\nDefine \\(g: B(0, \\delta) \\to B(0, \\frac{\\delta}{2})\\).\nLet \\(W = B(0, \\frac{\\delta}{2})\\), and define: \\[\nU = \\{ x \\in B(0, \\delta): f(x) \\in W \\}\n\\]\n\n\n\n\nFix \\(y \\in W\\). Apply the Contraction Mapping Principle (CMP) to: \\[\ng_y(x) = y + x - f(x) = y + g(x)\n\\] Then \\(g_y(x): B(0, \\delta) \\to B(0, \\delta)\\). Thus, there exists a unique \\(x \\in B(0, \\delta)\\) such that: \\[\ng_y(x) = x \\quad \\Longrightarrow \\quad f(x) = y\n\\] Therefore, \\(\\exists! x \\in U\\) such that \\(f(x) = y\\).\nFix \\(y, y_1, y_2 \\in W\\), let \\(x_i = f^{-1}(y_i), i = 1,2\\). Then: \\[\n\\| f^{-1}(y_1) - f^{-1}(y_2) \\| = \\| x_1 - x_2 \\|\n= \\| g_{y_1}(x_1) - g_{y_2}(x_2) \\|\n\\]\nSince \\(\\| Dg(x) \\| \\le \\frac{1}{2}\\) for \\(x \\in B(0, \\delta)\\), we get: \\[\n\\| x_1 - x_2 \\| \\le 2 \\| y_1 - y_2 \\|\n\\]\nThus, \\(f^{-1}\\) is Lipschitz continuous.\n\n\n\n\nObservation: \\([Df(x_0)]^{-1}\\) exists and \\(Df(x)\\) is continuous at \\(x_0\\).\n\n\\[ \\Rightarrow \\exists \\delta &gt; 0 \\text{ such that } [Df(x)]^{-1} \\text{ exists and bounded by } M \\text{, } \\forall \\|x\\| \\leq \\delta \\] \\[ \\| [Df(x)]^{-1} \\| \\leq M, \\quad \\forall x \\in B(0, \\delta) \\]\n\nShow \\(f^{-1}\\) is differentiable at any \\(y_* \\in W\\) and: \\[\nDf^{-1}(y_0) = [Df(x_0)]^{-1}, \\quad \\text{where} \\quad y_0 = f(x_0)\n\\]\n\nFix \\(y_* \\in W\\). Then: \\[\n\\frac{\\| f^{-1}(y) - f^{-1}(y_*) - [Df(x_0)]^{-1}(y - y_*) \\|}{\\| y - y_* \\|}\n\\] can be simplified, and as \\(y \\to y_*\\), it tends to \\(0\\).\nThus, in conclusion, \\(f^{-1}(y)\\) is differentiable at \\(y_* \\in W\\) and: \\[\nDf^{-1}(y_*) = [Df(x_*)]^{-1}\n\\]\n\n\n\n\nInvestigate the invertibility (both local and global) for the map: \\[f \\in C^\\infty, \\quad A = \\mathbb{R}^2\\]\n\\[W = (u,v) = f(x,y): \\mathbb{R}^2 \\to \\mathbb{R}^2\\] Given by: \\[\nu = e^x\\cos y, \\quad v = e^x\\sin y\\]\n\nCompute Jacobian determinant: \\[\nJ_f(x,y) = \\det(Df(x,y)) =\n\\begin{vmatrix}\ne^x\\cos y & -e^x\\sin y \\\\\\\\\ne^x\\sin y & e^x\\cos y\n\\end{vmatrix}\n= e^{2x} &gt; 0\n\\]\n\nThus, by IFT, \\(f\\) is invertible locally at any point and: \\[\nDf^{-1}(u,v) = [Df(x,y)]^{-1} =\n\\begin{bmatrix}\ne^x\\cos y & -e^x\\sin y \\\\\\\\\ne^x\\sin y & e^x\\cos y\n\\end{bmatrix}^{-1}\n= \\begin{bmatrix}\ne^{-x}\\cos y & e^{-x}\\sin y \\\\\\\\\n-e^{-x}\\sin y & e^{-x}\\cos y\n\\end{bmatrix}\n\\]\nHowever, \\(f\\) is not globally invertible (not injective). Consider: \\[\n\\begin{aligned}\nf(x_0, y_0 + 2\\pi) &= (e^{x_0}\\cos(y_0 + 2\\pi), e^{x_0}\\sin(y_0 + 2\\pi))\\\\\\\\\n&= (e^{x_0}\\cos y_0, e^{x_0}\\sin y_0)\\\\\\\\\n&= (u_0, v_0)\n\\end{aligned}\n\\]\nIn complex notation, \\(f\\) can be written as: \\[\nf(z) = e^z = e^{x+iy} = e^x e^{iy} = e^x(\\cos y + i \\sin y)\n\\] with \\(u = e^x \\cos y\\), \\(v = e^x \\sin y\\).\n\n\n\n\n\nSince \\(f(x, y)\\) maps points periodically in \\(y\\), it is not globally injective, despite being locally invertible.\n\n\n\n\nThe periodic nature is reflected in the mapping: \\[f(x_0, y_0 + 2\\pi) = f(x_0, y_0)\\] This demonstrates that multiple points in the domain map to the same point in the range, confirming non-injectivity.",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1.1 反函数定理（证明）"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#recall-ift",
    "href": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#recall-ift",
    "title": "7.1.1 反函数定理（证明）",
    "section": "",
    "text": "Theorem 7.1.1: Let \\(y = f(x): A \\subset \\mathbb{R}^n \\to \\mathbb{R}^n\\) be of class \\(C^1\\). Suppose \\(x_0 \\in A\\) with: \\[\nJ_f(x_0) = \\det(Df(x_0)) \\ne 0\n\\] Then there exist neighborhoods \\(U\\) of \\(x_0\\) in \\(A\\) and \\(W\\) of \\(y_0 = f(x_0)\\) such that:\n\n\\(f(U) = W\\) and \\(f: U \\to W\\) has an inverse \\(f^{-1}: W \\to U\\).\n\\(f^{-1} \\in C^1\\) (If \\(f \\in C^r\\), then \\(f^{-1} \\in C^r\\)).\n\\(Df^{-1}(y) = [Df(x)]^{-1}\\) for \\(x \\in U\\) and \\(y = f(x)\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1.1 反函数定理（证明）"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#proof-of-theorem-7.1.1",
    "href": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#proof-of-theorem-7.1.1",
    "title": "7.1.1 反函数定理（证明）",
    "section": "",
    "text": "We may assume \\(Df(x_0) = I\\) and \\(x_0 = 0\\), \\(y_0 = f(x_0)\\).\n\n\n\nConsider the function \\(g(x) = x - f(x)\\).\n\nUsing continuity of \\(Dg(x)\\) at \\(0\\) and Mean Value Theorem, one can show there exists \\(\\delta &gt; 0\\) such that for \\(x \\in B(0, \\delta)\\): \\[\n\\|g(x)\\| \\le \\frac{\\delta}{2}\n\\]\nDefine \\(g: B(0, \\delta) \\to B(0, \\frac{\\delta}{2})\\).\nLet \\(W = B(0, \\frac{\\delta}{2})\\), and define: \\[\nU = \\{ x \\in B(0, \\delta): f(x) \\in W \\}\n\\]\n\n\n\n\nFix \\(y \\in W\\). Apply the Contraction Mapping Principle (CMP) to: \\[\ng_y(x) = y + x - f(x) = y + g(x)\n\\] Then \\(g_y(x): B(0, \\delta) \\to B(0, \\delta)\\). Thus, there exists a unique \\(x \\in B(0, \\delta)\\) such that: \\[\ng_y(x) = x \\quad \\Longrightarrow \\quad f(x) = y\n\\] Therefore, \\(\\exists! x \\in U\\) such that \\(f(x) = y\\).\nFix \\(y, y_1, y_2 \\in W\\), let \\(x_i = f^{-1}(y_i), i = 1,2\\). Then: \\[\n\\| f^{-1}(y_1) - f^{-1}(y_2) \\| = \\| x_1 - x_2 \\|\n= \\| g_{y_1}(x_1) - g_{y_2}(x_2) \\|\n\\]\nSince \\(\\| Dg(x) \\| \\le \\frac{1}{2}\\) for \\(x \\in B(0, \\delta)\\), we get: \\[\n\\| x_1 - x_2 \\| \\le 2 \\| y_1 - y_2 \\|\n\\]\nThus, \\(f^{-1}\\) is Lipschitz continuous.\n\n\n\n\nObservation: \\([Df(x_0)]^{-1}\\) exists and \\(Df(x)\\) is continuous at \\(x_0\\).\n\n\\[ \\Rightarrow \\exists \\delta &gt; 0 \\text{ such that } [Df(x)]^{-1} \\text{ exists and bounded by } M \\text{, } \\forall \\|x\\| \\leq \\delta \\] \\[ \\| [Df(x)]^{-1} \\| \\leq M, \\quad \\forall x \\in B(0, \\delta) \\]\n\nShow \\(f^{-1}\\) is differentiable at any \\(y_* \\in W\\) and: \\[\nDf^{-1}(y_0) = [Df(x_0)]^{-1}, \\quad \\text{where} \\quad y_0 = f(x_0)\n\\]\n\nFix \\(y_* \\in W\\). Then: \\[\n\\frac{\\| f^{-1}(y) - f^{-1}(y_*) - [Df(x_0)]^{-1}(y - y_*) \\|}{\\| y - y_* \\|}\n\\] can be simplified, and as \\(y \\to y_*\\), it tends to \\(0\\).\nThus, in conclusion, \\(f^{-1}(y)\\) is differentiable at \\(y_* \\in W\\) and: \\[\nDf^{-1}(y_*) = [Df(x_*)]^{-1}\n\\]\n\n\n\n\nInvestigate the invertibility (both local and global) for the map: \\[f \\in C^\\infty, \\quad A = \\mathbb{R}^2\\]\n\\[W = (u,v) = f(x,y): \\mathbb{R}^2 \\to \\mathbb{R}^2\\] Given by: \\[\nu = e^x\\cos y, \\quad v = e^x\\sin y\\]\n\nCompute Jacobian determinant: \\[\nJ_f(x,y) = \\det(Df(x,y)) =\n\\begin{vmatrix}\ne^x\\cos y & -e^x\\sin y \\\\\\\\\ne^x\\sin y & e^x\\cos y\n\\end{vmatrix}\n= e^{2x} &gt; 0\n\\]\n\nThus, by IFT, \\(f\\) is invertible locally at any point and: \\[\nDf^{-1}(u,v) = [Df(x,y)]^{-1} =\n\\begin{bmatrix}\ne^x\\cos y & -e^x\\sin y \\\\\\\\\ne^x\\sin y & e^x\\cos y\n\\end{bmatrix}^{-1}\n= \\begin{bmatrix}\ne^{-x}\\cos y & e^{-x}\\sin y \\\\\\\\\n-e^{-x}\\sin y & e^{-x}\\cos y\n\\end{bmatrix}\n\\]\nHowever, \\(f\\) is not globally invertible (not injective). Consider: \\[\n\\begin{aligned}\nf(x_0, y_0 + 2\\pi) &= (e^{x_0}\\cos(y_0 + 2\\pi), e^{x_0}\\sin(y_0 + 2\\pi))\\\\\\\\\n&= (e^{x_0}\\cos y_0, e^{x_0}\\sin y_0)\\\\\\\\\n&= (u_0, v_0)\n\\end{aligned}\n\\]\nIn complex notation, \\(f\\) can be written as: \\[\nf(z) = e^z = e^{x+iy} = e^x e^{iy} = e^x(\\cos y + i \\sin y)\n\\] with \\(u = e^x \\cos y\\), \\(v = e^x \\sin y\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1.1 反函数定理（证明）"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#conclusion",
    "href": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#conclusion",
    "title": "7.1.1 反函数定理（证明）",
    "section": "",
    "text": "Since \\(f(x, y)\\) maps points periodically in \\(y\\), it is not globally injective, despite being locally invertible.",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1.1 反函数定理（证明）"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#additional-notes",
    "href": "content/notes/理论/实分析/第七章/7.1.1 Inverse FT (Proof).html#additional-notes",
    "title": "7.1.1 反函数定理（证明）",
    "section": "",
    "text": "The periodic nature is reflected in the mapping: \\[f(x_0, y_0 + 2\\pi) = f(x_0, y_0)\\] This demonstrates that multiple points in the domain map to the same point in the range, confirming non-injectivity.",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.1.1 反函数定理（证明）"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html",
    "href": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html",
    "title": "7.6 莫尔斯引理",
    "section": "",
    "text": "Let \\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\) be of class \\(C^2\\) and \\(x_0\\) is a critical point \\(\\rightarrow\\) one can use \\(H(x_0)\\) to classify critical points.\nMorse theory: makes this classification more precise. ### Morse Lemma\n\n[!lemma|*] Let \\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\) be of class \\(C^2\\) with critical point \\(x_0 \\in A\\). If \\(H(x_0)\\) is non-degenerate, then there exists a neighborhood of \\(x_0\\) and a diffeomorphism \\(g\\) such that the function \\(f \\circ g\\) has the form: \\[f \\circ g(y) = f(x_0) + \\sum_{i=1}^{\\lambda} -y_i^2 + \\sum_{i=\\lambda+1}^n y_i^2\\] where \\(\\lambda\\) is an integer called the index of \\(f\\) at \\(x_0\\). ### Applications - \\(\\lambda = 0\\): \\(x_0\\) is local minimum (paraboloid opens upward) - \\(\\lambda = n\\): \\(x_0\\) is local maximum (paraboloid opens downward) - \\(0 &lt; \\lambda &lt; n\\): \\(x_0\\) is saddle point (hyperboloid)\n\n\n\n\\(H(f) = \\begin{pmatrix}\n\\frac{\\partial^2 f}{\\partial x_1^2} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} & \\cdots \\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_2^2} & \\cdots \\\\\n\\vdots & \\vdots & \\ddots\n\\end{pmatrix}\\)\n\\(\\lambda\\) = # of negative eigenvalues of \\(H(f)(x_0)\\)\n\n\nSolution: At \\((0,0)\\), \\(f_x = 0\\), \\(f_y = 0\\)\nCompute eigenvalues of the Hessian matrix. If there is one negative eigenvalue, \\(\\lambda = 1\\), it’s a saddle point (hyperboloid).",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.6 莫尔斯引理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html#morse-theory-local-behavior-near-a-critical-point",
    "href": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html#morse-theory-local-behavior-near-a-critical-point",
    "title": "7.6 莫尔斯引理",
    "section": "",
    "text": "Let \\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\) be of class \\(C^2\\) and \\(x_0\\) is a critical point \\(\\rightarrow\\) one can use \\(H(x_0)\\) to classify critical points.\nMorse theory: makes this classification more precise. ### Morse Lemma\n\n[!lemma|*] Let \\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\) be of class \\(C^2\\) with critical point \\(x_0 \\in A\\). If \\(H(x_0)\\) is non-degenerate, then there exists a neighborhood of \\(x_0\\) and a diffeomorphism \\(g\\) such that the function \\(f \\circ g\\) has the form: \\[f \\circ g(y) = f(x_0) + \\sum_{i=1}^{\\lambda} -y_i^2 + \\sum_{i=\\lambda+1}^n y_i^2\\] where \\(\\lambda\\) is an integer called the index of \\(f\\) at \\(x_0\\). ### Applications - \\(\\lambda = 0\\): \\(x_0\\) is local minimum (paraboloid opens upward) - \\(\\lambda = n\\): \\(x_0\\) is local maximum (paraboloid opens downward) - \\(0 &lt; \\lambda &lt; n\\): \\(x_0\\) is saddle point (hyperboloid)\n\n\n\n\\(H(f) = \\begin{pmatrix}\n\\frac{\\partial^2 f}{\\partial x_1^2} & \\frac{\\partial^2 f}{\\partial x_1 \\partial x_2} & \\cdots \\\\\n\\frac{\\partial^2 f}{\\partial x_2 \\partial x_1} & \\frac{\\partial^2 f}{\\partial x_2^2} & \\cdots \\\\\n\\vdots & \\vdots & \\ddots\n\\end{pmatrix}\\)\n\\(\\lambda\\) = # of negative eigenvalues of \\(H(f)(x_0)\\)\n\n\nSolution: At \\((0,0)\\), \\(f_x = 0\\), \\(f_y = 0\\)\nCompute eigenvalues of the Hessian matrix. If there is one negative eigenvalue, \\(\\lambda = 1\\), it’s a saddle point (hyperboloid).",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.6 莫尔斯引理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html#constrained-extremal-problem",
    "href": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html#constrained-extremal-problem",
    "title": "7.6 莫尔斯引理",
    "section": "Constrained Extremal Problem",
    "text": "Constrained Extremal Problem\nGoal: To maximize or minimize a function \\(f(x): \\mathbb{R}^n \\to \\mathbb{R}\\) under the condition \\(g(x) = c\\).\n\nLagrange Multiplier Method\n\nA Necessary Condition\nTheorem: Let \\(f, g: U \\subset \\mathbb{R}^n \\to \\mathbb{R}\\) be of class \\(C^1\\). Assume \\(g(x_0) = c_0\\) with \\(\\nabla g(x_0) \\neq 0\\). If \\(f\\) restricted to the surface \\(S = \\{g(x) = c_0\\}\\) has a max or min at \\(x_0\\), then there exists a real number \\(\\lambda\\) such that:\n\\[\\nabla f(x_0) = \\lambda \\nabla g(x_0)\\]\n\n\nGeometric Meaning\n\n\\(\\nabla f(x_0)\\) points in the direction of steepest ascent\nAt the extremum, this direction is perpendicular to the surface \\(S\\)\n\n\n\nGeometric Proof\nLet \\(c(t)\\) be a fixed curve on \\(S = \\{g(x) = c_0\\}\\) passing through \\(x_0\\) at \\(t = t_0\\). If \\(f\\) restricted to \\(S\\) has a max at \\(x_0\\), then \\(f(c(t))\\) has max at \\(t_0\\).\nTherefore: \\(\\frac{d}{dt}f(c(t))|_{t=t_0} = 0\\)\nBy chain rule: \\(\\nabla f(c(t_0)) \\cdot c'(t_0) = 0\\)\nSince \\(c'(t_0)\\) is tangent to \\(S\\) at \\(x_0\\), \\(\\nabla f(x_0)\\) must be perpendicular to the tangent space of \\(S\\) at \\(x_0\\). Therefore, it must be parallel to \\(\\nabla g(x_0)\\), which is normal to the surface.\n\n\n\nProcedure to Solve Extremal Problem\nStep 1: Solve the system of equations \\[\\nabla f(x) = \\lambda \\nabla g(x)\\] \\[g(x) = c\\]\nThis gives \\(n+1\\) equations with \\(n+1\\) variables \\((x_1, x_2, ..., x_n, \\lambda)\\)\nStep 2: Compute values of \\(f\\) at these critical points and determine which are maxima, minima, or saddle points\n\nExample: Find the extrema of\n\\[f(x,y) = x^2 y^2\\] subject to the condition \\(x^2 + y^2 = 1\\)\nSolution: 1. Applying Lagrange multiplier method: \\(\\nabla f = (2xy^2, 2x^2y) = \\lambda \\nabla g = \\lambda(2x, 2y)\\)\n\nThis gives us:\n\n\\(xy^2 = \\lambda x\\)\n\\(x^2y = \\lambda y\\)\n\nAnalyzing by cases:\n\nCase 1: If \\(x = 0\\), then \\(y = \\pm 1\\) (from constraint)\nCase 2: If \\(y = 0\\), then \\(x = \\pm 1\\) (from constraint)\nCase 3: If \\(x \\neq 0\\) and \\(y \\neq 0\\):\n\nFrom the first equation: \\(y^2 = \\lambda\\) (dividing by \\(x\\))\nFrom the second equation: \\(x^2 = \\lambda\\) (dividing by \\(y\\))\nThis gives \\(x^2 = y^2\\)\nWith the constraint \\(x^2 + y^2 = 1\\), we get \\(2x^2 = 1\\), so \\(x = \\pm\\frac{1}{\\sqrt{2}}\\) and \\(y = \\pm\\frac{1}{\\sqrt{2}}\\)\n\n\nCritical points: \\((0, \\pm 1), (\\pm 1, 0), (\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}), (\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}}), (-\\frac{1}{\\sqrt{2}}, \\frac{1}{\\sqrt{2}}), (-\\frac{1}{\\sqrt{2}}, -\\frac{1}{\\sqrt{2}})\\)\nEvaluating \\(f(x,y) = x^2y^2\\) at these points:\n\n\\(f(0, \\pm 1) = 0\\)\n\\(f(\\pm 1, 0) = 0\\)\n\\(f(\\pm\\frac{1}{\\sqrt{2}}, \\pm\\frac{1}{\\sqrt{2}}) = (\\frac{1}{2})^2 = \\frac{1}{4}\\)\n\nTherefore, the maximum value is \\(\\frac{1}{4}\\) at \\((\\pm\\frac{1}{\\sqrt{2}}, \\pm\\frac{1}{\\sqrt{2}})\\), and the minimum value is \\(0\\) at \\((0, \\pm 1)\\) and \\((\\pm 1, 0)\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.6 莫尔斯引理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html#extremal-problem-with-multiple-constraints",
    "href": "content/notes/理论/实分析/第七章/7.6 Morse Lemma.html#extremal-problem-with-multiple-constraints",
    "title": "7.6 莫尔斯引理",
    "section": "Extremal Problem with Multiple Constraints",
    "text": "Extremal Problem with Multiple Constraints\nMaximize/minimize \\(f(x)\\) with constraints: - \\(g_1(x) = c_1\\) - \\(g_2(x) = c_2\\) - … - \\(g_m(x) = c_m\\)\n\nProcedure: Solve the system of equations\n\\[\\nabla f(x) = \\lambda_1 \\nabla g_1(x) + \\lambda_2 \\nabla g_2(x) + ... + \\lambda_m \\nabla g_m(x)\\] \\[g_1(x) = c_1, g_2(x) = c_2, ..., g_m(x) = c_m\\]\nWith \\(m+n\\) equations and \\(m+n\\) variables \\((x_1,...,x_n, \\lambda_1,...,\\lambda_m)\\)\n\n\nAnalytical Proof of the Theorem (Lagrange Multiplier)\nWe want to substitute the condition \\(g(x) = c_0\\) into the function \\(f(x)\\) to eliminate the constraint.\nSince \\(\\nabla g(x_0) \\neq 0\\), we may assume without loss of generality that \\(\\frac{\\partial g}{\\partial x_n} \\neq 0\\) at \\(x_0\\).\nBy the implicit function theorem, the equation \\(g(x_1, x_2, ..., x_n) = c_0\\) can be solved for \\(x_n\\) in a neighborhood of \\(x_0\\): \\[x_n = h(x_1, x_2, ..., x_{n-1})\\]\nLet \\(k(x_1, x_2, ..., x_{n-1}) = f(x_1, x_2, ..., x_{n-1}, h(x_1, x_2, ..., x_{n-1}))\\)\nThus, an extremum of \\(f\\) subject to the constraint corresponds to an extremum of \\(k\\) without constraints.\nAt an extremum of \\(k\\), we have: \\[0 = \\frac{\\partial k}{\\partial x_i} = \\frac{\\partial f}{\\partial x_i} + \\frac{\\partial f}{\\partial x_n}\\frac{\\partial h}{\\partial x_i}, \\quad i = 1, 2, ..., n-1\\]\nSince \\(g(x_1, x_2, ..., x_{n-1}, h(x_1, x_2, ..., x_{n-1})) = c_0\\) identically, we can differentiate with respect to \\(x_i\\):\n\\[\\frac{\\partial g}{\\partial x_i} + \\frac{\\partial g}{\\partial x_n}\\frac{\\partial h}{\\partial x_i} = 0, \\quad i = 1, 2, ..., n-1\\]\nSolving for \\(\\frac{\\partial h}{\\partial x_i}\\):\n\\[\\frac{\\partial h}{\\partial x_i} = -\\frac{\\frac{\\partial g}{\\partial x_i}}{\\frac{\\partial g}{\\partial x_n}}, \\quad i = 1, 2, ..., n-1\\]\nSubstituting this into our extremum condition:\n\\[\\frac{\\partial f}{\\partial x_i} - \\frac{\\partial f}{\\partial x_n}\\frac{\\frac{\\partial g}{\\partial x_i}}{\\frac{\\partial g}{\\partial x_n}} = 0, \\quad i = 1, 2, ..., n-1\\]\nRearranging:\n\\[\\frac{\\partial f}{\\partial x_i}\\frac{\\partial g}{\\partial x_n} - \\frac{\\partial f}{\\partial x_n}\\frac{\\partial g}{\\partial x_i} = 0, \\quad i = 1, 2, ..., n-1\\]\nLet \\(\\lambda = \\frac{\\partial f}{\\partial x_n} / \\frac{\\partial g}{\\partial x_n}\\), then:\n\\[\\frac{\\partial f}{\\partial x_i} = \\lambda \\frac{\\partial g}{\\partial x_i}, \\quad i = 1, 2, ..., n-1\\]\nAnd by definition of \\(\\lambda\\), we also have \\(\\frac{\\partial f}{\\partial x_n} = \\lambda \\frac{\\partial g}{\\partial x_n}\\)\nTherefore, in vector form: \\(\\nabla f(x_0) = \\lambda \\nabla g(x_0)\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第七章 逆函数和隐函数定理",
      "7.6 莫尔斯引理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html",
    "title": "积分计算",
    "section": "",
    "text": "In practice, how do we compute integral \\(\\int_A f(x)dx\\)?\n\nIn \\(\\mathbb{R}^1\\) (one-dimensional space): \\[\\int_a^b f(x)dx = F(x)|_a^b = F(b) - F(a)\\]\n\nFTC (Fundamental Theorem of Calculus)\n\nIn \\(\\mathbb{R}^n\\) (n-dimensional space):\n\nReduce to \\(\\mathbb{R}^1\\) case by Fubini’s Theorem\nChange of Variables (Substitution) first\n\n\n\n\n\n\n\nTheorem 1: Let \\(A = \\{(x,y): a \\leq x \\leq b, c \\leq y \\leq d\\}\\) be a rectangle in \\(\\mathbb{R}^2\\) and \\(f: A \\to \\mathbb{R}\\) be integrable. Suppose, for each \\(x \\in [a,b]\\), the following integral exists: \\[g(x) = \\int_c^d f(x,y)dy\\]\nThen \\(g(x)\\) is integrable on \\([a,b]\\) and \\(\\int_A f = \\int_a^b \\left(\\int_c^d f(x,y)dy\\right)dx = \\int_a^b g(x)dx\\)\n\n\n\n\nCorollary 1: If \\(f: A \\to \\mathbb{R}\\) is continuous, then \\[\\int_A f = \\int_a^b \\left(\\int_c^d f(x,y)dy\\right)dx = \\int_c^d \\left(\\int_a^b f(x,y)dx\\right)dy\\]\nThis shows the symmetry of the double integral - we can integrate first with respect to \\(y\\) and then with respect to \\(x\\), or vice versa.\nCorollary 2: Let \\(A\\) be a region given by \\(A = {(x,y): a \\leq x \\leq b, \\varphi(x) \\leq y \\leq \\psi(x)}\\) where \\(\\varphi(x)\\) and \\(\\psi(x)\\) are continuous functions. If \\(f: A \\to \\mathbb{R}\\) is continuous, then \\(\\int_A f = \\int_a^b \\left(\\int_{\\varphi(x)}^{\\psi(x)} f(x,y)dy\\right)dx\\)\n[Note: The image shows a graphical representation of region \\(A\\) bounded by \\(y = \\varphi(x)\\) below and \\(y = \\psi(x)\\) above, with \\(x\\) ranging from \\(a\\) to \\(b\\).]\n\n\nRoles of \\(x\\) and \\(y\\) can be interchanged Results true in higher dimensions\nLet \\(C = A \\times B \\subset \\mathbb{R}^{n+m}\\) where \\(A \\subset \\mathbb{R}^n\\), \\(B \\subset \\mathbb{R}^m\\) [The image shows a diagram of the Cartesian product \\(A \\times B\\) as a rectangle in a coordinate system with axes labeled \\(\\mathbb{R}^n\\) and \\(\\mathbb{R}^m\\)] Then: \\(\\int_{A \\times B} f = \\int_A \\left(\\int_B f(x,y)dy\\right)dx\\)\n\n\n\n\n\n\nCompute \\(\\int_A (x+y) \\, dxdy\\)\nWhere \\(A\\) is a triangle in the first quadrant bounded by the lines: - \\(x = 0\\) - \\(y = 0\\) - \\(x + y = 1\\)\n\n\n\nUsing Fubini’s Theorem, we can compute this double integral as an iterated integral:\n\\[\\int_A (x+y) \\, dxdy = \\int_0^1 \\left(\\int_0^{1-x} (x+y) \\, dy\\right) \\, dx\\]\nFirst, we evaluate the inner integral with respect to \\(y\\):\n\\[\\int_0^{1-x} (x+y) \\, dy = \\left[xy + \\frac{y^2}{2}\\right]_{y=0}^{y=1-x}\\]\n\\[= x(1-x) + \\frac{(1-x)^2}{2} - \\left(0 + 0\\right)\\]\n\\[= x - x^2 + \\frac{1 - 2x + x^2}{2}\\]\n\\[= x - x^2 + \\frac{1}{2} - x + \\frac{x^2}{2}\\]\n\\[= \\frac{1}{2} - \\frac{x^2}{2}\\]\nNow we evaluate the outer integral with respect to \\(x\\):\n\\[\\int_0^1 \\left(\\frac{1}{2} - \\frac{x^2}{2}\\right) \\, dx = \\frac{1}{2}\\int_0^1 (1 - x^2) \\, dx\\]\n\\[= \\frac{1}{2}\\left[x - \\frac{x^3}{3}\\right]_0^1\\]\n\\[= \\frac{1}{2}\\left(1 - \\frac{1}{3} - 0\\right)\\]\n\\[= \\frac{1}{2} \\cdot \\frac{2}{3} = \\frac{1}{3}\\]\nTherefore, \\(\\int_A (x+y) \\, dxdy = \\frac{1}{3}\\)\nNote: The calculation in the original blackboard image showed a final result of \\(\\frac{1}{2}\\), but the correct answer is \\(\\frac{1}{3}\\) as demonstrated in the steps above.\n\n\n\n\n\nI’ll write out a concise proof for just the part shown in the image:\n\n\n\nLet \\(g(x) = \\int_c^d f(x,y)dy\\)\nWe need to show: 1. \\(g\\) is integrable on \\([a,b]\\) 2. \\(\\int_a^b g(x)dx = \\int_A f\\)\nWe will compare upper and lower sums of \\(f\\) and \\(g\\).\nFix any partition \\(P_A\\) of \\(A\\). We can write \\(P_A = \\{S_{ij}\\}\\) where \\(S_{ij} = V_i \\times W_j\\) represents rectangular cells in the partition.\nThen \\(P_A\\) induces: - A partition of \\([a,b]\\): \\(P_{[a,b]} = \\{V_i\\}\\) - A partition of \\([c,d]\\): \\(P_{[c,d]} = \\{W_j\\}\\)\nFor each cell \\(S_{ij}\\), we define: - \\(M_{ij} = \\sup\\{f(x,y): (x,y) \\in S_{ij}\\}\\) - \\(m_{ij} = \\inf\\{f(x,y): (x,y) \\in S_{ij}\\}\\)\nThe upper and lower sums for \\(f\\) over partition \\(P_A\\) are: - \\(U(f, P_A) = \\sum_{i,j} M_{ij}|V_i||W_j|\\) - \\(L(f, P_A) = \\sum_{i,j} m_{ij}|V_i||W_j|\\)\nWhen we consider the integrable function \\(g(x)\\), we can establish that: \\(L(f, P_A) \\leq \\int_a^b g(x)dx \\leq U(f, P_A)\\)\nAs we refine the partition, the upper and lower sums converge, proving that \\(g\\) is integrable on \\([a,b]\\) and that \\(\\int_a^b g(x)dx = \\int_A f\\).\nI’ll continue the proof based on the additional image:\nI’ll rewrite the proof using proper display math formatting with $$ delimiters:\nNext, examine the lower sum \\(L(f, P_A)\\):\n\\[L(f, P_A) = \\sum_{i,j} m_{ij}(f) \\cdot V(S_{ij})\\]\n\\[= \\sum_{i,j} m_{ij}(f) \\cdot V(V_i) \\cdot V(W_j)\\]\nWhere \\(m_{ij}(f) = \\inf\\{f(x,y): (x,y) \\in S_{ij}\\}\\)\nKey Observation: \\[\\inf\\{f(x,y): (x,y) \\in V_i \\times W_j\\} \\leq \\inf\\{f(x,y): y \\in W_j\\} \\text{ for all } x \\in V_i\\] \\[= m_j(f, x)\\]\nThen for any \\(x \\in [a,b]\\), we have: \\[\\sum_j m_j(f) \\cdot V(W_j) \\leq \\sum_j m_j(f,x) \\cdot V(W_j)\\]\nThis is the lower sum of \\(f(x,y)\\) in the variable \\(y\\) with partition \\(P_{[c,d]}\\): \\[= L(f(x,·), P_{[c,d]})\\] \\[\\leq \\int_c^d f(x,y)dy = g(x) \\text{ for all } x\\]\nThus: \\[\\sum_i \\left(\\sum_j m_j(f) \\cdot V(W_j)\\right) \\cdot V(V_i) \\leq \\sum_i \\inf(g(x)) \\cdot V(V_i)\\]\ni.e., \\[\\sum_{i,j} m_{ij}(f) \\cdot V(W_j) \\cdot V(V_i) \\leq \\sum_i (\\inf g(x)) \\cdot V(V_i)\\]\nTherefore: \\[L(f, P_A) \\leq L(g, P_{[a,b]})\\]\nSimilarly, we have:\n\\[U(f, P_A) \\geq U(g, P_{[a,b]})\\]\nThus we have:\n\\[L(f, P_A) \\leq L(g, P_{[a,b]}) \\leq U(g, P_{[a,b]}) \\leq U(f, P_A)\\]\nBy Riemann’s criterion, if \\(f\\) is integrable on \\(A\\), then: 1. \\(g\\) is integrable on \\([a,b]\\), and 2. \\[\\int_A f = \\int_a^b g(x)dx\\]\nThis completes the proof of Fubini’s Theorem, showing that we can compute a double integral by first integrating with respect to one variable and then with respect to the other.",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#introduction",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#introduction",
    "title": "积分计算",
    "section": "",
    "text": "In practice, how do we compute integral \\(\\int_A f(x)dx\\)?\n\nIn \\(\\mathbb{R}^1\\) (one-dimensional space): \\[\\int_a^b f(x)dx = F(x)|_a^b = F(b) - F(a)\\]\n\nFTC (Fundamental Theorem of Calculus)\n\nIn \\(\\mathbb{R}^n\\) (n-dimensional space):\n\nReduce to \\(\\mathbb{R}^1\\) case by Fubini’s Theorem\nChange of Variables (Substitution) first",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#fubinis-theorem",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#fubinis-theorem",
    "title": "积分计算",
    "section": "",
    "text": "Theorem 1: Let \\(A = \\{(x,y): a \\leq x \\leq b, c \\leq y \\leq d\\}\\) be a rectangle in \\(\\mathbb{R}^2\\) and \\(f: A \\to \\mathbb{R}\\) be integrable. Suppose, for each \\(x \\in [a,b]\\), the following integral exists: \\[g(x) = \\int_c^d f(x,y)dy\\]\nThen \\(g(x)\\) is integrable on \\([a,b]\\) and \\(\\int_A f = \\int_a^b \\left(\\int_c^d f(x,y)dy\\right)dx = \\int_a^b g(x)dx\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#corollaries",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#corollaries",
    "title": "积分计算",
    "section": "",
    "text": "Corollary 1: If \\(f: A \\to \\mathbb{R}\\) is continuous, then \\[\\int_A f = \\int_a^b \\left(\\int_c^d f(x,y)dy\\right)dx = \\int_c^d \\left(\\int_a^b f(x,y)dx\\right)dy\\]\nThis shows the symmetry of the double integral - we can integrate first with respect to \\(y\\) and then with respect to \\(x\\), or vice versa.\nCorollary 2: Let \\(A\\) be a region given by \\(A = {(x,y): a \\leq x \\leq b, \\varphi(x) \\leq y \\leq \\psi(x)}\\) where \\(\\varphi(x)\\) and \\(\\psi(x)\\) are continuous functions. If \\(f: A \\to \\mathbb{R}\\) is continuous, then \\(\\int_A f = \\int_a^b \\left(\\int_{\\varphi(x)}^{\\psi(x)} f(x,y)dy\\right)dx\\)\n[Note: The image shows a graphical representation of region \\(A\\) bounded by \\(y = \\varphi(x)\\) below and \\(y = \\psi(x)\\) above, with \\(x\\) ranging from \\(a\\) to \\(b\\).]\n\n\nRoles of \\(x\\) and \\(y\\) can be interchanged Results true in higher dimensions\nLet \\(C = A \\times B \\subset \\mathbb{R}^{n+m}\\) where \\(A \\subset \\mathbb{R}^n\\), \\(B \\subset \\mathbb{R}^m\\) [The image shows a diagram of the Cartesian product \\(A \\times B\\) as a rectangle in a coordinate system with axes labeled \\(\\mathbb{R}^n\\) and \\(\\mathbb{R}^m\\)] Then: \\(\\int_{A \\times B} f = \\int_A \\left(\\int_B f(x,y)dy\\right)dx\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#example-computing-a-double-integral",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#example-computing-a-double-integral",
    "title": "积分计算",
    "section": "",
    "text": "Compute \\(\\int_A (x+y) \\, dxdy\\)\nWhere \\(A\\) is a triangle in the first quadrant bounded by the lines: - \\(x = 0\\) - \\(y = 0\\) - \\(x + y = 1\\)\n\n\n\nUsing Fubini’s Theorem, we can compute this double integral as an iterated integral:\n\\[\\int_A (x+y) \\, dxdy = \\int_0^1 \\left(\\int_0^{1-x} (x+y) \\, dy\\right) \\, dx\\]\nFirst, we evaluate the inner integral with respect to \\(y\\):\n\\[\\int_0^{1-x} (x+y) \\, dy = \\left[xy + \\frac{y^2}{2}\\right]_{y=0}^{y=1-x}\\]\n\\[= x(1-x) + \\frac{(1-x)^2}{2} - \\left(0 + 0\\right)\\]\n\\[= x - x^2 + \\frac{1 - 2x + x^2}{2}\\]\n\\[= x - x^2 + \\frac{1}{2} - x + \\frac{x^2}{2}\\]\n\\[= \\frac{1}{2} - \\frac{x^2}{2}\\]\nNow we evaluate the outer integral with respect to \\(x\\):\n\\[\\int_0^1 \\left(\\frac{1}{2} - \\frac{x^2}{2}\\right) \\, dx = \\frac{1}{2}\\int_0^1 (1 - x^2) \\, dx\\]\n\\[= \\frac{1}{2}\\left[x - \\frac{x^3}{3}\\right]_0^1\\]\n\\[= \\frac{1}{2}\\left(1 - \\frac{1}{3} - 0\\right)\\]\n\\[= \\frac{1}{2} \\cdot \\frac{2}{3} = \\frac{1}{3}\\]\nTherefore, \\(\\int_A (x+y) \\, dxdy = \\frac{1}{3}\\)\nNote: The calculation in the original blackboard image showed a final result of \\(\\frac{1}{2}\\), but the correct answer is \\(\\frac{1}{3}\\) as demonstrated in the steps above.",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#proof-of-theorem-1",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#proof-of-theorem-1",
    "title": "积分计算",
    "section": "",
    "text": "I’ll write out a concise proof for just the part shown in the image:",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#proof-of-theorem-1-1",
    "href": "content/notes/理论/实分析/第九章/9.1 Computing Integrals.html#proof-of-theorem-1-1",
    "title": "积分计算",
    "section": "",
    "text": "Let \\(g(x) = \\int_c^d f(x,y)dy\\)\nWe need to show: 1. \\(g\\) is integrable on \\([a,b]\\) 2. \\(\\int_a^b g(x)dx = \\int_A f\\)\nWe will compare upper and lower sums of \\(f\\) and \\(g\\).\nFix any partition \\(P_A\\) of \\(A\\). We can write \\(P_A = \\{S_{ij}\\}\\) where \\(S_{ij} = V_i \\times W_j\\) represents rectangular cells in the partition.\nThen \\(P_A\\) induces: - A partition of \\([a,b]\\): \\(P_{[a,b]} = \\{V_i\\}\\) - A partition of \\([c,d]\\): \\(P_{[c,d]} = \\{W_j\\}\\)\nFor each cell \\(S_{ij}\\), we define: - \\(M_{ij} = \\sup\\{f(x,y): (x,y) \\in S_{ij}\\}\\) - \\(m_{ij} = \\inf\\{f(x,y): (x,y) \\in S_{ij}\\}\\)\nThe upper and lower sums for \\(f\\) over partition \\(P_A\\) are: - \\(U(f, P_A) = \\sum_{i,j} M_{ij}|V_i||W_j|\\) - \\(L(f, P_A) = \\sum_{i,j} m_{ij}|V_i||W_j|\\)\nWhen we consider the integrable function \\(g(x)\\), we can establish that: \\(L(f, P_A) \\leq \\int_a^b g(x)dx \\leq U(f, P_A)\\)\nAs we refine the partition, the upper and lower sums converge, proving that \\(g\\) is integrable on \\([a,b]\\) and that \\(\\int_a^b g(x)dx = \\int_A f\\).\nI’ll continue the proof based on the additional image:\nI’ll rewrite the proof using proper display math formatting with $$ delimiters:\nNext, examine the lower sum \\(L(f, P_A)\\):\n\\[L(f, P_A) = \\sum_{i,j} m_{ij}(f) \\cdot V(S_{ij})\\]\n\\[= \\sum_{i,j} m_{ij}(f) \\cdot V(V_i) \\cdot V(W_j)\\]\nWhere \\(m_{ij}(f) = \\inf\\{f(x,y): (x,y) \\in S_{ij}\\}\\)\nKey Observation: \\[\\inf\\{f(x,y): (x,y) \\in V_i \\times W_j\\} \\leq \\inf\\{f(x,y): y \\in W_j\\} \\text{ for all } x \\in V_i\\] \\[= m_j(f, x)\\]\nThen for any \\(x \\in [a,b]\\), we have: \\[\\sum_j m_j(f) \\cdot V(W_j) \\leq \\sum_j m_j(f,x) \\cdot V(W_j)\\]\nThis is the lower sum of \\(f(x,y)\\) in the variable \\(y\\) with partition \\(P_{[c,d]}\\): \\[= L(f(x,·), P_{[c,d]})\\] \\[\\leq \\int_c^d f(x,y)dy = g(x) \\text{ for all } x\\]\nThus: \\[\\sum_i \\left(\\sum_j m_j(f) \\cdot V(W_j)\\right) \\cdot V(V_i) \\leq \\sum_i \\inf(g(x)) \\cdot V(V_i)\\]\ni.e., \\[\\sum_{i,j} m_{ij}(f) \\cdot V(W_j) \\cdot V(V_i) \\leq \\sum_i (\\inf g(x)) \\cdot V(V_i)\\]\nTherefore: \\[L(f, P_A) \\leq L(g, P_{[a,b]})\\]\nSimilarly, we have:\n\\[U(f, P_A) \\geq U(g, P_{[a,b]})\\]\nThus we have:\n\\[L(f, P_A) \\leq L(g, P_{[a,b]}) \\leq U(g, P_{[a,b]}) \\leq U(f, P_A)\\]\nBy Riemann’s criterion, if \\(f\\) is integrable on \\(A\\), then: 1. \\(g\\) is integrable on \\([a,b]\\), and 2. \\[\\int_A f = \\int_a^b g(x)dx\\]\nThis completes the proof of Fubini’s Theorem, showing that we can compute a double integral by first integrating with respect to one variable and then with respect to the other.",
    "crumbs": [
      "Notes",
      "实分析",
      "第九章",
      "积分计算"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html",
    "title": "Erise Note",
    "section": "",
    "text": "第八章的研究对象是Lebesgue积分。我们将要推导的是度量理论（measure theory）的核心内容：集合的测度（measure）和覆盖性质。\n我们主要看以下这几个方面：",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html#积分的定义",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html#积分的定义",
    "title": "Erise Note",
    "section": "1.1 积分的定义",
    "text": "1.1 积分的定义\n\n1.1.1 几何动机\n积分本质上是计算函数下方区域的「体积（volume）」。如何定义这种「体积」会直接改变到积分的性质。我们的目的是为了计算任意曲线 \\(y = f(x)\\) 从 \\(a\\) 到 \\(b\\) 下方区域的面积\nLebesgue积分定义的逻辑步骤如下：\n\n定义：任意有界函数\\(f\\)于在高维空间中的有界区域 \\(A\\) （bounded）上。\n简化问题：由于曲线下方区域通常不是规则形状，我们需要用近似方法来计算。我们可以将区间 \\([a,b]\\) 分成若干小区间，然后用矩形来近似。将区域 \\(A\\) 嵌入到一个矩形区域 \\(B\\) 中，并将函数 \\(f\\) 扩展为函数 \\(f̃\\)，使其在 \\(A\\) 之外的 \\(B\\) 上取值为零\n分割：划分矩形 \\(B\\) 为更小的矩形，来创建一个分割结构（partition）。\n构造上下近似：对每个小矩形，通过这种方式，我们可以获得两种近似：一种是偏大的（上和），一种是偏小的（下和）。\n\n上和: \\(U(f, P) = \\sum_{i=1}^{n} (\\sup f(x)) \\cdot \\ell(I_i)\\)\n对每个小区间 \\(I_i\\)，我们找出函数在该区间上的最大值 \\(\\sup f(x)\\)，然后乘以区间长度 \\(\\ell(I_i)\\)。这样形成的矩形面积之和总是大于或等于真实面积。\n下和: \\(L(f, P) = \\sum_{i=1}^{n} (\\inf f(x)) \\cdot \\ell(I_i)\\)\n对每个小区间 \\(I_i\\)，我们找出函数在该区间上的最小值 \\(\\inf f(x)\\)，然后乘以区间长度 \\(\\ell(I_i)\\)。这样形成的矩形面积之和总是小于或等于真实面积。\n\n当我们让分割变得越来越细时，上和会减小，下和会增大。它们的极限值就定义了上积分和下积分。当这两个极限值相等时，我们就说这个函数是可积的（integrable）。\n\n\n\n1.1.2 一般表述\n\n设定\nLet \\(f: A \\to \\mathbb{R}\\) be a bounded function on a bounded set \\(A\\) in \\(\\mathbb{R}^n\\). We want to define the “volume” of the region under the surface \\(y = f(x)\\) (or the integral \\(\\int_A f(x) dx\\)).\n\n\n步骤1：选择一个矩形\\(B\\)\n为了简化计算，我们首先选择一个包含 \\(A\\) 的矩形区域\\(B\\)，并将函数 \\(f\\) 扩展到整个矩形上。选择包含 \\(A\\) 的矩形 \\(B = [a_1, b_1] \\times [a_2, b_2] \\times ... \\times [a_n, b_n]\\) 并且扩展函数 \\(f\\) 使得当 \\(x \\notin A\\) 时，\\(f(x) = 0\\)\n\n\n步骤2：对B进行分割（partition）\n我们将矩形 \\(B\\) 的各边分割成若干个子区间（subintervals），得到一个分割 \\(P\\)（partition \\(P\\)）的小矩形的集合。\n\n\n步骤3：构造上下和（upper and lower sums）\n对于每个小矩形 \\(R\\)，我们找出函数在其上的最大值 \\(\\sup f(x)\\)，和最小值 \\(\\inf f(x)\\)，乘以矩形的体积 \\(V(R)\\)，然后求和。 - 上和（US）: \\[U(f, P) = \\sum_{R \\in P} (\\sup f(x)) \\cdot V(R)\\]\n\n下和 （LS）: \\[L(f, P) = \\sum_{R \\in P} (\\inf f(x)) \\cdot V(R)\\]\n\n\n\n步骤4：构造上下积分\n与一维情况相同，我们定义上积分和下积分作为US和LS的极限。所有可能分割对应的下和的上确界:\n\n上积分: \\[\\overline{\\int_A} f = \\inf_P U(f, P)\\]\n下积分: \\[\\underline{\\int_A} f = \\sup_P L(f, P)\\]\n\n\n\n重要观察\n很明显，我们有 \\(L(f, P) \\leq\\) “真实体积” \\(\\leq U(f, P)\\)。下积分和上积分分别是真实体积的下界和上界：\n\\[\\underline{\\int_{A}}f \\leq\\text{“real volume” }\\leq \\overline{\\int_A} f\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html#函数的可积性及其积分",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html#函数的可积性及其积分",
    "title": "Erise Note",
    "section": "1.2 函数的可积性及其积分",
    "text": "1.2 函数的可积性及其积分\n现在我们可以正式定义函数的可积性及其积分。\n\n[!theorem|*] 我们称函数 \\(f\\) 是黎曼可积（Riemann integrable）的，当且仅当： \\[\\overline{\\int_A} f = \\underline{\\int_A} f\\] 函数 \\(f\\) 在 \\(A\\) 上的积分定义为：\\(\\int_A f(x)dx = \\overline{\\int_A} f = \\underline{\\int_A} f\\)。\n\n\n1.2.1 一般设定：\n在我们讨论积分时，通常默认以下条件成立： 1. 函数有界：\\(f: A \\subset \\mathbb{R}^n \\to \\mathbb{R}\\) bounded； 2. 定义域有界： \\(A \\subset B\\) is bounded； 3. 矩形区域： \\(B\\) is a rectangle in \\(\\mathbb{R}^n\\)； 4. 零延拓：函数 f 在集合 A 外部定义为 0，即： \\[f(x) = 0, \\quad \\forall x \\notin A\\]\n\n\n1.2.2 黎曼条件（Riemann’s Condition）\n这意味着我们可以找到一个足够细的分割，使得上和与下和的差小于任意给定的正数 \\(\\varepsilon\\)。换句话说，随着分割变得越来越细，上和和下和会无限接近。 &gt; [!theorem|*] &gt; For \\(f\\) to be (Riemann) integrable, \\(\\forall \\varepsilon &gt; 0\\), \\(\\exists\\) partition \\(P_\\varepsilon\\) (of \\(B\\)) s.t. \\[0 \\leq U(f, P_\\varepsilon) - L(f, P_\\varepsilon) &lt; \\varepsilon\\]\n\n\n1.2.3 达布条件（Darboux’s Condition）\n达布条件是黎曼可积性的另一个等价表述。\n\n[!theorem|*] \\(\\forall \\varepsilon &gt; 0\\), \\(\\exists P_\\delta\\) s.t. if: 1. \\(P\\) is any partition of \\(B\\) into rectangles \\(B_1, B_2, ..., B_N\\) with side length \\(&lt; \\delta\\) 2. \\(x \\in B_1, x \\in B_2, ..., x \\in B_N\\), then we have: \\(\\left|\\sum_{i=1}^N f(x_i)V(B_i) - I\\right| &lt; \\varepsilon\\) where the number \\(I\\) is the value of the integral.\n\n\\(\\forall \\varepsilon &gt; 0\\)，\\(\\exists P_0\\) 使得如果： 1. \\(P\\) 是将 \\(B\\) 分割成矩形 \\(B_1, B_2, ..., B_N\\) 的任意分割，且这些矩形的边长 \\(&lt; \\delta\\) 2. 如果 \\(x \\in B_1, x \\in B_2, ..., x \\in B_N\\)，那么我们有： \\(\\left|\\sum_{i=1}^N f(x_i)V(B_i) - I\\right| &lt; \\varepsilon\\) 其中 \\(I\\) 是积分值。\n\n解释: 达布条件说的是，当分割足够细时（每个矩形的边长小于某个 \\(\\delta\\)），黎曼和（在每个小矩形上取一点计算函数值，乘以体积，然后求和）会非常接近积分值 \\(I\\)。\n\n达布条件也可以表述为： \\(\\forall \\varepsilon &gt; 0\\)，\\(\\exists\\) 分割 \\(P_{\\varepsilon}\\) 使得 \\(0 \\leq U(f, P_{\\varepsilon}) - L(f, P_{\\varepsilon}) &lt; \\varepsilon\\)\n\n解释: 这一表述与黎曼条件形式上相同，但强调了这是达布条件的一个等价形式。",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html#备注",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html#备注",
    "title": "Erise Note",
    "section": "备注",
    "text": "备注\n\n数字 \\(I\\) 是积分的值\n\n解释: \\(I\\) 代表函数 \\(f\\) 在区域 \\(A\\) 上的积分值。\n\n称为关于 \\(P\\) 的 \\(f\\) 的黎曼和\n\n解释: 黎曼和是一种近似积分的方法，根据一个分割 \\(P\\)，在每个小区域内选取一点，计算函数值，乘以区域的大小，然后求和。\n\n解释：达布条件说当分割足够细时（边长 \\(&lt; \\delta\\)），黎曼和是积分的良好近似。\n\n解释: 这表明，随着分割变得越来越细，黎曼和会收敛到真实的积分值。",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html#定理",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html#定理",
    "title": "Erise Note",
    "section": "定理",
    "text": "定理\n解释: 下面的定理表明，我们之前讨论的条件是等价的。这很重要，因为不同的条件可能在不同的情境下更容易验证或应用。\n以下条件是等价的： 1. \\(f\\) 在 \\(A\\) 上可积 - 解释: 上积分等于下积分。\n\n\\(f\\) 满足黎曼条件\n\n解释: 可以找到足够细的分割使上和与下和的差小于任意给定的正数。\n\n\\(f\\) 满足达布条件\n\n解释: 对于足够细的分割，黎曼和接近积分值。",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html#定理证明",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html#定理证明",
    "title": "Erise Note",
    "section": "定理证明",
    "text": "定理证明\n解释: 现在我们来证明这些条件的等价性。我们需要证明：1⇒2，2⇒1，以及其他等价关系。\n\n步骤1：\\(f\\) 可积 \\(\\Rightarrow\\) 黎曼条件\n解释: 首先，我们证明如果函数可积，那么它满足黎曼条件。\n假设，如果 \\(\\varepsilon &gt; 0\\)：\n因为 \\(\\overline{\\int_A} f = \\underline{\\int_A} f\\)，且根据上确界和下确界的定义， \\(\\exists P_\\varepsilon\\) 使得 \\(0 \\leq U(f, P_\\varepsilon) - L(f, P_\\varepsilon) &lt; \\varepsilon\\)\n\n解释: 由于可积性意味着上积分等于下积分，我们可以找到一个分割，使得上和和下和足够接近。\n\n\n\n步骤2：黎曼条件 \\(\\Rightarrow\\) \\(f\\) 可积\n解释: 现在，我们证明如果函数满足黎曼条件，那么它是可积的。\n假设，\\(\\forall \\varepsilon &gt; 0\\)，\\(\\exists P_\\varepsilon\\) 使得 \\(0 \\leq U(f, P_\\varepsilon) - L(f, P_\\varepsilon) &lt; \\varepsilon\\)\n因为 \\(\\overline{\\int_A} f \\leq U(f, P_\\varepsilon)\\) 且 \\(\\underline{\\int_A} f \\geq L(f, P_\\varepsilon)\\)：\n\\(\\Rightarrow 0 \\leq \\overline{\\int_A} f - \\underline{\\int_A} f \\leq U(f, P_\\varepsilon) - L(f, P_\\varepsilon) &lt; \\varepsilon\\)\n\n解释: 我们利用上积分是所有上和的下确界，而下积分是所有下和的上确界，得到上积分与下积分的差小于 \\(\\varepsilon\\)。\n\n由于 \\(\\overline{\\int_A} f - \\underline{\\int_A} f &lt; \\varepsilon\\) 对任意的 \\(\\varepsilon &gt; 0\\) 成立：\n\\(\\overline{\\int_A} f - \\underline{\\int_A} f = 0\\)\n\n解释: 如果两个数的差小于任意正数，那么它们必须相等。\n\n因此 \\(\\overline{\\int_A} f = \\underline{\\int_A} f \\Rightarrow f\\) 可积。\n\n解释: 这就证明了函数是可积的。",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.1 度量理论.html#构造细分分割",
    "href": "content/notes/理论/实分析/第八章/8.1 度量理论.html#构造细分分割",
    "title": "Erise Note",
    "section": "构造细分分割",
    "text": "构造细分分割\n解释: 在定理的证明中，我们需要构造特定的分割。下面是这一过程的详细说明。\n因为 \\(\\overline{\\int_A} f = \\inf_P U(f,P)\\)，根据下确界的定义，\\(\\exists P_1\\) 使得 \\(U(f, P_1) &lt; \\overline{\\int_A} f + \\frac{\\varepsilon}{2}\\)\n\n解释: 我们可以找到一个分割 \\(P_1\\)，使得它对应的上和与上积分的差小于 \\(\\frac{\\varepsilon}{2}\\)。\n\n类似地，\\(\\exists\\) 分割 \\(P_2\\) 使得 \\(L(f, P_2) &gt; \\underline{\\int_A} f - \\frac{\\varepsilon}{2}\\)\n\n解释: 同样，我们可以找到一个分割 \\(P_2\\)，使得它对应的下和与下积分的差小于 \\(\\frac{\\varepsilon}{2}\\)。\n\n设 \\(P_\\varepsilon = P_1 \\cup P_2\\)（共同细分）\n\n解释: 我们将两个分割合并，得到一个新的、更细的分割。\n\n那么 \\(P_\\varepsilon\\) 是 \\(P_1\\) 和 \\(P_2\\) 的细分。\n细分的性质： - \\(U(f, P_\\varepsilon) \\leq U(f, P_1)\\)（细分会使上和减小） - 解释: 当分割变得更细时，上和不会增加，因为我们更准确地逼近了函数的最大值。\n\n\\(L(f, P_\\varepsilon) \\geq L(f, P_2)\\)（细分会使下和增大）\n\n解释: 当分割变得更细时，下和不会减小，因为我们更准确地逼近了函数的最小值。\n\n\n因此： \\(U(f, P_\\varepsilon) - L(f, P_\\varepsilon) \\leq U(f, P_1) - L(f, P_2)\\)\n\\(&lt; (\\overline{\\int_A} f + \\frac{\\varepsilon}{2}) - (\\underline{\\int_A} f - \\frac{\\varepsilon}{2})\\)\n\\(= \\overline{\\int_A} f - \\underline{\\int_A} f + \\varepsilon = 0 + \\varepsilon = \\varepsilon\\)\n\n解释: 通过上述不等式链，我们证明了 \\(P_\\varepsilon\\) 对应的上和与下和的差小于 \\(\\varepsilon\\)，这就是黎曼条件。\n\n\\(\\Rightarrow\\) 黎曼条件\n因此 \\(\\overline{\\int_A} f = \\underline{\\int_A} f \\Rightarrow f\\) 可积。\n\n解释: 这完成了证明：黎曼条件蕴含函数可积。通过证明这些条件的等价性，我们深入理解了可积性的本质，并为积分的计算和应用奠定了基础。",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "1.1 积分的定义"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.3 Proof of Lebesgue's Theorem.html",
    "href": "content/notes/理论/实分析/第八章/8.3 Proof of Lebesgue's Theorem.html",
    "title": "Erise Note",
    "section": "",
    "text": "[!theorem|8.?.?] Let \\(f : A \\subset \\mathbb{R} \\to \\mathbb{R}\\) be a bounded function on a bounded set \\(A\\). Then \\(f\\) is integrable on \\(A\\) if and only if the set of discontinuities for the extended \\(f(x)\\) has measure zero.",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "Proof of the Theorem"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.3 Proof of Lebesgue's Theorem.html#proof-of-the-theorem",
    "href": "content/notes/理论/实分析/第八章/8.3 Proof of Lebesgue's Theorem.html#proof-of-the-theorem",
    "title": "Erise Note",
    "section": "Proof of the Theorem",
    "text": "Proof of the Theorem\n\nStep 1: Preparation\n\nDiagram: a set \\(A\\) enclosed in set \\(B\\). #### (a): Set Up\nFix rectangle \\(B\\) with \\(\\overline{A} \\subset \\text{int}(B)\\) and let: \\[\ng(x) = \\begin{cases}  \nf(x) & \\text{if } x \\in A \\\\  \n0 & \\text{if } x \\notin A  \n\\end{cases}\n\\]\nDefine: \\[\nD = \\{ x \\in B \\mid g \\text{ is not continuous at } x \\}\n\\]\nNeed to show: \\[\nf \\text{ integrable } \\Leftrightarrow m(D) = 0\n\\] #### (b): How to Measure Discontinuity\nOscillation of a function \\(h\\) at a point \\(x_0\\): \\[O(h, x_0) = \\inf  \\{ \\sup \\left\\{ h(x) - h(y) : x, y \\in U \\} : U \\text{ is a neighborhood of } x_0 \\right\\}\\]\nFact: \\(h\\) is continuous at \\(x_0\\) if and only if \\(O(h, x_0) = 0\\). ### Step 2: Assume \\(m(D) = 0\\). Prove \\(f\\) integrable\nWill show \\(g\\) satisfying Riemann’s Condition.\n\n(a) Setup: - Fix \\(\\epsilon &gt; 0\\). Let\n\\[D_{\\epsilon} = \\{ x \\in B : O(g, x) \\geq \\epsilon \\}\\]\n\nThen \\(D_{\\epsilon} \\subset D \\implies m(D_{\\epsilon}) = 0\\)\nBy definition, there exists a collection of open rectangles \\(\\{ B_i \\}\\) such that:\n\n\\[D_{\\epsilon} \\subset \\bigcup_i B_i \\quad  ext{and} \\quad \\sum v(B_i) &lt; \\epsilon\\]\nClaim: \\(D_{\\epsilon}\\) is closed (hence compact).\n\nAssume \\(x_n \\in D_{\\epsilon},  x \\rightarrow x \\implies x \\in D_{\\epsilon}\\) (Assume that \\(x\\ne D_{\\epsilon}\\)) \\[O(g, x_n) \\geq \\epsilon \\implies O(g, x) \\geq \\epsilon\\]\n\n\n(b) Partition of \\(B\\)\n\nConstruct a partition \\(P\\) from \\(\\{ B_i \\}_{i=1}^N\\) such that each rectangle \\(S \\in P\\) is either:\n\nDisjoint from \\(D_{\\epsilon}\\), or\nIts interior is contained in one of the \\(B_i\\)\n\n\nLet: - \\(C_1 = \\{ S \\in P :   \\text{int}(S)   \\text{ is contained in one of the } B_i \\}\\) - \\(C_2 = \\{ S \\in P : S \\cap D_{\\epsilon} = \\emptyset \\}\\)\n\n\n(c) Refinement of \\(P\\)\n\nFix \\(S \\in C_2\\)\n\\(S \\cap D_{\\epsilon} = \\emptyset \\implies O(g, x) &lt; \\epsilon \\,\\, \\forall x \\in S\\)\nThus, \\(\\forall x \\in S, \\exists\\) a neighborhood \\(U_x\\) such that:\n\n\\[\\Longrightarrow\\sup \\{ |g(x_1) - g(x_2)| : x_1, x_2 \\in U_x \\} &lt; O(g, x) + \\delta,\\quad \\delta = \\frac{1}{2} (\\epsilon - O(g, x))\\]\n\nTherefore: \\[\\sup_{U_x} g - \\inf_{U_x} g &lt; O(g, x) + 2\\delta = \\epsilon\\]\n\n\\(i.e. \\quad M_{U_x}(g) - m_{U_x}(g) &lt; \\epsilon.\\)\n\n\nSince \\(S\\) is compact, \\(S \\subset \\bigcup_{x \\in S} U_x \\implies \\exists\\) finite collection of neighborhoods \\(\\{ U_{x_i} \\}\\) that covers \\(S\\).\nPosition \\(S\\) so that each rectangle is contained in some \\(U_{x_i}\\).\nDo this for each \\(S \\in C_2\\)\nWe obtain a refinement of \\(P\\), denoted by \\(P'\\). ### (d) Verify Riemman condition for \\(P'\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "Proof of the Theorem"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html",
    "title": "8.6 勒贝格收敛定理",
    "section": "",
    "text": "When do we have: \\[\\lim_{n\\to\\infty}\\int_A f_n(x)dx = \\int_A(\\lim_{n\\to\\infty}f_n(x))dx?\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#main-question",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#main-question",
    "title": "8.6 勒贝格收敛定理",
    "section": "",
    "text": "When do we have: \\[\\lim_{n\\to\\infty}\\int_A f_n(x)dx = \\int_A(\\lim_{n\\to\\infty}f_n(x))dx?\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#lebesgue-monotone-convergence-theorem-theorem-8.6.1",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#lebesgue-monotone-convergence-theorem-theorem-8.6.1",
    "title": "8.6 勒贝格收敛定理",
    "section": "Lebesgue Monotone Convergence Theorem (Theorem 8.6.1)",
    "text": "Lebesgue Monotone Convergence Theorem (Theorem 8.6.1)\nLet \\(g_n: [0,1] \\to \\mathbb{R}\\) be a sequence of non-negative measurable functions such that:\n\n\\(g_{n+1}(x) \\leq g_n(x)\\) \\(\\forall x\\) (decreasing sequence)\n\\(\\lim_{n\\to\\infty} g_n(x) = 0\\) \\(\\forall x \\in [0,1]\\)\n\nThen: \\[\\lim_{n\\to\\infty}\\int_0^1 g_n(x)dx = \\int_0^1 0 dx = 0\\]",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#proof-details",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#proof-details",
    "title": "8.6 勒贝格收敛定理",
    "section": "Proof Details",
    "text": "Proof Details\nFor LMCT to hold, we only need:\n\n\\(f_n(x) \\leq f_{n+1}(x) \\leq f(x)\\) \\(\\forall x\\)\n\\(f_n(x) \\to f(x)\\), \\(\\forall x\\)\n\nThis implies: \\(f_n(x) \\uparrow f(x)\\)\nThe assumption \\(A \\subset [0,1] \\subset \\mathbb{R}\\) is not essential. Result is true for any set \\(A \\subset \\mathbb{R}^n\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#the-monotonicity-assumption-cannot-be-removed",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#the-monotonicity-assumption-cannot-be-removed",
    "title": "8.6 勒贝格收敛定理",
    "section": "The Monotonicity Assumption Cannot Be Removed",
    "text": "The Monotonicity Assumption Cannot Be Removed\n\nExample\n\\(g_n(x) = \\begin{cases}\nn, & 0 &lt; x &lt; \\frac{1}{n} \\\\\n0, & \\text{else}\n\\end{cases}\\)\nNote that: - \\(g_n(x) \\to 0\\) \\(\\forall x \\in [0,1]\\) - \\(\\int_0^1 g_n(x)dx = 1\\) \\(\\forall n\\)\nTherefore \\(\\lim_{n\\to\\infty}\\int_0^1 g_n(x)dx = 1 \\neq 0 = \\int_0^1 0 dx\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#nd-part-of-lmct",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#nd-part-of-lmct",
    "title": "8.6 勒贝格收敛定理",
    "section": "2nd Part of LMCT",
    "text": "2nd Part of LMCT\n\nLemma\nSuppose \\(f: [0,1] \\to \\mathbb{R}\\) is measurable with \\(|f| \\leq M\\) and \\(\\int_0^1 f \\geq \\alpha &gt; 0\\). Then the set: \\(E = \\{x \\in [0,1]: f(x) \\geq \\frac{\\alpha}{2}\\}\\) contains a finite union of disjoint open intervals of total length \\(\\geq \\frac{\\alpha}{4M}\\)\n\n\nResult\n\\(0 \\leq \\int_0^1 f - L(f,P) \\leq \\frac{\\alpha}{4}\\)\nWhere \\(L\\) denotes the total length of intervals \\(I \\in P\\) with \\(I \\subset E\\).\nThen: \\[\\frac{3\\alpha}{4} &lt; L(f, P) = \\sum_{I \\in P} \\left(\\inf_{I}(f(x))\\right)\\ell(I)\\]\n\\[= \\sum_{I \\subset E} + \\sum_{I \\not\\subset E} \\left(\\inf_{I}(f(x))\\right)\\ell(I)\\]\n\\[\\leq \\sum_{I \\subset E} M\\ell(I) + \\sum_{I} \\frac{\\alpha}{2}\\ell(I)\\]\n\\[\\leq \\ell M + \\frac{\\alpha}{2} \\cdot 1\\]\nSince \\(\\ell M &gt; \\frac{3\\alpha}{4} - \\frac{\\alpha}{2} = \\frac{\\alpha}{4}\\), we can conclude:\n\\[\\ell &gt; \\frac{\\alpha}{4M}\\]\nThis completes the proof of the lemma, demonstrating that the set \\(E\\) contains intervals with sufficient total length, which is a key component in establishing the Lebesgue Monotone Convergence Theorem.\nThe boxed result at the end confirms that \\(\\ell &gt; \\frac{\\alpha}{4M}\\), which validates our earlier assertion about the minimum total length of the intervals in set \\(E\\).",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#proof-of-theorem-8.6.1-lmct",
    "href": "content/notes/理论/实分析/第八章/8.6 Lebesgue Convergence Theorem.html#proof-of-theorem-8.6.1-lmct",
    "title": "8.6 勒贝格收敛定理",
    "section": "Proof of Theorem 8.6.1 (LMCT)",
    "text": "Proof of Theorem 8.6.1 (LMCT)\n\nStep 1: Setup\nGiven: - \\(0 \\leq g_{n+1} \\leq g_n\\) implies \\(\\int_0^1 g_{n+1}(x) \\leq \\int_0^1 g_n(x)\\) - This leads to the limit: \\(\\lim_{n\\to\\infty}\\int_0^1 g_n(x) = \\lambda \\geq 0\\)\nWe need to show that \\(\\lambda = 0\\).\nAssuming \\(\\lambda &gt; 0\\) will lead to a contradiction (using our assumption that \\(g_n(x) \\to 0\\) \\(\\forall x \\in [0,1]\\)).\n\n\nStep 2: Application of Lemma\nWe apply the previously established lemma to the cut-off function:\n\\[(g_n)_M = \\begin{cases}\ng_n(x), & g_n(x) \\leq M \\\\\nM, & g_n(x) &gt; M\n\\end{cases}\\]\nThis implies:\n\\[\\int_0^1 g_n(x) dx = \\lim_{M \\to \\infty} \\int_0^1 (g_n)_M\\] 选择 \\(m&gt; \\frac{2\\lambda}{5}\\) s.t. \\[0 \\leq \\int^{1}_{0}(g_{n}-(g_{n})_{M})$\\leq \\int^{1}_{0}(g_{1}-(g_{1})_{M})\\leq \\frac{\\lambda}{5}\\] 我们让\\(E_{n}=\\left\\{ x\\in[1,0]:g_{n}(x)\\geq \\frac{2\\lambda}{5} \\right\\}\\)，然后 - \\(E_{n+1}\\subset E_{n}\\) - \\(\\{x \\in [0,1] : (g_n)_M(x) \\geq \\frac{\\alpha}{2}\\} \\subset E_n\\) where we choose \\(\\alpha\\) such that \\(\\frac{2\\lambda}{5} = \\frac{\\alpha}{2}\\), giving us \\(\\alpha = \\frac{4\\lambda}{5}\\)\n\n\nKey Step:\nApplying the lemma to \\((g_n)_M\\) with \\(\\alpha = \\frac{4\\lambda}{5}\\): this implies \\(E_n\\) contains a finite union of disjoint open intervals of total length: \\[\\ell \\geq \\frac{\\alpha}{4M} = \\frac{\\lambda}{5M}\\]\n\n\nStep 3:\nShow that \\(\\bigcap_{n=1}^{\\infty} E_n = \\emptyset\\)\nLet \\(D = \\bigcap_{n=1}^{\\infty} \\{x \\in [0,1] : g_n \\text{ not converging to } 0\\} = \\bigcap_{n=1}^{\\infty} D_n\\)\nThen \\(g_{n}\\) intagrable \\(\\Rightarrow m(D_n) = 0 = m(D) = 0\\).\nThus \\(D\\) is covered by \\(U\\), a countable union of open intervals of total length \\(&lt; \\frac{\\lambda}{5M}\\).\nBy Step 2,\n\\(E_n \\subset U\\)",
    "crumbs": [
      "Notes",
      "实分析",
      "第八章 度量理论",
      "8.6 勒贝格收敛定理"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第六章/6.4 Sufficient Conditions for Differentiability.html",
    "href": "content/notes/理论/实分析/第六章/6.4 Sufficient Conditions for Differentiability.html",
    "title": "6.4 可微分性的必要条件",
    "section": "",
    "text": "Recall: A necessary condition for differentiability: \\[\n\\boxed{ f \\text{ differentiable} \\Rightarrow f \\text{ is continuous} }\n\\]\nContinuity is a requirement. ## 2. Sufficient Conditions for Differentiability (a) Partial derivatives and differentiability f differentiable \\(\\Rightarrow\\) continuity + partials exists conditions + partials exists \\(\\Rightarrow f\\) differentiable (?)\n\n\n\n\nConsider the function defined as:\n\\[\nf(x,y) =\n\\begin{cases}\n\\frac{xy}{x^2 + y^2}, & (x,y) \\neq (0,0) \\\\\n0, & (x,y) = (0,0)\n\\end{cases}\n\\]\n\n\n\nWe analyze the limit:\n\\[\n|xy| \\leq \\frac{1}{2} (x^2 + y^2)\n\\]\nwhich implies:\n\\[\nf(x,y) \\to 0 \\quad \\text{as} \\quad (x,y) \\to (0,0)\n\\]\nThus, ( f ) is continuous at ( (0,0) ).",
    "crumbs": [
      "Notes",
      "实分析",
      "第六章 可微映射",
      "6.4 可微分性的必要条件"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第六章/6.4 Sufficient Conditions for Differentiability.html#necessary-condition-for-differentiability",
    "href": "content/notes/理论/实分析/第六章/6.4 Sufficient Conditions for Differentiability.html#necessary-condition-for-differentiability",
    "title": "6.4 可微分性的必要条件",
    "section": "",
    "text": "Recall: A necessary condition for differentiability: \\[\n\\boxed{ f \\text{ differentiable} \\Rightarrow f \\text{ is continuous} }\n\\]\nContinuity is a requirement. ## 2. Sufficient Conditions for Differentiability (a) Partial derivatives and differentiability f differentiable \\(\\Rightarrow\\) continuity + partials exists conditions + partials exists \\(\\Rightarrow f\\) differentiable (?)\n\n\n\n\nConsider the function defined as:\n\\[\nf(x,y) =\n\\begin{cases}\n\\frac{xy}{x^2 + y^2}, & (x,y) \\neq (0,0) \\\\\n0, & (x,y) = (0,0)\n\\end{cases}\n\\]\n\n\n\nWe analyze the limit:\n\\[\n|xy| \\leq \\frac{1}{2} (x^2 + y^2)\n\\]\nwhich implies:\n\\[\nf(x,y) \\to 0 \\quad \\text{as} \\quad (x,y) \\to (0,0)\n\\]\nThus, ( f ) is continuous at ( (0,0) ).",
    "crumbs": [
      "Notes",
      "实分析",
      "第六章 可微映射",
      "6.4 可微分性的必要条件"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第六章/6.6 Product Rule and Gradients.html",
    "href": "content/notes/理论/实分析/第六章/6.6 Product Rule and Gradients.html",
    "title": "6.6 乘积法则与梯度",
    "section": "",
    "text": "[ ]",
    "crumbs": [
      "Notes",
      "实分析",
      "第六章 可微映射",
      "6.6 乘积法则与梯度"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第六章/index.html",
    "href": "content/notes/理论/实分析/第六章/index.html",
    "title": "第六章 可微映射",
    "section": "",
    "text": "6.4 可微分性的必要条件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.5 链式法则\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.6 乘积法则与梯度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n6.9 泰勒公式的高维形式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "实分析",
      "第六章 可微映射"
    ]
  },
  {
    "objectID": "content/notes/理论/实分析/第十章/index.html",
    "href": "content/notes/理论/实分析/第十章/index.html",
    "title": "第十章",
    "section": "",
    "text": "Gaussian Integral Computation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "实分析",
      "第十章"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/3. Index Notation.html",
    "href": "content/notes/理论/广义相对论/广义相对论理论/3. Index Notation.html",
    "title": "指标",
    "section": "",
    "text": "把时空想成有 4 个抽屉：\n\n抽屉 0 装时间： \\(x^0=c t\\)\n抽屉 1－3 装空间： \\(x^1=x, x^2=y, x^3=z\\) 。\n\n符号 \\(\\mu, \\nu\\) 是“拿第几个抽屉”的编号（0／1／2／3）。世界里有两种＂数＂的角色： 1. vector（箭头）：告诉你＂往各抽屉方向走多少＂。写成上标。 2. covector（尺子）：告诉你＂走这些，会被量出多少＂。写成下标。\n直觉上说，上标＝箭头的大小；下标＝尺子（怎么量这个大小）\n\n\n\n因为把＂箭头＂和＂尺子／价格表＂配对，就会得到一个不侬赖坐标的纯数字（这才是物理量应该有的样子）：\n\\[\nb_\\mu a^\\mu=\\text { 把同一编号的上、下配对相乘后相加 (自动求和) . }\n\\]\n这就是爱因斯坦求和规则的用意：同一项里＂同一编号一次上、一次下＂就自动相加。比如 \\(a^i b_i\\) 会自动求和；而 \\(a_i b_i\\)（两个下标）不会。",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "指标"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/3. Index Notation.html#四个抽屉和两种角色",
    "href": "content/notes/理论/广义相对论/广义相对论理论/3. Index Notation.html#四个抽屉和两种角色",
    "title": "指标",
    "section": "",
    "text": "把时空想成有 4 个抽屉：\n\n抽屉 0 装时间： \\(x^0=c t\\)\n抽屉 1－3 装空间： \\(x^1=x, x^2=y, x^3=z\\) 。\n\n符号 \\(\\mu, \\nu\\) 是“拿第几个抽屉”的编号（0／1／2／3）。世界里有两种＂数＂的角色： 1. vector（箭头）：告诉你＂往各抽屉方向走多少＂。写成上标。 2. covector（尺子）：告诉你＂走这些，会被量出多少＂。写成下标。\n直觉上说，上标＝箭头的大小；下标＝尺子（怎么量这个大小）",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "指标"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/3. Index Notation.html#为什么一定要分成两种",
    "href": "content/notes/理论/广义相对论/广义相对论理论/3. Index Notation.html#为什么一定要分成两种",
    "title": "指标",
    "section": "",
    "text": "因为把＂箭头＂和＂尺子／价格表＂配对，就会得到一个不侬赖坐标的纯数字（这才是物理量应该有的样子）：\n\\[\nb_\\mu a^\\mu=\\text { 把同一编号的上、下配对相乘后相加 (自动求和) . }\n\\]\n这就是爱因斯坦求和规则的用意：同一项里＂同一编号一次上、一次下＂就自动相加。比如 \\(a^i b_i\\) 会自动求和；而 \\(a_i b_i\\)（两个下标）不会。",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论",
      "指标"
    ]
  },
  {
    "objectID": "content/notes/理论/广义相对论/广义相对论理论/index.html",
    "href": "content/notes/理论/广义相对论/广义相对论理论/index.html",
    "title": "广义相对论理论",
    "section": "",
    "text": "Einstein求和约定\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n四维向量\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n张量方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指标\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "广义相对论",
      "广义相对论理论"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html",
    "href": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html",
    "title": "Parametrized Curves in \\(\\mathbb{R}^3\\)",
    "section": "",
    "text": "Let \\(I\\subset \\mathbb{R}\\) be an open interval. A (smooth) curve is a map \\[\n\\gamma:I\\to\\mathbb{R}^3,\\qquad \\gamma\\in C^\\infty,\n\\] Therefore, \\(\\gamma(t)\\) is a parametrization, as the position of a moving point in space at time \\(t\\), that is: \\[t \\mapsto \\gamma(t)=(x(t), y(t), z(t))\\] We write \\(\\dot\\gamma(t)=\\dfrac{d\\gamma}{dt}(t)\\) for its velocity.\n\\begin{document}\n\\begin{tikzpicture}[line cap=round,line join=round,&gt;=stealth,thick,scale=2.5]\n  % curve with arrowhead at the end\n  \\draw[-&gt;] plot[smooth, tension=0.8] coordinates {(0,0.2) (1.2,0.8) (2.6,0.3) (4.0,0.7)};\n  % marked point on the curve\n  \\fill[black] (1.2,0.8) circle (0.7pt);\n  \\draw (1.2,0.8) circle (0.4pt);\n  % tangent/velocity arrow starting at the marked point\n  \\draw[-&gt;] (1.2,0.8) -- (2.1,0.8);\n  % labels\n  \\node[above] at (2.15,0.9) {\\large $\\dot{\\gamma}$};\n  \\node[right] at (2.4,1) {\\large (velocity)};\n\\end{tikzpicture}\n\\end{document}\n\n[!definition|1.1] regular curve a curve \\(\\gamma\\) is regular if \\(\\dot\\gamma(t)\\neq 0\\) for all \\(t\\in I\\).\n\nNote: any regular curve cannot be a zero vector. ## 1.1 Arc-Length\n\n[!definition|1.1.1] Arc-length function Fix \\(t_0\\in I\\). The arc-length from \\(t_0\\) to \\(t\\in I\\) is \\[\ns(t)=\\int_{t_0}^{t}\\bigl\\lVert \\dot\\gamma(\\tau)\\bigr\\rVert\\,d\\tau\n\\] for fixed \\(t_{0} \\in I\\).\n\nIf a vector is nonzero, its norm should be strictly positive. From the Fundamental Theorem of Calculus, \\[\n\\frac{ds}{dt}=\\|\\dot{\\gamma}(t)\\| \\quad\\text{(speed)}&gt;0\\ \\text{for regular curves}.\n\\] For a regular curve, since\\(\\dfrac{ds}{dt}&gt;0\\), \\(s(t)\\) is strictly increasing and smooth.\n\n\nBy the Inverse Function Theorem, the monotone smooth map \\(s:I\\to s(I)\\) has a \\(C^\\infty\\) inverse function \\(t=t(s)\\). Define the unit-speed reparametrization \\[\n\\widetilde\\gamma(s)=\\gamma\\!\\bigl(t(s)\\bigr),\\qquad s\\in s(I).\n\\] Then \\[\n\\begin{aligned}\n\\frac{d\\widetilde\\gamma}{ds}\n&=\\dot\\gamma\\bigl(t(s)\\bigr)\\,\\frac{dt}{ds}\n=\\dot\\gamma\\bigl(t(s)\\bigr)\\,\\frac{1}{\\lVert \\dot\\gamma\\bigl(t(s)\\bigr)\\rVert},\n\\end{aligned}\n\\] so \\(\\lVert \\widetilde\\gamma(s)\\rVert=1\\) for all \\(s\\).\n\n[!Lemma|1.2.1] unit-speed reparametrization Every regular curve admits a reparametrization by arclength, writing \\(\\gamma(s):=\\gamma\\big(t(s)\\big)\\) so that \\(\\|\\dot{\\gamma}(s)\\|=1\\) (unit-speed) ## 1.3 Example: Circle of radius \\(r\\) and angular velocity \\(\\omega\\) Let \\[\n\\gamma(t)=\\big(r\\cos(\\omega t),\\, r\\sin(\\omega t)\\big),\\qquad t\\in\\mathbb{R}.\n\\]\n\nSpeed \\[\n\\|\\dot\\gamma(t)\\|=\\|(-r\\omega\\sin(\\omega t),\\, r\\omega\\cos(\\omega t))\\|=r\\omega.\n\\]\nArc length and inversion (take \\(s(0)=0\\)) \\[\ns(t)=\\int_0^t \\|\\dot\\gamma(u)\\|\\,du=r\\omega t,\n\\qquad\nt=\\frac{s}{r\\omega}.\n\\]\nUnit-speed form \\[\n\\gamma(s)=\\gamma\\!\\left(\\tfrac{s}{r\\omega}\\right)\n=\\big(r\\cos(\\tfrac{s}{r}),\\, r\\sin(\\tfrac{s}{r})\\big).\n\\]\nDerivatives w.r.t. \\(s\\) \\[\n\\gamma'(s)=\\Big(-\\sin\\!\\big(\\tfrac{s}{r}\\big),\\, \\cos\\!\\big(\\tfrac{s}{r}\\big)\\Big),\\quad\n\\|\\gamma'(s)\\|=1,\n\\] \\[\n\\gamma''(s)=\\Big(-\\tfrac{1}{r}\\cos\\!\\big(\\tfrac{s}{r}\\big),\\, -\\tfrac{1}{r}\\sin\\!\\big(\\tfrac{s}{r}\\big)\\Big),\\quad\n\\|\\gamma''(s)\\|=\\tfrac{1}{r}.\n\\] Hence the curvature of the circle is \\(\\kappa=\\dfrac{1}{r}\\).\n\n\n\n\n[!definition|1.4.1] Curvature (unit speed) For a unit-speed curve \\(\\gamma(s)\\), \\[\n\\kappa(s)=\\|\\gamma''(s)\\|.\n\\]\n\n\n\n\\[\n\\begin{aligned}\n\\gamma'(s)\\cdot\\gamma'(s)&=1 \\\\\n\\Rightarrow\\quad 2\\,\\gamma'(s)\\cdot\\gamma''(s)&=0 \\\\\n\\Rightarrow\\quad \\gamma'(s)&\\perp \\gamma''(s).\n\\end{aligned}\n\\]\n\n\n\nLet \\(v:=\\dfrac{ds}{dt}=\\|\\dot\\gamma(t)\\|\\) be the speed. Then \\[\n\\begin{aligned}\n\\frac{d}{dt}&=v\\,\\frac{d}{ds},\\qquad\n\\frac{d}{ds}=\\frac{1}{v}\\,\\frac{d}{dt},\\\\\n\\frac{d\\gamma}{ds}&=\\frac{1}{v}\\,\\dot\\gamma(t),\\\\\n\\frac{d^2\\gamma}{ds^2}\n&=\\frac{1}{v}\\frac{d}{dt}\\left(\\frac{\\dot\\gamma}{v}\\right)\n=\\frac{v\\,\\ddot\\gamma-\\dot v\\,\\dot\\gamma}{v^3}.\n\\end{aligned}\n\\]\n\n\n\n\\[\n\\boxed{\\ \\kappa(t)=\\left\\lVert \\frac{d^2\\gamma}{ds^2}\\right\\rVert\n=\\frac{\\big\\|\\,v\\,\\ddot{\\gamma}(t)-\\dot{v}\\,\\dot{\\gamma}(t)\\,\\big\\|}{v(t)^3}\\ }\n\\qquad v=\\|\\dot\\gamma(t)\\|.\n\\] In \\(\\mathbb{R}^3\\) one may also use \\[\n\\boxed{\\ \\kappa(t)=\\dfrac{\\|\\dot{\\gamma}(t)\\times\\ddot{\\gamma}(t)\\|}{\\|\\dot{\\gamma}(t)\\|^3}\\ }\n\\]",
    "crumbs": [
      "Notes",
      "微分几何",
      "Parametrized Curves in $\\mathbb{R}^3$"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#re-parametrization-by-arc-length",
    "href": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#re-parametrization-by-arc-length",
    "title": "Parametrized Curves in \\(\\mathbb{R}^3\\)",
    "section": "",
    "text": "By the Inverse Function Theorem, the monotone smooth map \\(s:I\\to s(I)\\) has a \\(C^\\infty\\) inverse function \\(t=t(s)\\). Define the unit-speed reparametrization \\[\n\\widetilde\\gamma(s)=\\gamma\\!\\bigl(t(s)\\bigr),\\qquad s\\in s(I).\n\\] Then \\[\n\\begin{aligned}\n\\frac{d\\widetilde\\gamma}{ds}\n&=\\dot\\gamma\\bigl(t(s)\\bigr)\\,\\frac{dt}{ds}\n=\\dot\\gamma\\bigl(t(s)\\bigr)\\,\\frac{1}{\\lVert \\dot\\gamma\\bigl(t(s)\\bigr)\\rVert},\n\\end{aligned}\n\\] so \\(\\lVert \\widetilde\\gamma(s)\\rVert=1\\) for all \\(s\\).\n\n[!Lemma|1.2.1] unit-speed reparametrization Every regular curve admits a reparametrization by arclength, writing \\(\\gamma(s):=\\gamma\\big(t(s)\\big)\\) so that \\(\\|\\dot{\\gamma}(s)\\|=1\\) (unit-speed) ## 1.3 Example: Circle of radius \\(r\\) and angular velocity \\(\\omega\\) Let \\[\n\\gamma(t)=\\big(r\\cos(\\omega t),\\, r\\sin(\\omega t)\\big),\\qquad t\\in\\mathbb{R}.\n\\]\n\nSpeed \\[\n\\|\\dot\\gamma(t)\\|=\\|(-r\\omega\\sin(\\omega t),\\, r\\omega\\cos(\\omega t))\\|=r\\omega.\n\\]\nArc length and inversion (take \\(s(0)=0\\)) \\[\ns(t)=\\int_0^t \\|\\dot\\gamma(u)\\|\\,du=r\\omega t,\n\\qquad\nt=\\frac{s}{r\\omega}.\n\\]\nUnit-speed form \\[\n\\gamma(s)=\\gamma\\!\\left(\\tfrac{s}{r\\omega}\\right)\n=\\big(r\\cos(\\tfrac{s}{r}),\\, r\\sin(\\tfrac{s}{r})\\big).\n\\]\nDerivatives w.r.t. \\(s\\) \\[\n\\gamma'(s)=\\Big(-\\sin\\!\\big(\\tfrac{s}{r}\\big),\\, \\cos\\!\\big(\\tfrac{s}{r}\\big)\\Big),\\quad\n\\|\\gamma'(s)\\|=1,\n\\] \\[\n\\gamma''(s)=\\Big(-\\tfrac{1}{r}\\cos\\!\\big(\\tfrac{s}{r}\\big),\\, -\\tfrac{1}{r}\\sin\\!\\big(\\tfrac{s}{r}\\big)\\Big),\\quad\n\\|\\gamma''(s)\\|=\\tfrac{1}{r}.\n\\] Hence the curvature of the circle is \\(\\kappa=\\dfrac{1}{r}\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "Parametrized Curves in $\\mathbb{R}^3$"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#curvature",
    "href": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#curvature",
    "title": "Parametrized Curves in \\(\\mathbb{R}^3\\)",
    "section": "",
    "text": "[!definition|1.4.1] Curvature (unit speed) For a unit-speed curve \\(\\gamma(s)\\), \\[\n\\kappa(s)=\\|\\gamma''(s)\\|.\n\\]\n\n\n\n\\[\n\\begin{aligned}\n\\gamma'(s)\\cdot\\gamma'(s)&=1 \\\\\n\\Rightarrow\\quad 2\\,\\gamma'(s)\\cdot\\gamma''(s)&=0 \\\\\n\\Rightarrow\\quad \\gamma'(s)&\\perp \\gamma''(s).\n\\end{aligned}\n\\]\n\n\n\nLet \\(v:=\\dfrac{ds}{dt}=\\|\\dot\\gamma(t)\\|\\) be the speed. Then \\[\n\\begin{aligned}\n\\frac{d}{dt}&=v\\,\\frac{d}{ds},\\qquad\n\\frac{d}{ds}=\\frac{1}{v}\\,\\frac{d}{dt},\\\\\n\\frac{d\\gamma}{ds}&=\\frac{1}{v}\\,\\dot\\gamma(t),\\\\\n\\frac{d^2\\gamma}{ds^2}\n&=\\frac{1}{v}\\frac{d}{dt}\\left(\\frac{\\dot\\gamma}{v}\\right)\n=\\frac{v\\,\\ddot\\gamma-\\dot v\\,\\dot\\gamma}{v^3}.\n\\end{aligned}\n\\]\n\n\n\n\\[\n\\boxed{\\ \\kappa(t)=\\left\\lVert \\frac{d^2\\gamma}{ds^2}\\right\\rVert\n=\\frac{\\big\\|\\,v\\,\\ddot{\\gamma}(t)-\\dot{v}\\,\\dot{\\gamma}(t)\\,\\big\\|}{v(t)^3}\\ }\n\\qquad v=\\|\\dot\\gamma(t)\\|.\n\\] In \\(\\mathbb{R}^3\\) one may also use \\[\n\\boxed{\\ \\kappa(t)=\\dfrac{\\|\\dot{\\gamma}(t)\\times\\ddot{\\gamma}(t)\\|}{\\|\\dot{\\gamma}(t)\\|^3}\\ }\n\\]",
    "crumbs": [
      "Notes",
      "微分几何",
      "Parametrized Curves in $\\mathbb{R}^3$"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#coordinate-patches",
    "href": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#coordinate-patches",
    "title": "Parametrized Curves in \\(\\mathbb{R}^3\\)",
    "section": "2.1 Coordinate Patches",
    "text": "2.1 Coordinate Patches\n\n[!definition|2.1.1] coordinate patch (regular parametrization) A patch is a \\(C^\\infty\\) map \\[\nX:U\\to\\mathbb{R}^3,\n\\] where \\(U\\subset\\mathbb{R}^2\\) is open and connected, such that \\(DX\\) has rank \\(2\\) (i.e., it is regular). With coordinates \\((u^1,u^2)\\) on \\(U\\), set the coordinate vectors \\[\n\\sigma_i:=\\frac{\\partial X}{\\partial u^i}\\in\\mathbb{R}^3,\\quad i=1,2,\n\\] which are linearly independent at each point.\n\n(We use the Einstein summation convention to track how objects transform under coordinate changes.)",
    "crumbs": [
      "Notes",
      "微分几何",
      "Parametrized Curves in $\\mathbb{R}^3$"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#smooth-surfaces",
    "href": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#smooth-surfaces",
    "title": "Parametrized Curves in \\(\\mathbb{R}^3\\)",
    "section": "2.2 Smooth Surfaces",
    "text": "2.2 Smooth Surfaces\n\n[!definition|2.2.1] smooth surface A smooth surface \\(S\\subset\\mathbb{R}^3\\) is a set equipped with an atlas of regular patches \\(\\{X_\\alpha:U_\\alpha\\to S\\}\\) covering \\(S\\).",
    "crumbs": [
      "Notes",
      "微分几何",
      "Parametrized Curves in $\\mathbb{R}^3$"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#transition-maps-and-smoothness",
    "href": "content/notes/理论/微分几何/2. Lecture 2 (ACTUAL).html#transition-maps-and-smoothness",
    "title": "Parametrized Curves in \\(\\mathbb{R}^3\\)",
    "section": "2.3 Transition Maps and Smoothness",
    "text": "2.3 Transition Maps and Smoothness\n\n[!proposition|2.3.1] smooth transition maps If \\(X:U\\to S\\) and \\(\\widetilde X:\\widetilde U\\to S\\) are overlapping regular patches, then on the overlap the transition map \\[\n\\widetilde X^{-1}\\circ X:\\ U\\cap X^{-1}\\bigl(\\widetilde X(\\widetilde U)\\bigr)\\longrightarrow \\widetilde U\n\\] (and its inverse) is \\(C^\\infty\\).\n\n\n2.3.1 Smooth functions on a surface\nA function \\(f:S\\to\\mathbb{R}\\) is smooth if \\(f\\circ X:U\\to\\mathbb{R}\\) is smooth for every patch \\(X\\).\n\n\n2.3.2 Smooth maps between surfaces\nFor \\(f:S_1\\to S_2\\), we say \\(f\\) is smooth if for every pair of patches \\(X:U\\to S_1\\) and \\(\\widetilde X:\\widetilde U\\to S_2\\), \\[\n\\widetilde X^{-1}\\circ f\\circ X:\\ U\\to \\widetilde U\n\\] is smooth.",
    "crumbs": [
      "Notes",
      "微分几何",
      "Parametrized Curves in $\\mathbb{R}^3$"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/3. Tangent Vectors on a Surface.html",
    "href": "content/notes/理论/微分几何/3. Tangent Vectors on a Surface.html",
    "title": "0. Recap from Last lecture",
    "section": "",
    "text": "0. Recap from Last lecture\n\nSlide 1 - 2\nDefinition. A tangent vector to a smooth surface \\(S\\) at \\(p\\in S\\) is a linear map \\[\nX: C^\\infty(S)\\to\\mathbb{R}\\qquad\\text{(based at }p\\text{)},\n\\] meaning: 1. \\(Xf = Xg\\) if \\(f\\) and \\(g\\) agree on a neighbourhood of \\(p\\). (So \\(X\\) depends only on the germ of a function at \\(p\\), not on values away from \\(p\\).) 2. \\(X(fg) = f(p)\\,X(g) + g(p)\\,X(f)\\). (Leibniz / derivation rule at \\(p\\).)\n(Intuition: a tangent vector acts like a directional derivative at the point \\(p\\); it is a derivation on smooth functions.)\n\\[\nT_pS := \\{\\,\\text{tangent vectors to }S\\text{ at }p\\,\\}\n\\;=\\; \\text{a vector space over }\\mathbb{R}.\n\\]\n(One often writes a tangent vector in local coordinates as \\(v=v^i\\partial_{u^i}\\), meaning the linear combination of coordinate derivations — see Example 2.)\nExamples:\n\nVelocity of a curve. If \\(\\gamma:I\\to S\\) is a smooth curve and \\(t_0\\in I\\), define the velocity (tangent vector) at \\(t_0\\) by\\[\n\\dot\\gamma(t_0):\\; C^\\infty(S)\\to\\mathbb{R},\\qquad\n\\big(\\dot\\gamma(t_0)\\big)(f)\\;=\\;\\frac{d}{dt}\\Big|_{t=t_0} f\\big(\\gamma(t)\\big).\n\\] This map is linear and satisfies the Leibniz rule, so \\(\\dot\\gamma(t_0)\\in T_{\\gamma(t_0)}S\\). (Thus velocities of curves give canonical examples of tangent vectors.)\nCoordinate (basis) vectors in a patch. Let \\(\\sigma:U\\subset\\mathbb{R}^2\\to S\\) be a local chart (patch) with coordinates \\((u^1,u^2)\\). Locally any \\(f\\in C^\\infty(S)\\) can be written as a smooth function of the coordinates:\\[\nF(u^1,u^2)\\;=\\;f\\big(\\sigma(u^1,u^2)\\big).\n\\]For each index \\(i=1,2\\) define a derivation at the point \\(p=\\sigma(u^1_0,u^2_0)\\) by\\[\n\\partial_i\\big|_{p} :\\; C^\\infty(S)\\to\\mathbb{R},\\qquad\n\\big(\\partial_i\\big|_{p}\\big)(f)\\;=\\;\\frac{\\partial}{\\partial u^i}\\Big|_{(u^1_0,u^2_0)} F(u^1,u^2)\\]Each \\(\\partial_i|_p\\) is linear and satisfies the Leibniz rule, so \\(\\partial_i|_p\\in T_pS\\). The collection \\(\\{\\partial_1|_p,\\partial_2|_p\\}\\) is the standard coordinate basis for \\(T_pS\\) coming from the chart.(In these coordinates any tangent vector \\(X\\in T_pS\\) can be written \\(X = X^i\\partial_i|_p\\) with real components \\(X^i\\).)\n\n\n\nSlides 3 - 4\nIn a coordinate patch we can take the coordinates \\(u^i\\) as local smooth functions on \\(S\\). Given \\(X\\in T_pS\\) we define the local coefficients \\[\na^i := X(u^i)\\qquad(i=1,2).\n\\] Lemma. If \\(\\sigma:U\\subset\\mathbb{R}^2\\to S\\) is a local coordinate patch and \\(p=\\sigma(u^1_0,u^2_0)\\), then any \\(X\\in T_pS\\) can be written\n\\[\nX \\;=\\; a^1\\partial_1\\big|_{p} + a^2\\partial_2\\big|_{p},\n\\]\ni.e. \\(T_pS\\) is \\(2\\)-dimensional with basis \\(\\{\\partial_1|_p,\\partial_2|_p\\}\\).\n(Einstein summation convention will be used below: repeated upper/lower indices are summed implicitly.)\nProof (sketch, as on the board). First note \\(X\\) annihilates constant functions. Indeed, for the constant function \\(1\\), \\[\nX(1\\cdot 1)=1\\cdot X(1)+1\\cdot X(1)=2X(1),\n\\] so \\(X(1)=0\\). Hence for any constant \\(c\\), \\(X(c)=c\\,X(1)=0\\). Write a smooth \\(f\\in C^\\infty(S)\\) locally in coordinates by \\(F(u^1,u^2)=f\\circ\\sigma\\). By the chain rule at \\((u^1_0,u^2_0)\\), \\[\nX(f)=X\\big(F(u^1,u^2)\\big)\n= X(u^i)\\,\\frac{\\partial F}{\\partial u^i}\\Big|_{(u^1_0,u^2_0)}\n= a^i\\big(\\partial_i|_p\\big)(f).\n\\] Since this holds for all \\(f\\), we have \\(X=a^i\\partial_i|_p\\). Uniqueness of the \\(a^i\\) follows because the \\(\\partial_i|_p\\) are linearly independent. ∎\n(Remark kept inline: coordinate derivations \\(\\partial_i|_p\\) depend on the chosen chart; velocities of curves give intrinsic examples of tangent vectors.)",
    "crumbs": [
      "Notes",
      "微分几何",
      "0. Recap from Last lecture"
    ]
  },
  {
    "objectID": "content/notes/理论/微分几何/T-n分离公理.html",
    "href": "content/notes/理论/微分几何/T-n分离公理.html",
    "title": "Erise Note",
    "section": "",
    "text": "T-n Levels of Separation Axiom\n\n[!axiom] \\(T_{0}\\) — Kolmogorov Space\n\\(\\forall x \\neq y \\in X,\\, \\exists\\) open \\(U\\) s.t. \\(x \\in U,\\, y \\notin U\\) or \\(y \\in U,\\, x \\notin U\\).\n\n\n[!axiom] \\(T_{1}\\) — Fréchet Space\n\\(\\forall x \\neq y \\in X,\\, \\exists\\) open \\(U, V\\) s.t. \\(x \\in U,\\, y \\notin U\\) and \\(y \\in V,\\, x \\notin V\\).\n(Equivalently, all singletons are closed.)\n\n\n[!axiom] \\(T_{2}\\) — Hausdorff Space\n\\(\\forall x \\neq y \\in X,\\, \\exists\\) disjoint open \\(U, V\\) with \\(x \\in U,\\, y \\in V\\).\n\n\n[!axiom] \\(T_{2.5}\\) — Urysohn Space\n\\(\\forall x \\neq y \\in X,\\, \\exists\\) disjoint closed neighborhoods \\(N_x, N_y\\) with \\(x \\in N_x,\\, y \\in N_y\\).\n\n\n[!axiom] \\(T_{3}\\) — Regular \\(T_0\\) Space（正规 \\(T_0\\) 空间）\n\\(\\forall x \\in X,\\, A\\) closed, \\(x \\notin A,\\, \\exists\\) disjoint open \\(U, V\\) with \\(x \\in U,\\, A \\subset V\\).\n\n\n[!axiom] \\(T_{3.5}\\) — Tychonoff Space（Tychonoff 空间 / 完全正规 \\(T_0\\) 空间）\n\\(\\forall x \\in X,\\, A\\) closed, \\(x \\notin A,\\, \\exists f:X \\to [0,1]\\) continuous with \\(f(x)=0,\\, f(A)=\\{1\\}\\).\n\n\n[!axiom] \\(T_{4}\\) — Normal \\(T_1\\) Space（正规 \\(T_1\\) 空间）\n\\(\\forall\\) disjoint closed \\(A, B,\\, \\exists\\) disjoint open \\(U, V\\) with \\(A \\subset U,\\, B \\subset V\\).\n\n\n[!axiom] \\(T_{5}\\) — Completely Normal \\(T_1\\) Space（完全正规 \\(T_1\\) 空间）\n\\(\\forall\\) disjoint closed \\(A, B,\\, \\exists f:X \\to [0,1]\\) continuous with \\(f(A)=\\{0\\},\\, f(B)=\\{1\\}\\).\n\n逻辑链（纵向箭头代表“蕴含”关系）：\nT₅ Completely normal Hausdorff (完全正规豪斯多夫) │ 闭集–闭集可用连续函数分离 ▼ T₄ Normal Hausdorff (正规豪斯多夫) │ 闭集–闭集可用不交开集分离 ▼ T₃.₅ Completely regular Hausdorff (完全正规豪斯多夫 / Tychonoff) │ 点–闭集可用连续函数分离 ▼ T₃ Regular Hausdorff (正规豪斯多夫) │ 点–闭集可用不交开集分离 ▼ T₂.₅ Urysohn (乌里松) │ 点–点可用不交闭邻域分离 ▼ T₂ Hausdorff (豪斯多夫) │ 点–点可用不交开集分离 ▼ T₁ Fréchet (Fréchet) │ 单点集是闭集 ▼ T₀ Kolmogorov (Kolmogorov) 任意两点至少有一个开集包含其中之一而不包含另一",
    "crumbs": [
      "Notes",
      "微分几何",
      "T-n Levels of Separation Axiom"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html",
    "title": "Autoregressive Model (Continue)",
    "section": "",
    "text": "An AR (autoregressive) generative model represents the joint probability of a sequence by chaining conditionals left-to-right (the chain rule \\[P\\left(w_{1: T}\\right)=\\prod_{t=1}^T P\\left(w_t \\mid w_{&lt;t}\\right)\\] ## 1. Decoding / Inference in Language Models\n\nlocal higher probability do not always produce the global solution.\nwe care about the joint probability ### 1. 1. Argmax (Greedy Decoding) Choose the most likely token: \\[\nw_t = \\arg\\max_{w} p_\\theta(w \\mid w_{&lt;t})\n\\]\nDeterministic, always picks the top token.\n\nCan lead to repetitive or dull text. ### Beam search",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#setup-notation-shapes-first",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#setup-notation-shapes-first",
    "title": "Autoregressive Model (Continue)",
    "section": "2.1 Setup & notation (shapes first)",
    "text": "2.1 Setup & notation (shapes first)\n\nInputs: \\(\\mathbf{x}_t\\in\\mathbb{R}^{p}\\)\n\nHidden states: \\(\\mathbf{h}_t\\in\\mathbb{R}^{H}\\)\n\nLogits / probabilities / targets: \\(\\mathbf{z}_t,\\mathbf{p}_t,\\mathbf{y}_{t+1}\\in\\mathbb{R}^{R}\\)\n\nParameters:\n\n\\(W_{xh}\\in\\mathbb{R}^{H\\times p}\\), \\(W_{hh}\\in\\mathbb{R}^{H\\times H}\\), \\(\\mathbf{b}_h\\in\\mathbb{R}^{H}\\)\n\n\\(W_{ho}\\in\\mathbb{R}^{R\\times H}\\), \\(\\mathbf{b}_o\\in\\mathbb{R}^{R}\\)\n\n\nNonlinearity \\(f:\\mathbb{R}^{H}\\to\\mathbb{R}^{H}\\) (elementwise), with derivative \\(f'\\).\n\n\nShape cue used below: after each line, brackets like [H×p] or [H] indicate resulting shapes where helpful.",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#forward-definitions",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#forward-definitions",
    "title": "Autoregressive Model (Continue)",
    "section": "2.2 Forward definitions",
    "text": "2.2 Forward definitions\nHidden pre-activation, hidden state, logits, softmax: \\[\n\\begin{aligned}\n\\mathbf{a}_t &= W_{xh}\\,\\mathbf{x}_t \\;+\\; W_{hh}\\,\\mathbf{h}_{t-1} \\;+\\; \\mathbf{b}_h\n&&[\\;H\\times p\\;\\cdot\\;p \\to H\\;+\\;H\\times H\\cdot H \\to H\\;+\\;H\\;=\\;H\\;] \\\\\n\\mathbf{h}_t &= f(\\mathbf{a}_t) &&[\\;H\\;] \\\\\n\\mathbf{z}_t &= W_{ho}\\,\\mathbf{h}_t \\;+\\; \\mathbf{b}_o &&[\\;R\\times H\\cdot H \\to R\\;+\\;R\\;=\\;R\\;] \\\\\n\\mathbf{p}_t &= \\operatorname{softmax}(\\mathbf{z}_t),\\quad\n(\\mathbf{p}_t)_i = \\dfrac{e^{z_{t,i}}}{\\sum_{j=1}^{R} e^{z_{t,j}}}\n&&[\\;\\mathbf{p}_t\\in\\Delta^{R-1}\\;]\n\\end{aligned}\n\\]\n\nObservation model: \\(P(X_{t+1}\\mid X_{\\le t})=\\mathbf{p}_t=\\operatorname{softmax}(W_{ho}\\mathbf{h}_t+\\mathbf{b}_o)\\).",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#sequence-loss-sum-of-per-time-cross-entropies",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#sequence-loss-sum-of-per-time-cross-entropies",
    "title": "Autoregressive Model (Continue)",
    "section": "2.3 Sequence loss = sum of per-time cross-entropies",
    "text": "2.3 Sequence loss = sum of per-time cross-entropies\n\\[\n\\begin{aligned}\n\\mathcal{L}\n&= \\sum_{t=1}^{T} \\ell_t,\n\\qquad\n\\ell_t \\;=\\; -\\,\\mathbf{y}_{t+1}^{\\!\\top}\\log \\mathbf{p}_t\n\\;=\\; -\\sum_{i=1}^{R} y_{t+1,i}\\,\\log p_{t,i}.\n\\end{aligned}\n\\]\nIf \\(\\mathbf{y}_{t+1}\\) is one-hot (\\(\\mathbf{y}_{t+1}=e_{k_t}\\)), then \\[\n\\ell_t = -\\log p_{t,k_t}\\quad\\text{(only the true class contributes)}.\n\\]",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-3.-softmax-cross-entropy-gradient-w.r.t.-logits-local-output-node",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-3.-softmax-cross-entropy-gradient-w.r.t.-logits-local-output-node",
    "title": "Autoregressive Model (Continue)",
    "section": "Step 3. Softmax + cross-entropy gradient w.r.t. logits (local output node)",
    "text": "Step 3. Softmax + cross-entropy gradient w.r.t. logits (local output node)\nDerivation (math only): \\[\n\\begin{aligned}\n&\\text{softmax: } p_{t,i}=\\frac{e^{z_{t,i}}}{\\sum_j e^{z_{t,j}}},\n\\quad\n\\frac{\\partial p_{t,i}}{\\partial z_{t,j}} = p_{t,i}\\left(\\delta_{ij}-p_{t,j}\\right) \\\\\n&\\text{CE: } \\ell_t = -\\sum_i y_{t+1,i}\\log p_{t,i}\n\\;\\Rightarrow\\;\n\\frac{\\partial \\ell_t}{\\partial p_{t,i}} = -\\frac{y_{t+1,i}}{p_{t,i}} \\\\\n&\\text{chain: }\n\\frac{\\partial \\ell_t}{\\partial z_{t,j}}\n= \\sum_i \\frac{\\partial \\ell_t}{\\partial p_{t,i}} \\frac{\\partial p_{t,i}}{\\partial z_{t,j}}\n= \\sum_i \\left(-\\frac{y_{t+1,i}}{p_{t,i}}\\right) p_{t,i}(\\delta_{ij}-p_{t,j}) \\\\\n&\\qquad\\quad= -y_{t+1,j} + \\Big(\\sum_i y_{t+1,i}\\Big)p_{t,j}\n= -y_{t+1,j} + p_{t,j}\n\\;\\Rightarrow\\;\n\\boxed{\\nabla_{\\mathbf{z}_t}\\ell_t = \\mathbf{p}_t - \\mathbf{y}_{t+1}} \\\\\n&\\text{and since }\\mathbf{z}_t=W_{ho}\\mathbf{h}_t+\\mathbf{b}_o,\\;\n\\boxed{\\;\\nabla_{\\mathbf{h}_t}\\ell_t = W_{ho}^{\\!\\top}\\,(\\mathbf{p}_t-\\mathbf{y}_{t+1})\\;}\n\\end{aligned}\n\\]\n\nNote: The “\\(p - y\\)” result is independent of which class is correct; with one-hot labels it reduces to subtracting 1 at the true index.",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-4.-transition-jacobian-of-the-hidden-dynamics",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-4.-transition-jacobian-of-the-hidden-dynamics",
    "title": "Autoregressive Model (Continue)",
    "section": "Step 4. Transition Jacobian of the hidden dynamics",
    "text": "Step 4. Transition Jacobian of the hidden dynamics\nDefine \\(D_t:=\\operatorname{diag}\\!\\big(f'(\\mathbf{a}_t)\\big)\\in\\mathbb{R}^{H\\times H}\\).\nDerivation (math only): \\[\n\\begin{aligned}\n\\frac{\\partial \\mathbf{h}_t}{\\partial \\mathbf{h}_{t-1}}\n&=\n\\frac{\\partial \\mathbf{h}_t}{\\partial \\mathbf{a}_t}\n\\cdot\n\\frac{\\partial \\mathbf{a}_t}{\\partial \\mathbf{h}_{t-1}}\n=\nD_t \\cdot W_{hh}\n\\;\\; \\Rightarrow\\;\\;\n\\boxed{J_t := \\frac{\\partial \\mathbf{h}_t}{\\partial \\mathbf{h}_{t-1}} = D_t\\,W_{hh}} \\\\\n&\\text{so } J_t^{\\!\\top}=W_{hh}^{\\!\\top}D_t.\n\\end{aligned}\n\\]\n\nShape cue: \\(D_t[H\\times H] \\cdot W_{hh}[H\\times H] \\Rightarrow J_t[H\\times H]\\).",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-5.-backpropagation-through-time-bptt-local-future-error",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-5.-backpropagation-through-time-bptt-local-future-error",
    "title": "Autoregressive Model (Continue)",
    "section": "Step 5. Backpropagation through time (BPTT): local + future error",
    "text": "Step 5. Backpropagation through time (BPTT): local + future error\nLet \\(\\mathbf{s}_t := \\nabla_{\\mathbf{h}_t}\\mathcal{L}\\) be the total gradient on the hidden at time \\(t\\), and define the local term\n\\(\\boldsymbol{\\delta}_t := \\nabla_{\\mathbf{h}_t}\\ell_t = W_{ho}^{\\!\\top}(\\mathbf{p}_t-\\mathbf{y}_{t+1})\\).\nDerivation (math only): \\[\n\\begin{aligned}\n\\text{future pullback: }\n&\\mathbf{s}_{t+1} \\xrightarrow{\\text{chain via } \\mathbf{h}_{t+1}=f(\\cdots \\mathbf{h}_t)}\n\\frac{\\partial \\mathbf{h}_{t+1}}{\\partial \\mathbf{h}_t}^{\\!\\top}\\,\\mathbf{s}_{t+1}\n= J_{t+1}^{\\!\\top}\\,\\mathbf{s}_{t+1} \\\\\n\\text{combine: }\n&\\boxed{\\;\\mathbf{s}_t = \\boldsymbol{\\delta}_t \\;+\\; J_{t+1}^{\\!\\top}\\,\\mathbf{s}_{t+1}\\;}\n\\end{aligned}\n\\]\n\nReading cue: “total at \\(t\\) = local at \\(t\\) + future error back-propagated one step”.",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-6.-parameter-gradients-outer-product-form",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-6.-parameter-gradients-outer-product-form",
    "title": "Autoregressive Model (Continue)",
    "section": "Step 6. Parameter gradients (outer-product form)",
    "text": "Step 6. Parameter gradients (outer-product form)\nLet \\(\\mathbf{r}_t := D_t\\,\\mathbf{s}_t = f'(\\mathbf{a}_t)\\odot \\mathbf{s}_t\\) (elementwise product).\nDerivation (math only): \\[\n\\begin{aligned}\n\\text{Output layer: } \\quad\n&\\nabla_{W_{ho}}\\mathcal{L} = \\sum_{t=1}^{T} (\\mathbf{p}_t-\\mathbf{y}_{t+1})\\,\\mathbf{h}_t^{\\!\\top},\n\\qquad\n\\nabla_{\\mathbf{b}_o}\\mathcal{L} = \\sum_{t=1}^{T} (\\mathbf{p}_t-\\mathbf{y}_{t+1}) \\\\\n\\text{Hidden update: } \\quad\n&\\nabla_{W_{xh}}\\mathcal{L} = \\sum_{t=1}^{T} \\mathbf{r}_t\\,\\mathbf{x}_t^{\\!\\top},\n\\qquad\n\\nabla_{W_{hh}}\\mathcal{L} = \\sum_{t=1}^{T} \\mathbf{r}_t\\,\\mathbf{h}_{t-1}^{\\!\\top},\n\\qquad\n\\nabla_{\\mathbf{b}_h}\\mathcal{L} = \\sum_{t=1}^{T} \\mathbf{r}_t\n\\end{aligned}\n\\]\n\nOuter-product cue: each linear map’s gradient is “upstream vector” \\(\\times\\) “its input”\\(^{\\top}\\).",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-7.-put-the-boxed-pieces-together-elementwise-general",
    "href": "content/notes/理论/概率机器学习/3. Autoregressive模型 & Recurrent Neural Networks (RNN).html#step-7.-put-the-boxed-pieces-together-elementwise-general",
    "title": "Autoregressive Model (Continue)",
    "section": "Step 7. Put the boxed pieces together (elementwise → general)",
    "text": "Step 7. Put the boxed pieces together (elementwise → general)\nCollecting the key boxed results used repeatedly:\n\\[\n\\begin{aligned}\n\\text{(i)}\\;&\\nabla_{\\mathbf{z}_t}\\ell_t \\;=\\; \\mathbf{p}_t - \\mathbf{y}_{t+1} \\\\\n\\text{(ii)}\\;&\\boldsymbol{\\delta}_t \\;=\\; W_{ho}^{\\!\\top}(\\mathbf{p}_t-\\mathbf{y}_{t+1}) \\\\\n\\text{(iii)}\\;&J_t \\;=\\; D_t\\,W_{hh},\\quad J_t^{\\!\\top}=W_{hh}^{\\!\\top}D_t \\\\\n\\text{(iv)}\\;&\\mathbf{s}_t \\;=\\; \\boldsymbol{\\delta}_t \\;+\\; J_{t+1}^{\\!\\top}\\,\\mathbf{s}_{t+1} \\\\\n\\text{(v)}\\;&\\mathbf{r}_t \\;=\\; D_t\\,\\mathbf{s}_t \\;=\\; f'(\\mathbf{a}_t)\\odot \\mathbf{s}_t \\\\\n\\text{(vi)}\\;&\\nabla_{W_{ho}}\\mathcal{L} = \\sum_t (\\mathbf{p}_t-\\mathbf{y}_{t+1})\\,\\mathbf{h}_t^{\\!\\top},\\quad\n\\nabla_{\\mathbf{b}_o}\\mathcal{L} = \\sum_t (\\mathbf{p}_t-\\mathbf{y}_{t+1}) \\\\\n\\text{(vii)}\\;&\\nabla_{W_{xh}}\\mathcal{L} = \\sum_t \\mathbf{r}_t\\,\\mathbf{x}_t^{\\!\\top},\\quad\n\\nabla_{W_{hh}}\\mathcal{L} = \\sum_t \\mathbf{r}_t\\,\\mathbf{h}_{t-1}^{\\!\\top},\\quad\n\\nabla_{\\mathbf{b}_h}\\mathcal{L} = \\sum_t \\mathbf{r}_t\n\\end{aligned}\n\\]\n\n\nDilated convolution\nSampling for i = H for j = 1:W for c = 1:C sample Same for all three models:\n\nRNN\nLSTM\nTranformer\n\nSampling is sequential.",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "Autoregressive Model (Continue)"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/index.html",
    "href": "content/notes/理论/概率机器学习/index.html",
    "title": "概率机器学习",
    "section": "",
    "text": "0. Probability Distributions (recap)\n\n\n\n\n\n\n\n\n2025年9月3日\n\n\n\n\n\n\n\n\n\n\n\n\nAgent\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAutoregressive Model (Continue)\n\n\n\n\n\n\n\n\n2025年9月8日\n\n\n\n\n\n\n\n\n\n\n\n\nAutoregressive Models\n\n\n\n\n\n\n\n\n2025年9月15日\n\n\n\n\n\n\n\n\n\n\n\n\nMarkov奖励&决策过程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n强化学习\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "概率机器学习"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html",
    "title": "Agent",
    "section": "",
    "text": "RL is the science of learning to make decision\nAn agent can learn - policy - value function - model (model predicts states)\nenevironement (state) != agenet (state)\nAssume we simplify Environement to single state: ## 1.1 Action Consider two actions: 1. a 2. b\n\n\nThe trade-off: - Exploitation: maximise peprformance based on current knolwedge - Exploration: increase knowledge - Long term involves short term sacrifices ## 1.3 The Multi-Armed Bandit\nGoal: maximise cumulative reward\nA multi-armed bandit is a set of distributions \\(\\{\\}\\) ## 1.4 Value Regret\n\n\n\n\n\n\n\n\nminimize total regret: \\[L_{t}=\\sum^{t}_{n=1}v_{*}-q(A_{n})=\\sum \\Delta_{A_{n}}\\] maximuise cumulative reward = minimise total regret",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#exploration-v.s.-exploitation",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#exploration-v.s.-exploitation",
    "title": "Agent",
    "section": "",
    "text": "The trade-off: - Exploitation: maximise peprformance based on current knolwedge - Exploration: increase knowledge - Long term involves short term sacrifices ## 1.3 The Multi-Armed Bandit\nGoal: maximise cumulative reward\nA multi-armed bandit is a set of distributions \\(\\{\\}\\) ## 1.4 Value Regret\n\n\n\n\n\n\n\n\nminimize total regret: \\[L_{t}=\\sum^{t}_{n=1}v_{*}-q(A_{n})=\\sum \\Delta_{A_{n}}\\] maximuise cumulative reward = minimise total regret",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#greedy",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#greedy",
    "title": "Agent",
    "section": "2.1 Greedy",
    "text": "2.1 Greedy",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#epsilon-greedy",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#epsilon-greedy",
    "title": "Agent",
    "section": "2.2 \\(\\epsilon\\)-Greedy",
    "text": "2.2 \\(\\epsilon\\)-Greedy",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#ucb",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#ucb",
    "title": "Agent",
    "section": "2.3 UCB",
    "text": "2.3 UCB",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#thomspson-samplong",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#thomspson-samplong",
    "title": "Agent",
    "section": "2.4 Thomspson samplong",
    "text": "2.4 Thomspson samplong",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#policy-gradients",
    "href": "content/notes/理论/概率机器学习/强化学习（RL）/Agent.html#policy-gradients",
    "title": "Agent",
    "section": "2.5 Policy Gradients",
    "text": "2.5 Policy Gradients",
    "crumbs": [
      "Notes",
      "概率机器学习",
      "强化学习",
      "Agent"
    ]
  },
  {
    "objectID": "content/notes/理论/点集拓扑学基础/index.html",
    "href": "content/notes/理论/点集拓扑学基础/index.html",
    "title": "点集拓扑学基础",
    "section": "",
    "text": "无匹配项",
    "crumbs": [
      "Notes",
      "点集拓扑学基础"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "Big picture: These notes consolidate core Julia language patterns (types, functions, dispatch, performance) and the Git mental model (objects → trees → commits → refs) with small, runnable examples. Use them as a quick study sheet before coding.\n\n\n\n\nJulia: Performance flows from type stability and multiple dispatch. Prefer clear function definitions, broadcasting (.), and small, composable methods.\nGit: Think “snapshot graph.” Commits point to trees (your files), and refs (branches/tags) point to commits. Stage → commit → push is the daily cadence. ## 1) Julia Basics\n\n\n\n\nAbstract: Real, Integer, Signed, Unsigned\nConcrete: Int64, Float64, Bool, Complex{T}, Rational{T}, Char, String, Symbol\n\n# Explore the type lattice (in REPL):\nsubtypes(Real)\nsubtypes(Integer)\nsubtypes(Signed)\n\n# Type inspection:\ntypeof(3), typeof(3.0), typeof(1//2), typeof(1 + 2im), typeof(:name)\n\n\n\n# Arrays, Tuples, Dicts\nA = [1, 2, 3]                       # Vector{Int}\nM = [1 2; 3 4]                      # Matrix{Int} (2×2)\nt = (1, \"a\", 3.0)                   # Tuple\nd = Dict(\"a\" =&gt; 1, \"b\" =&gt; 2)        # Dict{String,Int}\n\n# Ranges & comprehensions\nr = 0:0.25:1                        # 0.0,0.25,0.5,0.75,1.0\nsquares = [i^2 for i in 1:5]        # [1,4,9,16,25]\n\n\n\n\n\n\n\nf(x) = 3x + 1\nf(10)  # 31\n\n\n\nfunction g(x, y)\n    z = x + y\n    return 3z\nend\ng(2, 4)  # 18\n\n\n\nh = (x, y) -&gt; 3 * (x + y)\nh(2, 4)  # 18\n\n\n\nfunction no_return_example(x)\n    x^2 + 1   # returned implicitly\nend\nno_return_example(3)  # 10\n\n\n\nfunction apply_twice(f, x)\n    return f(f(x))\nend\napply_twice(x -&gt; x + 1, 3)  # 5\n\n\n\n\nIdea: Different method bodies for different argument types.\narea(r::Real) = π * r^2                 # circle by radius\narea(w::Real, h::Real) = w * h          # rectangle\n\narea(2)       # uses first method\narea(3.0, 4)  # uses second method\nType-specific behavior:\nf(x::Int, y::Int) = x + y\nf(x::AbstractFloat, y::AbstractFloat) = x + y + 0.1\n\nf(1, 2)       # 3\nf(1.0, 2.0)   # 3.1\n\n\n\n\n\n\nstruct Point\n    x::Float64\n    y::Float64\nend\n\nmutable struct MPoint\n    x::Float64\n    y::Float64\nend\n\np = Point(1.0, 2.0)\n# p.x = 3.0   # ERROR: immutable\n\nmp = MPoint(1.0, 2.0)\nmp.x = 3.0    # OK\n\n\n\n# Annotate arguments for clarity/perf (when helpful)\nfunction scale!(v::Vector{Float64}, α::Float64)\n    for i in eachindex(v)\n        v[i] *= α\n    end\n    return v\nend\n\nv = [1.0, 2.0, 3.0]\nscale!(v, 0.5)  # [0.5,1.0,1.5]\n\n\n\n\n\n\n\nx = range(0, stop=2π, length=5)\ny = sin.(x)               # elementwise sin\nz = sin.(x .+ 0.1) .^ 2   # dotted ops fuse efficiently\n\n\n\nfunction midpoint(a; b=0.0)\n    return (a + b)/2\nend\nmidpoint(3.0; b=5.0)  # 4.0\n\n\n\nsum_all(xs...) = sum(xs)\nsum_all(1, 2, 3, 4)   # 10\n\n\n\n\"\"\"\n    myfunc(x)\n\nReturn x squared.\n\"\"\"\nmyfunc(x) = x^2\n\n# In REPL: ?myfunc\n\n\n\n\n\n\nPrefer type-stable returns.\nAvoid mutating global vars; wrap code in functions.\nPrefer in-place operations for large arrays.\nUse @views for slicing without allocations; @inbounds in hot loops (careful).\n\nfunction add!(y::Vector{Float64}, A::Matrix{Float64}, x::Vector{Float64})\n    @views y .+= A * x   # no copies for slices; allocation from A*x remains\n    return y\nend\n\n\n\n\n\n\nGit stores content-addressed objects:\n\nblob = file content\ntree = directory (names → blobs/trees)\ncommit = snapshot + metadata (points to a tree and parent commit(s))\ntag = named pointer (often to a commit)\n\nRefs (e.g., main) are pointers to commits; HEAD points to the current ref.\n\n\n\ngit clone &lt;url&gt;          # or: git init\ngit status               # see changes\ngit add &lt;paths&gt;          # stage\ngit commit -m \"message\"  # snapshot\ngit push origin main     # publish\ngit pull                 # update from remote\n\n\n\n\n\n\n\ngit log --oneline --graph --decorate -n 10\ngit ls-tree -r HEAD                # list files in current commit tree\ngit cat-file -p HEAD               # show commit (tree, parent, metadata)\ngit cat-file -p &lt;tree-hash&gt;        # show tree entries\ngit cat-file -p &lt;blob-hash&gt;        # show file contents snapshot\n\n\n\ngit symbolic-ref --short HEAD      # current branch name\ngit show-ref --heads               # local branch refs\ngit show-ref --tags                # tag refs\n\n\n\n\n\n# Branching\ngit branch feature/x\ngit switch feature/x               # or: git checkout feature/x\ngit switch -c feature/x            # create & switch\n\n# Merging / Rebasing\ngit merge feature/x\ngit rebase main                    # replay commits on top of main (avoid on shared history)\n\n# Amending\ngit commit --amend                 # edit last commit\n\n# Stashing\ngit stash\ngit stash pop\n\n# Show a file from a commit\ngit show &lt;commit&gt;:path/to/file\n\n\n\n\ngit switch -c feature/speed-up\n# edit; run tests\ngit add -A\ngit commit -m \"Optimize inner loop with @inbounds\"\ngit push -u origin feature/speed-up\n# open PR on GitHub/GitLab\n\n\n\n\ngit reflog                         # timeline of HEAD moves (lifesaver)\ngit reset --hard HEAD~1            # drop last commit (DANGER: discards changes)\ngit restore --staged &lt;file&gt;        # unstage a file\ngit checkout &lt;commit&gt; -- &lt;file&gt;    # restore file version from old commit\n\n\n\n\ngit tag -a v0.1.0 -m \"First release\"\ngit push origin --tags\n\n\n\n\n# Julia\n*.jl~\n*.ji\n*.jld2\nManifest.toml\nProject.toml\n\n# General\n.DS_Store\n*.log\n.env\n.vscode/\n\n\n\n\n# Save environment with your code\njulia --project -e 'using Pkg; Pkg.instantiate(); Pkg.status()'\ngit add Project.toml Manifest.toml\ngit commit -m \"Pin Julia environment\"\n\n\n\n\nCan you explain why multiple dispatch helps write both generic and fast code?\nCan you draw the Git graph: refs → commits → trees → blobs?\nCan you stage/commit/push and recover a mistaken commit with reflog?\n\nThat’s it—paste into Obsidian and you’re set for a crisp review before coding.",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#key-takeaways",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#key-takeaways",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "Julia: Performance flows from type stability and multiple dispatch. Prefer clear function definitions, broadcasting (.), and small, composable methods.\nGit: Think “snapshot graph.” Commits point to trees (your files), and refs (branches/tags) point to commits. Stage → commit → push is the daily cadence. ## 1) Julia Basics\n\n\n\n\nAbstract: Real, Integer, Signed, Unsigned\nConcrete: Int64, Float64, Bool, Complex{T}, Rational{T}, Char, String, Symbol\n\n# Explore the type lattice (in REPL):\nsubtypes(Real)\nsubtypes(Integer)\nsubtypes(Signed)\n\n# Type inspection:\ntypeof(3), typeof(3.0), typeof(1//2), typeof(1 + 2im), typeof(:name)\n\n\n\n# Arrays, Tuples, Dicts\nA = [1, 2, 3]                       # Vector{Int}\nM = [1 2; 3 4]                      # Matrix{Int} (2×2)\nt = (1, \"a\", 3.0)                   # Tuple\nd = Dict(\"a\" =&gt; 1, \"b\" =&gt; 2)        # Dict{String,Int}\n\n# Ranges & comprehensions\nr = 0:0.25:1                        # 0.0,0.25,0.5,0.75,1.0\nsquares = [i^2 for i in 1:5]        # [1,4,9,16,25]",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#functions-syntax-three-ways",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#functions-syntax-three-ways",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "f(x) = 3x + 1\nf(10)  # 31\n\n\n\nfunction g(x, y)\n    z = x + y\n    return 3z\nend\ng(2, 4)  # 18\n\n\n\nh = (x, y) -&gt; 3 * (x + y)\nh(2, 4)  # 18\n\n\n\nfunction no_return_example(x)\n    x^2 + 1   # returned implicitly\nend\nno_return_example(3)  # 10\n\n\n\nfunction apply_twice(f, x)\n    return f(f(x))\nend\napply_twice(x -&gt; x + 1, 3)  # 5",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#multiple-dispatch-method-overloading",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#multiple-dispatch-method-overloading",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "Idea: Different method bodies for different argument types.\narea(r::Real) = π * r^2                 # circle by radius\narea(w::Real, h::Real) = w * h          # rectangle\n\narea(2)       # uses first method\narea(3.0, 4)  # uses second method\nType-specific behavior:\nf(x::Int, y::Int) = x + y\nf(x::AbstractFloat, y::AbstractFloat) = x + y + 0.1\n\nf(1, 2)       # 3\nf(1.0, 2.0)   # 3.1",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#types-structs-mutability",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#types-structs-mutability",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "struct Point\n    x::Float64\n    y::Float64\nend\n\nmutable struct MPoint\n    x::Float64\n    y::Float64\nend\n\np = Point(1.0, 2.0)\n# p.x = 3.0   # ERROR: immutable\n\nmp = MPoint(1.0, 2.0)\nmp.x = 3.0    # OK\n\n\n\n# Annotate arguments for clarity/perf (when helpful)\nfunction scale!(v::Vector{Float64}, α::Float64)\n    for i in eachindex(v)\n        v[i] *= α\n    end\n    return v\nend\n\nv = [1.0, 2.0, 3.0]\nscale!(v, 0.5)  # [0.5,1.0,1.5]",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#idiomatic-julia",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#idiomatic-julia",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "x = range(0, stop=2π, length=5)\ny = sin.(x)               # elementwise sin\nz = sin.(x .+ 0.1) .^ 2   # dotted ops fuse efficiently\n\n\n\nfunction midpoint(a; b=0.0)\n    return (a + b)/2\nend\nmidpoint(3.0; b=5.0)  # 4.0\n\n\n\nsum_all(xs...) = sum(xs)\nsum_all(1, 2, 3, 4)   # 10\n\n\n\n\"\"\"\n    myfunc(x)\n\nReturn x squared.\n\"\"\"\nmyfunc(x) = x^2\n\n# In REPL: ?myfunc",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#performance-tips-quick-wins",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#performance-tips-quick-wins",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "Prefer type-stable returns.\nAvoid mutating global vars; wrap code in functions.\nPrefer in-place operations for large arrays.\nUse @views for slicing without allocations; @inbounds in hot loops (careful).\n\nfunction add!(y::Vector{Float64}, A::Matrix{Float64}, x::Vector{Float64})\n    @views y .+= A * x   # no copies for slices; allocation from A*x remains\n    return y\nend",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#git-model-daily-flow",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#git-model-daily-flow",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "Git stores content-addressed objects:\n\nblob = file content\ntree = directory (names → blobs/trees)\ncommit = snapshot + metadata (points to a tree and parent commit(s))\ntag = named pointer (often to a commit)\n\nRefs (e.g., main) are pointers to commits; HEAD points to the current ref.\n\n\n\ngit clone &lt;url&gt;          # or: git init\ngit status               # see changes\ngit add &lt;paths&gt;          # stage\ngit commit -m \"message\"  # snapshot\ngit push origin main     # publish\ngit pull                 # update from remote",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#git-internals-peek-under-the-hood",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#git-internals-peek-under-the-hood",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "git log --oneline --graph --decorate -n 10\ngit ls-tree -r HEAD                # list files in current commit tree\ngit cat-file -p HEAD               # show commit (tree, parent, metadata)\ngit cat-file -p &lt;tree-hash&gt;        # show tree entries\ngit cat-file -p &lt;blob-hash&gt;        # show file contents snapshot\n\n\n\ngit symbolic-ref --short HEAD      # current branch name\ngit show-ref --heads               # local branch refs\ngit show-ref --tags                # tag refs",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#essential-commands-cheat-sheet",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#essential-commands-cheat-sheet",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "# Branching\ngit branch feature/x\ngit switch feature/x               # or: git checkout feature/x\ngit switch -c feature/x            # create & switch\n\n# Merging / Rebasing\ngit merge feature/x\ngit rebase main                    # replay commits on top of main (avoid on shared history)\n\n# Amending\ngit commit --amend                 # edit last commit\n\n# Stashing\ngit stash\ngit stash pop\n\n# Show a file from a commit\ngit show &lt;commit&gt;:path/to/file",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#feature-branch-workflow-pr-friendly",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#feature-branch-workflow-pr-friendly",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "git switch -c feature/speed-up\n# edit; run tests\ngit add -A\ngit commit -m \"Optimize inner loop with @inbounds\"\ngit push -u origin feature/speed-up\n# open PR on GitHub/GitLab",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#recovery-inspection",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#recovery-inspection",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "git reflog                         # timeline of HEAD moves (lifesaver)\ngit reset --hard HEAD~1            # drop last commit (DANGER: discards changes)\ngit restore --staged &lt;file&gt;        # unstage a file\ngit checkout &lt;commit&gt; -- &lt;file&gt;    # restore file version from old commit",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#tags-releases",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#tags-releases",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "git tag -a v0.1.0 -m \"First release\"\ngit push origin --tags",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#gitignore-starter",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#gitignore-starter",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "# Julia\n*.jl~\n*.ji\n*.jld2\nManifest.toml\nProject.toml\n\n# General\n.DS_Store\n*.log\n.env\n.vscode/",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#julia-git-for-reproducible-projects",
    "href": "content/notes/计算/Julia科学计算笔记/2. Variables, primitive types, and functions.html#julia-git-for-reproducible-projects",
    "title": "Lecture Review: Julia & Git",
    "section": "",
    "text": "# Save environment with your code\njulia --project -e 'using Pkg; Pkg.instantiate(); Pkg.status()'\ngit add Project.toml Manifest.toml\ngit commit -m \"Pin Julia environment\"\n\n\n\n\nCan you explain why multiple dispatch helps write both generic and fast code?\nCan you draw the Git graph: refs → commits → trees → blobs?\nCan you stage/commit/push and recover a mistaken commit with reflog?\n\nThat’s it—paste into Obsidian and you’re set for a crisp review before coding.",
    "crumbs": [
      "Notes",
      "Julia科学计算笔记",
      "Lecture Review: **Julia & Git**"
    ]
  },
  {
    "objectID": "content/notes/计算/index.html",
    "href": "content/notes/计算/index.html",
    "title": "Physics",
    "section": "",
    "text": "4.1 三维空间的薛定谔方程\n\n\n\n\n\n\n\n\n\n\n4.1.1 经典氢原子 (Classical Hydrogen Atom)\n\n\n\n\n\n\n\n\n\n\n4.3.1 量子数 (Quantum Numbers)\n\n\n\n\n\n\n\n\n\n\nJulia科学计算笔记\n\n\n\n\n\n\n\n\n\n\nLecture\n\n\n\n\n\n\n\n\n\n\nLecture Review: Julia & Git\n\n\n\n\n\n\n\n\n\n\nSummary of Key Julia Codes and Algorithms by Chapter\n\n\n\n\n\n\n\n\n\n\nThree quantum indeterminacy position:\n\n\n\n\n\n\n\n\n\n\n氢原子\n\n\n\n\n\n\n\n\n\n\n波函数存在于Hilbert空间中\n\n\n\n\n\n\n\n\n\n\n第一章\n\n\n\n\n\n\n\n\n\n\n第四章\n\n\n\n\n\n\n\n\n\n\n薛定谔方程的傅立叶变换\n\n\n\n\n\n\n\n\n\n\n量子力学讲义\n\n\n\n\n\n\n\n\n\n\n量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "Physics"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第一章/1.1 The Wave Function.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第一章/1.1 The Wave Function.html",
    "title": "Erise Note",
    "section": "",
    "text": "To find a particle’s wave function, \\(\\psi(x,t)\\), we solve: &gt;logically analogous to Newton’s Second Law \\(F=ma\\)\n\n[!definition] Schrodinger’s Equation \\[i\\hbar \\frac{ \\partial \\Psi}{ \\partial t}=-\\frac{\\hbar^{2}}{2m}\\frac{ \\partial^{2}\\Psi}{ \\partial x^{2} }+V \\Psi\\]\n\nwhere Planck’s constant \\(\\hbar=\\frac{h}{2\\pi}=1.054573 \\times 10^{-34}\\).\n\n[!definition] Born’s Statistical Interpretation \\[\\int^{a}_{b} |\\Psi(x,t)^{2}| \\, dx \\] which is the probability finding the particle between \\(a\\) and \\(b\\).\n\n\nIt is natural to wonder whether it is a fact of nature, or a defect in theory.\n\n\nThree quantum indeterminacy position:\n\nrealist\n\nthe particle was at C. (a hidden variable?)\n\northodox (Copenhagen Interpretation)\n\nthe particle wasn’t anywhere. (measurement produce the result)\nmost widely accepted position\n\n(agnosticism)\n\nrefuse to answer. That is, no meaning to ask such question. &gt; Pauli: one should no more rack one’s brain about the problem of whether something one cannot know anything about exists all the same, than about the ancient question of how many angels are able to sit on the point of needle.\nfall-back position, however, eliminated by John Bell’s experiment in 1964\n\n\n\n\n\nTwo Distinct Physical Processes:\n\nOrdinary\n\nevolves in a leisurely fashion under\n\nMeasurements\n\nwave equation \\(\\Psi\\) discontinuously collapses, when the first measurement radically alters the function.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第一章",
      "Three quantum indeterminacy position:"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html",
    "title": "Erise Note",
    "section": "",
    "text": "In the classical model of the hydrogen atom, we have an electron orbiting around a proton. The electrostatic potential energy is: \\[E = -\\frac{1}{2}\\frac{e^2}{4\\pi\\varepsilon_0 r}\\] According to classical electrodynamics, an accelerated charged particle radiates energy. The power radiated by an accelerated particle is given by the Larmor formula: \\[P = \\frac{dE}{dt} = -\\frac{e^2}{6\\pi\\varepsilon_0 c^3}a^2\\] This would cause the electron to spiral into the proton in approximately \\(10^{-11}\\) seconds!\nImportant conclusion: Quantum mechanics provides the basis for the stability of matter, as classical physics fails to explain stable atomic structures.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#经典氢原子-classical-hydrogen-atom",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#经典氢原子-classical-hydrogen-atom",
    "title": "Erise Note",
    "section": "",
    "text": "In the classical model of the hydrogen atom, we have an electron orbiting around a proton. The electrostatic potential energy is: \\[E = -\\frac{1}{2}\\frac{e^2}{4\\pi\\varepsilon_0 r}\\] According to classical electrodynamics, an accelerated charged particle radiates energy. The power radiated by an accelerated particle is given by the Larmor formula: \\[P = \\frac{dE}{dt} = -\\frac{e^2}{6\\pi\\varepsilon_0 c^3}a^2\\] This would cause the electron to spiral into the proton in approximately \\(10^{-11}\\) seconds!\nImportant conclusion: Quantum mechanics provides the basis for the stability of matter, as classical physics fails to explain stable atomic structures.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#三维薛定谔方程-3d-schrödinger-equation",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#三维薛定谔方程-3d-schrödinger-equation",
    "title": "Erise Note",
    "section": "4.1.2 三维薛定谔方程 (3D Schrödinger Equation)",
    "text": "4.1.2 三维薛定谔方程 (3D Schrödinger Equation)\nThe time-dependent Schrödinger equation in three dimensions is: \\[i\\hbar\\frac{\\partial\\Psi}{\\partial t} = H\\Psi\\] where the Hamiltonian \\(H\\) is:\n\\[H = \\frac{1}{2m}(p_x^2 + p_y^2 + p_z^2) + V\\] The momentum operators in quantum mechanics are: \\[p_x \\rightarrow \\frac{\\hbar}{i}\\frac{\\partial}{\\partial x}, \\quad p_y \\rightarrow \\frac{\\hbar}{i}\\frac{\\partial}{\\partial y}, \\quad p_z \\rightarrow \\frac{\\hbar}{i}\\frac{\\partial}{\\partial z}\\] More compactly: \\[\\mathbf{p} \\rightarrow \\frac{\\hbar}{i}\\nabla\\]\nThe canonical commutation relations for position and momentum are:\n\\[[r_i, p_j] = -[p_i, r_j] = i\\hbar\\delta_{ij}, \\quad [r_i, r_j] = [p_i, p_j] = 0\\]\nwhere the indices \\(i,j\\) stand for \\(x\\), \\(y\\), or \\(z\\).",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#拉普拉斯算子-laplacian",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#拉普拉斯算子-laplacian",
    "title": "Erise Note",
    "section": "4.1.3 拉普拉斯算子 (Laplacian)",
    "text": "4.1.3 拉普拉斯算子 (Laplacian)\nIn terms of the Laplacian operator, the Schrödinger equation can be written as:\n\\[i\\hbar\\frac{\\partial\\Psi}{\\partial t} = -\\frac{\\hbar^2}{2m}\\nabla^2\\Psi + V\\Psi\\]\nwhere the Laplacian is defined as:\n\\[\\nabla^2 \\equiv \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}\\]\nThe wavefunction must be normalized:\n\\[\\int |\\Psi|^2 d^3\\mathbf{r} = 1\\]\nwhere \\[d^3\\mathbf{r} = dx\\,dy\\,dz\\] is the volume element.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#时间独立势能的平稳态-stationary-states-for-time-independent-potential",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#时间独立势能的平稳态-stationary-states-for-time-independent-potential",
    "title": "Erise Note",
    "section": "4.1.4 时间独立势能的平稳态 (Stationary States for Time-Independent Potential)",
    "text": "4.1.4 时间独立势能的平稳态 (Stationary States for Time-Independent Potential)\nFor a time-independent potential, there exist stationary states of the form:\n\\[\\Psi_n(\\mathbf{r}, t) = \\psi_n(\\mathbf{r})e^{-iE_n t/\\hbar}\\]\nThese stationary states satisfy the time-independent Schrödinger equation:\n\\[-\\frac{\\hbar^2}{2m}\\nabla^2\\psi_n + V\\psi_n = E_n\\psi_n\\]\nThe general solution to the time-dependent Schrödinger equation is:\n\\[\\Psi(\\mathbf{r}, t) = \\sum_n c_n\\psi_n(\\mathbf{r})e^{-iE_n t/\\hbar}\\]\nThe initial state determines the coefficients:\n\\[\\Psi(\\mathbf{r}, 0) = \\sum_n c_n\\psi_n(\\mathbf{r})\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#中心势-central-potential",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#中心势-central-potential",
    "title": "Erise Note",
    "section": "4.1.5 中心势 (Central Potential)",
    "text": "4.1.5 中心势 (Central Potential)\nA central potential depends only on the radial distance:\n\\[V(\\mathbf{r}) = V(r)\\]\nFor a central potential, we use spherical coordinates:\n\\[\\mathbf{r} = (x, y, z) = (r, \\theta, \\phi)\\]\nThe Laplacian in spherical coordinates is:\n\\[\\nabla^2 = \\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial}{\\partial r}\\right) + \\frac{1}{r^2\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right) + \\frac{1}{r^2\\sin^2\\theta}\\left(\\frac{\\partial^2}{\\partial\\phi^2}\\right)\\]\nThe Schrödinger equation for a central potential becomes:\n\\[-\\frac{\\hbar^2}{2m}\\left[\\frac{1}{r^2}\\frac{\\partial}{\\partial r}\\left(r^2\\frac{\\partial\\psi}{\\partial r}\\right) + \\frac{1}{r^2\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial\\psi}{\\partial\\theta}\\right) + \\frac{1}{r^2\\sin^2\\theta}\\left(\\frac{\\partial^2\\psi}{\\partial\\phi^2}\\right)\\right] + V\\psi = E\\psi\\]\n\n变量分离 (Separation of Variables)\nFor a central potential, we can separate the variables:\n\\[\\psi(r, \\theta, \\phi) = R(r)Y(\\theta, \\phi)\\]\nSubstituting this into the Schrödinger equation:\n\\[-\\frac{\\hbar^2}{2m}\\left[\\frac{Y}{r^2}\\frac{d}{dr}\\left(r^2\\frac{dR}{dr}\\right) + \\frac{R}{r^2\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial Y}{\\partial\\theta}\\right) + \\frac{R}{r^2\\sin^2\\theta}\\frac{\\partial^2 Y}{\\partial\\phi^2}\\right] + VRY = ERY\\]\nDividing by \\(YR\\) and multiplying by \\(-2mr^2/\\hbar^2\\):\n\\[\\begin{align}\n\\left\\{\\frac{1}{R}\\frac{d}{dr}\\left(r^2\\frac{dR}{dr}\\right) - \\frac{2mr^2}{\\hbar^2}[V(r) - E]\\right\\} + \\frac{1}{Y}\\left\\{\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial Y}{\\partial\\theta}\\right) + \\frac{1}{\\sin^2\\theta}\\frac{\\partial^2 Y}{\\partial\\phi^2}\\right\\} = 0\n\\end{align}\\]\nSince the left term depends only on \\(r\\) and the right term depends only on \\(\\theta\\) and \\(\\phi\\), each must equal a constant:\n\\[\\frac{1}{R}\\frac{d}{dr}\\left(r^2\\frac{dR}{dr}\\right) - \\frac{2mr^2}{\\hbar^2}[V(r) - E] = \\ell(\\ell + 1)\\]\n\\[\\frac{1}{Y}\\left\\{\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial Y}{\\partial\\theta}\\right) + \\frac{1}{\\sin^2\\theta}\\frac{\\partial^2 Y}{\\partial\\phi^2}\\right\\} = -\\ell(\\ell + 1)\\]\nWhere \\[\\ell(\\ell + 1)\\] is the separation constant.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#角度方程-angular-equation",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#角度方程-angular-equation",
    "title": "Erise Note",
    "section": "4.1.6 角度方程 (Angular Equation)",
    "text": "4.1.6 角度方程 (Angular Equation)\nThe angular equation is:\n\\[\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial Y}{\\partial\\theta}\\right) + \\frac{\\partial^2 Y}{\\partial\\phi^2} = -\\ell(\\ell + 1)\\sin^2\\theta Y\\]\nWe can separate variables again:\n\\[Y(\\theta, \\phi) = \\Theta(\\theta)\\Phi(\\phi)\\]\nPlugging this in and dividing by \\(\\Theta\\Phi\\):\n\\[\\left\\{\\frac{1}{\\Theta}\\left[\\sin\\theta\\frac{d}{d\\theta}\\left(\\sin\\theta\\frac{d\\Theta}{d\\theta}\\right)\\right] + \\ell(\\ell + 1)\\sin^2\\theta\\right\\} + \\frac{1}{\\Phi}\\frac{d^2\\Phi}{d\\phi^2} = 0\\]\nThe \\(\\phi\\) equation separates as:\n\\[\\frac{1}{\\Phi}\\frac{d^2\\Phi}{d\\phi^2} = -m^2\\]\n\\[\\frac{d^2\\Phi}{d\\phi^2} = -m^2\\Phi \\Rightarrow \\Phi(\\phi) = e^{im\\phi}\\]\nSince \\(\\Phi(\\phi + 2\\pi) = \\Phi(\\phi)\\) must be true for single-valued wavefunctions, we have:\n\\[m = 0, \\pm 1, \\pm 2, \\ldots\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#勒让德多项式-legendre-polynomials",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#勒让德多项式-legendre-polynomials",
    "title": "Erise Note",
    "section": "4.1.7 勒让德多项式 (Legendre Polynomials)",
    "text": "4.1.7 勒让德多项式 (Legendre Polynomials)\nThe \\(\\theta\\) equation becomes:\n\\[\\sin\\theta\\frac{d}{d\\theta}\\left(\\sin\\theta\\frac{d\\Theta}{d\\theta}\\right) + [\\ell(\\ell + 1)\\sin^2\\theta - m^2]\\Theta = 0\\]\nThe solution is: \\[\\Theta(\\theta) = AP_\\ell^m(\\cos\\theta)\\]\nwhere \\(P_\\ell^m\\) is the associated Legendre function defined as: \\[P_\\ell^m(x) = (-1)^m(1-x^2)^{m/2}\\frac{d^m}{dx^m}P_\\ell(x)\\]\nFor negative \\(m\\): \\[P_\\ell^{-m}(x) = (-1)^m\\frac{(\\ell - m)!}{(\\ell + m)!}P_\\ell^m(x)\\] These functions are defined for: - \\(\\ell = 0, 1, 2, \\ldots\\) - \\(m = -\\ell, -\\ell+1, \\ldots, 0, \\ldots, \\ell-1, \\ell\\)\nThe Legendre polynomials \\(P_\\ell(x)\\) can be defined using Rodrigues’ formula: \\[P_\\ell(x) \\equiv \\frac{1}{2^\\ell \\ell!}\\left(\\frac{d}{dx}\\right)^\\ell (x^2 - 1)^\\ell\\] The Legendre polynomials are orthogonal:\n\\[\\int_{-1}^{1} dx P_\\ell(x)P_{\\ell'}(x) = \\frac{2}{2\\ell + 1}\\delta_{\\ell,\\ell'}\\]\nFor each value of \\(\\ell\\), there are \\(2\\ell + 1\\) values of \\(m\\).",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#球谐函数-spherical-harmonics",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#球谐函数-spherical-harmonics",
    "title": "Erise Note",
    "section": "4.1.8 球谐函数 (Spherical Harmonics)",
    "text": "4.1.8 球谐函数 (Spherical Harmonics)\nThe normalized angular wave functions, called spherical harmonics, are:\n\\[Y_\\ell^m(\\theta, \\phi) = \\sqrt{\\frac{2\\ell + 1}{4\\pi}\\frac{(\\ell - m)!}{(\\ell + m)!}} e^{im\\phi} P_\\ell^m(\\cos\\theta)\\]\nThese functions are orthonormal:\n\\[\\int_0^{2\\pi} d\\phi \\int_0^{\\pi} \\sin\\theta d\\theta [Y_\\ell^m(\\theta, \\phi)]^* Y_{\\ell'}^{m'}(\\theta, \\phi) = \\delta_{\\ell\\ell'}\\delta_{mm'}\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#径向方程-radial-equation",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.1 经典氢原子.html#径向方程-radial-equation",
    "title": "Erise Note",
    "section": "4.1.9 径向方程 (Radial Equation)",
    "text": "4.1.9 径向方程 (Radial Equation)\nThe radial equation is:\n\\[\\frac{d}{dr}\\left(r^2\\frac{dR}{dr}\\right) - \\frac{2mr^2}{\\hbar^2}[V(r) - E]R = \\ell(\\ell + 1)R\\]\nA useful substitution is: \\(u(r) \\equiv rR(r)\\), which transforms the radial equation to: \\[-\\frac{\\hbar^2}{2m}\\frac{d^2u}{dr^2} + \\left[V + \\frac{\\hbar^2\\ell(\\ell+1)}{2mr^2}\\right]u = Eu\\] The term \\(\\frac{\\hbar^2\\ell(\\ell+1)}{2mr^2}\\) is called the centrifugal term or effective potential. The normalization condition becomes: \\[\\int_0^{\\infty} |u|^2 dr = 1\\] ## 4.1.10 无限球势阱 (Infinite Spherical Well)\nConsider a potential: \\[V(r) = \\begin{cases}\n0, & r \\leq a \\\\\n\\infty, & r &gt; a\n\\end{cases}\\] ### 对于 \\(\\ell = 0\\) (For \\(\\ell = 0\\))\nInside the well, the radial equation becomes:\n\\[\\frac{d^2u}{dr^2} = -k^2u\\]\nwhere \\[k \\equiv \\frac{\\sqrt{2mE}}{\\hbar}\\].\nThe general solution is:\n\\[u(r) = A\\sin(kr) + B\\cos(kr)\\]\nFor \\(r=0\\), we must have \\(u(0) = 0\\) (since \\(R(r)\\) must remain finite), which means \\[B = 0\\].\nAt the boundary \\(r = a\\), we have \\(u(a) = 0\\), which gives:\n\\[\\sin(ka) = 0 \\Rightarrow ka = N\\pi\\]\nwhere \\(N\\) is an integer. This gives the energy eigenvalues:\n\\[E_{N0} = \\frac{N^2\\pi^2\\hbar^2}{2ma^2}, \\quad (N = 1, 2, 3, \\ldots)\\]\nThe normalized wave function is:\n\\[u_{N0} = \\sqrt{\\frac{2}{a}}\\sin\\left(\\frac{N\\pi r}{a}\\right)\\]\n\n对于 \\(\\ell &gt; 0\\) (For \\(\\ell &gt; 0\\))\nThe solution involves spherical Bessel functions:\n\\[u(r) = Arj_\\ell(kr) + Brn_\\ell(kr)\\]\nwhere \\(j_\\ell(x)\\) is the spherical Bessel function of order \\(\\ell\\), and \\(n_\\ell(x)\\) is the spherical Neumann function of order \\(\\ell\\).\nThe spherical Bessel functions are defined as:\n\\[j_\\ell(x) \\equiv (-x)^\\ell\\left(\\frac{1}{x}\\frac{d}{dx}\\right)^\\ell \\frac{\\sin x}{x}\\]\n\\[n_\\ell(x) \\equiv -(-x)^\\ell\\left(\\frac{1}{x}\\frac{d}{dx}\\right)^\\ell \\frac{\\cos x}{x}\\]\nFor example: \\[j_0(x) = \\frac{\\sin x}{x}; \\quad n_0(x) = -\\frac{\\cos x}{x}\\]\n\\[j_1(x) = (-x)\\frac{1}{x}\\frac{d}{dx}\\left(\\frac{\\sin x}{x}\\right) = \\frac{\\sin x}{x^2} - \\frac{\\cos x}{x}\\]\nSince \\(n_\\ell(0)\\) diverges, we must set \\[B = 0\\] for physical solutions.\nThe boundary condition \\(u(a) = 0\\) gives:\n\\[j_\\ell(ka) = 0\\]\nIf we denote the nth zero of \\(j_\\ell(x)\\) as \\(\\beta_{N\\ell}\\), then:\n\\[k = \\frac{1}{a}\\beta_{N\\ell}\\]\nAnd the energy eigenvalues are:\n\\[E_{N\\ell} = \\frac{\\hbar^2}{2ma^2}\\beta_{N\\ell}^2\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.1.1 经典氢原子 (Classical Hydrogen Atom)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html",
    "title": "Erise Note",
    "section": "",
    "text": "The stationary states of the hydrogen atom are labeled by three quantum numbers: \\(n\\), \\(\\ell\\), and \\(m\\). The principal quantum number (\\(n\\)) determines the energy of the state, while \\(\\ell\\) and \\(m\\) are related to the orbital angular momentum. In classical physics, energy and angular momentum are fundamental conserved quantities, so it’s not surprising that angular momentum plays an important role in quantum theory as well.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#量子数-quantum-numbers",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#量子数-quantum-numbers",
    "title": "Erise Note",
    "section": "",
    "text": "The stationary states of the hydrogen atom are labeled by three quantum numbers: \\(n\\), \\(\\ell\\), and \\(m\\). The principal quantum number (\\(n\\)) determines the energy of the state, while \\(\\ell\\) and \\(m\\) are related to the orbital angular momentum. In classical physics, energy and angular momentum are fundamental conserved quantities, so it’s not surprising that angular momentum plays an important role in quantum theory as well.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#经典角动量-classical-angular-momentum",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#经典角动量-classical-angular-momentum",
    "title": "Erise Note",
    "section": "4.3.2 经典角动量 (Classical Angular Momentum)",
    "text": "4.3.2 经典角动量 (Classical Angular Momentum)\nClassically, the angular momentum of a particle (with respect to the origin) is given by:\n\\[\\mathbf{L} = \\mathbf{r} \\times \\mathbf{p}\\]\nIn component form, this gives us:\n\\[L_x = yp_z - zp_y, \\quad L_y = zp_x - xp_z, \\quad L_z = xp_y - yp_x\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#量子算符-quantum-operators",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#量子算符-quantum-operators",
    "title": "Erise Note",
    "section": "4.3.3 量子算符 (Quantum Operators)",
    "text": "4.3.3 量子算符 (Quantum Operators)\nIn quantum mechanics, we obtain the corresponding operators by the standard prescription:\n\\[p_x \\rightarrow -i\\hbar\\frac{\\partial}{\\partial x}, \\quad p_y \\rightarrow -i\\hbar\\frac{\\partial}{\\partial y}, \\quad p_z \\rightarrow -i\\hbar\\frac{\\partial}{\\partial z}\\]\nNow we’ll explore the eigenvalues of the angular momentum operators through algebraic techniques based on commutation relations.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#本征值-eigenvalues",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#本征值-eigenvalues",
    "title": "Erise Note",
    "section": "4.3.4 本征值 (Eigenvalues)",
    "text": "4.3.4 本征值 (Eigenvalues)\n\n交换关系 (Commutation Relations)\nThe operators \\(L_x\\) and \\(L_y\\) do not commute. Let’s calculate their commutator:\n\\[[L_x, L_y] = [yp_z - zp_y, zp_x - xp_z]\\]\nExpanding this: \\[[L_x, L_y] = [yp_z, zp_x] - [yp_z, xp_z] - [zp_y, zp_x] + [zp_y, xp_z]\\]\nFrom canonical commutation relations, we know that only \\(x\\) with \\(p_x\\), \\(y\\) with \\(p_y\\), and \\(z\\) with \\(p_z\\) fail to commute. So the two middle terms drop out:\n\\[[L_x, L_y] = yp_z[z, p_x] + xp_z[z, p_y] = i\\hbar(xp_y - yp_x) = i\\hbar L_z\\]\nBy cyclic permutation of indices, we can obtain the other commutation relations:\n\\[[L_x, L_y] = i\\hbar L_z; \\quad [L_y, L_z] = i\\hbar L_x; \\quad [L_z, L_x] = i\\hbar L_y\\]\nThese are the fundamental commutation relations for angular momentum; everything follows from them.\n\n\n不相容的可观测量 (Incompatible Observables)\nNotice that \\(L_x\\), \\(L_y\\), and \\(L_z\\) are incompatible observables. According to the generalized uncertainty principle:\n\\[\\sigma_{L_x}\\sigma_{L_y} \\geq \\frac{\\hbar}{2}|\\langle L_z \\rangle|\\]\nThis means it would be futile to look for states that are simultaneously eigenfunctions of \\(L_x\\) and \\(L_y\\). However, the square of the total angular momentum:\n\\[L^2 = L_x^2 + L_y^2 + L_z^2\\]\ndoes commute with all components of \\(\\mathbf{L}\\):\n\\[[L^2, L_x] = [L_x^2, L_x] + [L_y^2, L_x] + [L_z^2, L_x] = 0\\]\n\\[[L^2, L_y] = 0, \\quad [L^2, L_z] = 0\\]\nOr more compactly:\n\\[[L^2, \\mathbf{L}] = 0\\]\nSo we can hope to find simultaneous eigenstates of \\(L^2\\) and (say) \\(L_z\\):\n\\[L^2 f = \\lambda f \\quad \\text{and} \\quad L_z f = \\mu f\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#阶梯算符-ladder-operators",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#阶梯算符-ladder-operators",
    "title": "Erise Note",
    "section": "4.3.5 阶梯算符 (Ladder Operators)",
    "text": "4.3.5 阶梯算符 (Ladder Operators)\nWe’ll use the ladder operator technique, similar to the harmonic oscillator treatment. Define:\n\\[L_{\\pm} = L_x \\pm iL_y\\]\nThe commutator with \\(L_z\\) is:\n\\[[L_z, L_{\\pm}] = [L_z, L_x] \\pm i[L_z, L_y] = i\\hbar L_y \\pm i(-i\\hbar L_x) = \\pm\\hbar(L_x \\pm iL_y) = \\pm\\hbar L_{\\pm}\\]\nSo: \\[[L_z, L_{\\pm}] = \\pm\\hbar L_{\\pm}\\]\nAlso: \\[[L^2, L_{\\pm}] = 0\\]\nIf \\(f\\) is an eigenfunction of \\(L^2\\) and \\(L_z\\), so is \\(L_{\\pm}f\\):\n\\[L^2(L_{\\pm}f) = L_{\\pm}(L^2f) = L_{\\pm}(\\lambda f) = \\lambda(L_{\\pm}f)\\]\n\\[L_z(L_{\\pm}f) = (L_zL_{\\pm} - L_{\\pm}L_z + L_{\\pm}L_z)f = (\\pm\\hbar L_{\\pm} + L_{\\pm}L_z)f = (\\mu \\pm \\hbar)(L_{\\pm}f)\\]\nSo \\(L_{\\pm}f\\) is an eigenfunction of \\(L_z\\) with eigenvalue \\(\\mu \\pm \\hbar\\). We call \\(L_+\\) the raising operator (increases eigenvalue by \\(\\hbar\\)) and \\(L_-\\) the lowering operator (decreases eigenvalue by \\(\\hbar\\)).\nFor a given \\(\\lambda\\), we get a “ladder” of states with each “rung” separated by \\(\\hbar\\) in the eigenvalue of \\(L_z\\). But this process must end somewhere. There must be a “top rung” \\(f_t\\) such that:\n\\[L_+f_t = 0\\]\nLet \\(\\hbar\\ell\\) be the eigenvalue of \\(L_z\\) at the top rung:\n\\[L_zf_t = \\hbar\\ell f_t; \\quad L^2f_t = \\lambda f_t\\]\nNow:\n\\[L_{\\pm}L_{\\mp} = (L_x \\pm iL_y)(L_x \\mp iL_y) = L_x^2 + L_y^2 \\mp i(L_xL_y - L_yL_x) = L^2 - L_z^2 \\mp i\\hbar L_z\\]\nSo: \\[L^2 = L_+L_- + L_z^2 + \\hbar L_z\\]\nThis gives: \\[L^2f_t = (L_-L_+ + L_z^2 - \\hbar L_z)f_t = (0 + \\hbar^2\\ell^2 - \\hbar^2\\ell)f_t = \\hbar^2\\ell(\\ell - 1)f_t\\]\nAnd: \\[\\lambda = \\hbar^2\\ell(\\ell - 1)\\]\nSimilarly, there must be a “bottom rung” \\(f_b\\) such that:\n\\[L_-f_b = 0\\]\nWith: \\[L_zf_b = \\hbar\\tilde{\\ell}f_b; \\quad L^2f_b = \\lambda f_b\\]\nThis leads to: \\[\\lambda = \\hbar^2\\tilde{\\ell}(\\tilde{\\ell} + 1)\\]\nComparing these equations for \\(\\lambda\\), we find that \\(\\ell(\\ell - 1) = \\tilde{\\ell}(\\tilde{\\ell} + 1)\\), which means either \\(\\tilde{\\ell} = \\ell + 1\\) (absurd—the bottom rung would be higher than the top rung!) or:\n\\[\\tilde{\\ell} = -\\ell\\]\nThus, the eigenvalues of \\(L_z\\) are \\(m\\hbar\\), where \\(m\\) goes from \\(-\\ell\\) to \\(+\\ell\\) in integer steps. In particular, \\(\\ell = -\\tilde{\\ell} + N\\), and thus \\(\\ell = N/2\\), which means \\(\\ell\\) must be an integer or a half-integer.\nThe eigenfunctions are characterized by the numbers \\(\\ell\\) and \\(m\\):\n\\[L^2f_\\ell^m = \\hbar^2\\ell(\\ell + 1)f_\\ell^m; \\quad L_zf_\\ell^m = \\hbar mf_\\ell^m\\]\nwhere: \\[\\ell = 0, 1/2, 1, 3/2, \\ldots; \\quad m = -\\ell, -\\ell + 1, \\ldots, \\ell - 1, \\ell\\]\nFor a given value of \\(\\ell\\), there are \\(2\\ell + 1\\) different values of \\(m\\) (i.e., \\(2\\ell + 1\\) “rungs” on the “ladder”).",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#角动量的球坐标表示-angular-momentum-in-spherical-coordinates",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#角动量的球坐标表示-angular-momentum-in-spherical-coordinates",
    "title": "Erise Note",
    "section": "4.3.6 角动量的球坐标表示 (Angular Momentum in Spherical Coordinates)",
    "text": "4.3.6 角动量的球坐标表示 (Angular Momentum in Spherical Coordinates)\nTo determine the eigenfunctions \\(f_\\ell^m(\\theta, \\phi)\\), we need to express the angular momentum operators in spherical coordinates.\nFirst, we rewrite \\(L_x\\), \\(L_y\\), and \\(L_z\\) in spherical coordinates:\n\\[L_z = -i\\hbar\\frac{\\partial}{\\partial\\phi}\\]\n\\[L_x = -i\\hbar\\left(-\\sin\\phi\\frac{\\partial}{\\partial\\theta} - \\cos\\phi\\cot\\theta\\frac{\\partial}{\\partial\\phi}\\right)\\]\n\\[L_y = -i\\hbar\\left(\\cos\\phi\\frac{\\partial}{\\partial\\theta} - \\sin\\phi\\cot\\theta\\frac{\\partial}{\\partial\\phi}\\right)\\]\nThe raising and lowering operators become:\n\\[L_{\\pm} = \\pm\\hbar e^{\\pm i\\phi}\\left(\\frac{\\partial}{\\partial\\theta} \\pm i\\cot\\theta\\frac{\\partial}{\\partial\\phi}\\right)\\]\nAnd \\(L^2\\) takes the form:\n\\[L^2 = -\\hbar^2\\left[\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right) + \\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\\phi^2}\\right]\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#球谐函数-spherical-harmonics",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#球谐函数-spherical-harmonics",
    "title": "Erise Note",
    "section": "4.3.7 球谐函数 (Spherical Harmonics)",
    "text": "4.3.7 球谐函数 (Spherical Harmonics)\nNow we can determine \\(f_\\ell^m(\\theta, \\phi)\\). It’s an eigenfunction of \\(L^2\\) with eigenvalue \\(\\hbar^2\\ell(\\ell + 1)\\):\n\\[L^2f_\\ell^m = -\\hbar^2\\left[\\frac{1}{\\sin\\theta}\\frac{\\partial}{\\partial\\theta}\\left(\\sin\\theta\\frac{\\partial}{\\partial\\theta}\\right) + \\frac{1}{\\sin^2\\theta}\\frac{\\partial^2}{\\partial\\phi^2}\\right]f_\\ell^m = \\hbar^2\\ell(\\ell + 1)f_\\ell^m\\]\nIt’s also an eigenfunction of \\(L_z\\) with eigenvalue \\(m\\hbar\\):\n\\[L_zf_\\ell^m = -i\\hbar\\frac{\\partial}{\\partial\\phi}f_\\ell^m = \\hbar mf_\\ell^m\\]\nThis is equivalent to the azimuthal equation. We have already solved this system of equations! The result (appropriately normalized) is the spherical harmonic:\n\\[f_\\ell^m(\\theta, \\phi) = Y_\\ell^m(\\theta, \\phi)\\]\nConclusion: Spherical harmonics are the eigenfunctions of \\(L^2\\) and \\(L_z\\). When we solved the Schrödinger equation by separation of variables, we were inadvertently constructing simultaneous eigenfunctions of the three commuting operators \\(H\\), \\(L^2\\), and \\(L_z\\):\n\\[H\\psi = E\\psi, \\quad L^2\\psi = \\hbar^2\\ell(\\ell + 1)\\psi, \\quad L_z\\psi = \\hbar m\\psi\\]\nThis explains why the spherical harmonics are orthogonal: they are eigenfunctions of hermitian operators (\\(L^2\\) and \\(L_z\\)) belonging to distinct eigenvalues.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#重要结论-key-conclusions",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/4.3 角动量 (Angular Momentum).html#重要结论-key-conclusions",
    "title": "Erise Note",
    "section": "重要结论 (Key Conclusions)",
    "text": "重要结论 (Key Conclusions)\n\nAngular momentum operators satisfy the fundamental commutation relations: \\([L_i, L_j] = i\\hbar\\epsilon_{ijk}L_k\\)\nWhile the individual components \\(L_x\\), \\(L_y\\), and \\(L_z\\) do not commute with each other, \\(L^2\\) commutes with all components.\nThe eigenvalues of \\(L^2\\) are \\(\\hbar^2\\ell(\\ell+1)\\) where \\(\\ell\\) can be integer or half-integer.\nFor each value of \\(\\ell\\), the eigenvalues of \\(L_z\\) are \\(\\hbar m\\) where \\(m\\) ranges from \\(-\\ell\\) to \\(+\\ell\\) in integer steps.\nFor a given \\(\\ell\\), there are \\(2\\ell+1\\) different values of \\(m\\).\nThe eigenfunctions of \\(L^2\\) and \\(L_z\\) are the spherical harmonics \\(Y_\\ell^m(\\theta,\\phi)\\).\nIn quantum mechanics, angular momentum cannot point in a definite direction; when \\(L_z\\) has a well-defined value, \\(L_x\\) and \\(L_y\\) do not.",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章",
      "4.3.1 量子数 (Quantum Numbers)"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/Lecture/第四章/index.html",
    "href": "content/notes/计算/量子力学讲义/Lecture/第四章/index.html",
    "title": "第四章",
    "section": "",
    "text": "4.1 三维空间的薛定谔方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.1 经典氢原子 (Classical Hydrogen Atom)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3.1 量子数 (Quantum Numbers)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n氢原子\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "Lecture",
      "第四章"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/index.html",
    "href": "content/notes/计算/量子力学讲义/index.html",
    "title": "量子力学讲义",
    "section": "",
    "text": "4.1 三维空间的薛定谔方程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.1.1 经典氢原子 (Classical Hydrogen Atom)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n4.3.1 量子数 (Quantum Numbers)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLecture\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThree quantum indeterminacy position:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n氢原子\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n波函数存在于Hilbert空间中\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第一章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n第四章\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n薛定谔方程的傅立叶变换\n\n\n\n\n\n\n\n\n2025年2月5日\n\n\n\n\n\n\n\n\n\n\n\n\n量子自旋态与算符讲义（Quantum Spin States and Operators Lecture Notes）\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "量子力学讲义"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/薛定谔方程的傅立叶变换.html",
    "href": "content/notes/计算/量子力学讲义/薛定谔方程的傅立叶变换.html",
    "title": "薛定谔方程的傅立叶变换",
    "section": "",
    "text": "\\[\n\\hat{H}=-\\frac{\\hbar^{2}}{2m}\\partial^{2}x+V(x)\n\\] Stationary States \\[\n\\Psi(x,t)=\\psi(x)e^{-iEt/\\hbar}\n\\] Eigenvalue equation: \\[\\hat{H}\\psi(x) = E\\psi(x)\\] In newtonian mechanics, note \\[F(x)=-\\frac{ \\partial V(x) }{ \\partial x } \\] ## 1. Infinite Finite Well (particle on a box) \\[E = \\frac{p^{2}}{2m}\\] &gt; knowing \\(E\\) results in knowing momentum \\(p^{2}\\)\nProblem Set-up Between \\(x=0\\), and \\(x=a\\), \\[-\\frac{\\hbar^{2}}{2m} \\frac{d^{2}}{dx}\\Psi(x)=E \\Psi(x)\\] Subject to “boundary condition”: \\(\\Psi(0)=\\Psi(a)=0\\) \\[\n\\begin{align}\n\\frac{d^{2}\\Psi}{dx} & =-\\left( \\frac{2m}{\\hbar^{2}} \\right) E \\Psi \\\\\n& =-k^{2}\\Psi\n\\end{align}\n\\] Recall\n\nSolution: 1. \\(\\Psi(x)=C_{1}e^{ikx}+C_{2}e^{-ikx}\\) 2. \\(\\Psi(x)=C_{1}\\cos(kx)+ C_{2}\\sin(kx)\\) (picked this version)\nThe solution is in the form of \\[\\Psi(x)=A\\sin(kx)+ B\\cos(kx)\\] Impose the boundary condition: 1. \\(\\Psi(x=0)=B\\cos(0)=0\\) \\[\\boxed{B=0}\\] 1. \\(\\Psi(x=a)=A\\sin(ka)=0\\) \\[\\begin{align}\n\\sin(ka) & =0 \\\\\nka & =+\\boldsymbol{\\pi},+2\\boldsymbol{\\pi},+3\\boldsymbol{\\pi}\\dots \\\\\nk_{n} & =\\frac{n\\boldsymbol{\\pi}}{a} \\quad \\{n\\in \\mathbb{N}\\} \\Rightarrow \\boxed{E_{n}=\\frac{\\hbar^{2}\\pi^{2}n^{2}}{2ma^{2}}}\n\\end{align}\\] &gt;Note: \\(n \\neq 0\\), since the eq. would vanish entirely. \\(n&gt;0\\), for positive \\(k\\).",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "薛定谔方程的傅立叶变换"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/薛定谔方程的傅立叶变换.html#review",
    "href": "content/notes/计算/量子力学讲义/薛定谔方程的傅立叶变换.html#review",
    "title": "薛定谔方程的傅立叶变换",
    "section": "",
    "text": "\\[\n\\hat{H}=-\\frac{\\hbar^{2}}{2m}\\partial^{2}x+V(x)\n\\] Stationary States \\[\n\\Psi(x,t)=\\psi(x)e^{-iEt/\\hbar}\n\\] Eigenvalue equation: \\[\\hat{H}\\psi(x) = E\\psi(x)\\] In newtonian mechanics, note \\[F(x)=-\\frac{ \\partial V(x) }{ \\partial x } \\] ## 1. Infinite Finite Well (particle on a box) \\[E = \\frac{p^{2}}{2m}\\] &gt; knowing \\(E\\) results in knowing momentum \\(p^{2}\\)\nProblem Set-up Between \\(x=0\\), and \\(x=a\\), \\[-\\frac{\\hbar^{2}}{2m} \\frac{d^{2}}{dx}\\Psi(x)=E \\Psi(x)\\] Subject to “boundary condition”: \\(\\Psi(0)=\\Psi(a)=0\\) \\[\n\\begin{align}\n\\frac{d^{2}\\Psi}{dx} & =-\\left( \\frac{2m}{\\hbar^{2}} \\right) E \\Psi \\\\\n& =-k^{2}\\Psi\n\\end{align}\n\\] Recall\n\nSolution: 1. \\(\\Psi(x)=C_{1}e^{ikx}+C_{2}e^{-ikx}\\) 2. \\(\\Psi(x)=C_{1}\\cos(kx)+ C_{2}\\sin(kx)\\) (picked this version)\nThe solution is in the form of \\[\\Psi(x)=A\\sin(kx)+ B\\cos(kx)\\] Impose the boundary condition: 1. \\(\\Psi(x=0)=B\\cos(0)=0\\) \\[\\boxed{B=0}\\] 1. \\(\\Psi(x=a)=A\\sin(ka)=0\\) \\[\\begin{align}\n\\sin(ka) & =0 \\\\\nka & =+\\boldsymbol{\\pi},+2\\boldsymbol{\\pi},+3\\boldsymbol{\\pi}\\dots \\\\\nk_{n} & =\\frac{n\\boldsymbol{\\pi}}{a} \\quad \\{n\\in \\mathbb{N}\\} \\Rightarrow \\boxed{E_{n}=\\frac{\\hbar^{2}\\pi^{2}n^{2}}{2ma^{2}}}\n\\end{align}\\] &gt;Note: \\(n \\neq 0\\), since the eq. would vanish entirely. \\(n&gt;0\\), for positive \\(k\\).",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "薛定谔方程的傅立叶变换"
    ]
  },
  {
    "objectID": "content/notes/计算/量子力学讲义/薛定谔方程的傅立叶变换.html#normalization",
    "href": "content/notes/计算/量子力学讲义/薛定谔方程的傅立叶变换.html#normalization",
    "title": "薛定谔方程的傅立叶变换",
    "section": "3. Normalization",
    "text": "3. Normalization\n\\[\\Psi(x)=A\\sin(k_{n}x)=A\\sin\\left( \\frac{n\\pi x}{a} \\right)\\] We normalize \\[\n\\begin{align}\n\\int^a_{b}|\\Psi_{n}(x)|^{2}\\, dx & =1 \\\\\nA^{2}\\int^a_{b}\\sin ^{2}\\left( \\frac{n\\pi x}{a} \\right)\\, dx & =1 \\\\\nA^{2}\\cdot \\frac{a}{2} & =1 \\Rightarrow A=\\sqrt{ \\frac{2}{a} }\n\\end{align}\n\\] Final Solution: \\[\\Psi(x)=A\\sin(k_{n}x)=\\sqrt{ \\frac{2}{a} }\\sin\\left( \\frac{n\\pi x}{a} \\right) \\quad \\{n\\in \\mathbb{N}\\}\\] (A): Why \\(E_{1}&gt;0\\)? \\[\\begin{aligned}  \\Delta x &\\sim a \\\\  \\Delta p \\cdot \\Delta x &\\sim \\hbar \\\\  \\Delta p &\\sim \\frac{\\hbar}{a} \\quad \\Longrightarrow \\quad KE\\sim \\frac{(\\Delta p)^2}{2 m} \\sim \\frac{\\hbar^2}{2 m a^2}\\end{aligned}\\] (B) States with higher energy have more nodes (C) States are orthonormal: \\[\\int_0^a d x \\Psi_n^*(x) \\Psi_m(x)=\\delta_{n m}\\] (D) Completeness: \\(f(x)\\) defined on the interval \\([0,a]\\), with \\(f(x=0) = f(x=a) = 0\\).\nFourier Series Representation: \\[\nf(x) = \\sum_{n=1}^{\\infty} c_n \\psi_n(x) = \\sqrt{\\frac{2}{a}} \\sum_{n=1}^{\\infty} c_n \\sin\\left(\\frac{n\\pi x}{a}\\right)\n\\] \\[\n\\begin{align}\n\\int_0^a dx \\, \\Psi_m^*(x) f(x)  & = \\sum_{n=1}^{\\infty} C_n \\int_0^a dx \\, \\Psi_m^*(x) \\Psi_n(x)\n\\\\ & =\\sum_{n=1}^{\\infty} C_n \\delta_{m,n} \\\\\n& =C_m\n\\end{align}\n\\]$$\n\\[\n\\] $$\n\\[\n\\delta_{m,n} =\n\\begin{cases}\n1, & \\text{if } m = n \\\\\n0, & \\text{if } m \\neq n\n\\end{cases}\n\\]",
    "crumbs": [
      "Notes",
      "量子力学讲义",
      "薛定谔方程的傅立叶变换"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html",
    "href": "content/posts/Image to 3D-Model.html",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "Creating 3D clothing from 2D anime-style references (like Genshin Impact outfits) is now faster with AI-assisted tools, though manual refinement is often needed for the best results. This guide focuses on clothing conversion – taking 2D images of robes, armor, or accessories and turning them into stylized 3D meshes with clean topology. We’ll explore the top AI tools and workflows (as of 2025) and outline a step-by-step process compatible with Blender.\n\n\n\nStylized Fidelity: The 3D clothing should match the anime/Genshin Impact aesthetic of the concept art (shapes, folds, and design details).\nOptimized Topology: Meshes need clean, animation-friendly topology (proper edge loops, reasonable polycount) for attaching to a rigged character.\nTexture & Detail: Preserve clothing details (patterns, trims, armor segments) either as modeled geometry or textures/normal maps.\nRigging Compatibility: The generated clothing must fit the existing character and allow weight painting or rig transfers so it deforms correctly during animation.\nMinimal Restrictions: Tools that allow creative freedom (no strict content rules) are preferred so any custom outfit design can be used.\n\n\n\n\nModern AI tools can convert a single 2D image into a 3D model in minutes (Converting 2D Images into 3D Models with AI: The step-by-step Guide). These are particularly useful to get a base 3D mesh of a clothing piece quickly, which can then be refined. Below are some of the best options:\n\nMeshy AI (Image to 3D): A popular AI 3D model generator with an image-to-3D feature and even a Blender plugin (Meshy AI - The #1 AI 3D Model Generator for Creators) (Meshy AI - The #1 AI 3D Model Generator for Creators). Meshy supports different art styles (including anime) for output (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Meshy AI - The #1 AI 3D Model Generator for Creators). You upload concept art or reference photos and get a 3D model with textures. Pros: Fast cloud generation, supports versatile art styles (can capture stylized looks) (Meshy AI - The #1 AI 3D Model Generator for Creators), exports to common formats (OBJ, FBX, GLB, etc.) for easy Blender import (Meshy AI - The #1 AI 3D Model Generator for Creators). Cons: Paid service (free tier available with limits), and results may require cleanup if topology is dense or if some parts are inaccurate.\nMazing AI / 3DFY.ai: Services that turn single images into 3D models with a focus on realism and high quality (Converting 2D Images into 3D Models with AI: The step-by-step Guide). Mazing (an e-commerce oriented tool) emphasizes automatic texturing and real-time optimization (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide). 3DFY.ai similarly promises high-quality results from one image (3DFY.ai). Pros: Quick image to model conversion; optimized for product visuals. Cons: May be geared towards realistic objects; stylized anime clothing might need additional editing to match the art style.\nKaedim and Alternatives (Tripo 3D, Alpha3D): Kaedim is an AI-assisted service where you upload an image (even a sketch or concept) and their pipeline (ML + human touch-ups) delivers a 3D model (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify). Tripo 3D offers a similar “single image to 3D in seconds” solution with emphasis on detailed geometry and textures (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify). Alpha3D provides image-to-3D generation but currently only for certain categories (e.g. shoes, furniture) (Transform text and 2D images into 3D assets with generative AI for free - Alpha3D). Pros: These services deliver production-ready assets with textures and decent topology, suitable for game engines (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify). Cons: They are paid services (some with subscriptions) and may have category limits. Quality can vary – often a good starting point but still might need retopology for optimal loops.\nThe New Black (AI Fashion Generator): A specialized tool for fashion design that can turn an outfit image into a realistic 3D clothing model (AI Fashion Features | Clothing Design). It’s geared toward apparel designers (e.g. previewing how a garment looks in 3D). Pros: Focused on clothing, likely good with fabric details like folds and drape. Cons: Primarily aimed at realistic fashion; you might need to simplify or stylize the output for anime characters. Also, it may output standalone clothing on a generic avatar that you’ll have to refit to your character.\nHunyuan 3D (Tencent): An AI model available via HuggingFace that generates 3D meshes from an image (used in the community alongside Meshy) (Do you know an AI to create cloth and outfit? - Daz 3D Forums). It’s free to try and can handle characters or clothes. Pros: Free and accessible; known to work for generating a rough clothed figure mesh. Cons: The output might be a combined human+clothes mesh (if the input was a full character image) and will definitely require manual retopology and separation of the clothing. Good for getting the overall shape of a complex outfit, but not a final game-ready mesh.\n“Pic-to-3D Mesh” Blender Add-on: An add-on that integrates AI image-to-3D conversion directly in Blender (Top AI Tools for Model Generation on Blender 3D - Vagon). You can input a reference image (e.g. a front view of a costume) and it generates a detailed 3D mesh inside Blender (Top AI Tools for Model Generation on Blender 3D - Vagon). Pros: Fully inside Blender – no need to use external apps; straightforward UI and quick conversion with just a few clicks (Top AI Tools for Model Generation on Blender 3D - Vagon). This is useful to instantly get a mesh that you can start editing in the same session. Cons: Being relatively new, results can be hit-or-miss on complex armor or multi-layer outfits; likely works best for simpler garments or accessory pieces.\nPixelModeler AI (Blender Add-on): A unique workflow where you paint on a 2D canvas in Blender and an AI generates a corresponding 3D mesh (PixelModeller AI - Blender Market) (PixelModeller AI - Blender Market). This can be used by painting the silhouette or even a depth map of the clothing; the addon will create a solid mesh from it. Generated models are watertight, UV-mapped, and come with vertex colors (a basic texture) (Top AI Tools for Model Generation on Blender 3D - Vagon), ready for further detailing. Pros: Gives a lot of control – you essentially guide the shape by painting, so it’s AI-assisted modeling rather than fully automatic. No external service needed (the AI model runs locally) (PixelModeller AI - Blender Market). Cons: There is a learning curve to painting effective guides. It won’t automatically produce intricate patterns – you’ll need to add those via texture or additional modeling.\n\n\n\nBelow is a quick comparison of these tools relevant to 2D-to-3D clothing conversion:\n\n\n\nTool/Service\nType\nOutput Quality\nTopology & UVs\nIntegration with Blender\nNotes\n\n\n\n\nMeshy AI\nCloud AI (image→3D)\nHigh detail; supports anime style (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Meshy AI - The #1 AI 3D Model Generator for Creators)\nDecent mesh; textured output (may need retopo)\nBlender plugin available (Meshy AI - The #1 AI 3D Model Generator for Creators)\nFast; paid (free trial available).\n\n\nMazing / 3DFY.ai\nCloud AI (image→3D)\nPhotorealistic focus, good folds\nOptimized for real-time (Converting 2D Images into 3D Models with AI: The step-by-step Guide); provides textures\nExports standard formats (OBJ/FBX)\nGreat for realism; stylization may require tweaks.\n\n\nKaedim\nCloud AI (+human)\nCustom models from concept art\nCleaned by artists; quad topology\nDownload to import in Blender\nConsistent results; subscription-based.\n\n\nTripo 3D\nCloud AI (image→3D)\nFast generation, detailed textures ([Kaedim Alternatives in 2025\nBest Kaedim Alternatives - Toolify](https://www.toolify.ai/alternative/kaedim#:~:text=,model%20generation))\nUnknown topology quality\nExports GLB/OBJ\n\n\nThe New Black (Fashion)\nCloud AI (image→3D)\nRealistic garment on avatar\nLikely well-formed cloth mesh\nExport capabilities (likely OBJ/FBX)\nFashion design oriented; may need rigging after import.\n\n\nHunyuan (Tencent)\nCloud AI (image→3D)\nFull character mesh with clothes\nHigh-poly, needs retopo\nOBJ export via HuggingFace demo\nFree; good for concept shape (Do you know an AI to create cloth and outfit? - Daz 3D Forums).\n\n\nPic-to-3D (Blender)\nBlender Add-on\nGood for single-object models (Top AI Tools for Model Generation on Blender 3D - Vagon)\nMesh quality varies; UV depends\nInside Blender (no export needed)\nConvenient, no coding needed.\n\n\nPixelModeler (Blender)\nBlender Add-on\nUser-guided, can achieve high detail\nWatertight & UV-mapped (Top AI Tools for Model Generation on Blender 3D - Vagon)\nInside Blender\nInteractive painting workflow.\n\n\n\nTable: AI-Based 2D→3D Clothing Tools – Comparison (performance as of 2025).\n\n\n\n\nFully automated results often need human improvement. In practice, the best quality comes from combining AI generation with manual modeling (Converting 2D Images into 3D Models with AI: The step-by-step Guide). Here are some AI-assisted workflows that clothing artists use:\n\nImage Inpainting + Mesh Generation: One clever approach is to use AI image tools to conceptually dress your character, then extract a model. For example, a community-suggested workflow is: render your character’s base body in T-pose, use an AI image editor (like Stable Diffusion inpainting or Photoshop’s generative fill) to “paint” new clothes onto the image, isolate just the garment in the edited image, then input that into an image-to-3D tool (Meshy or Hunyuan) to get a 3D mesh (Do you know an AI to create cloth and outfit? - Daz 3D Forums). This way, the AI helps create a consistent design on the body and another AI turns it into geometry. You’d still need to retopologize and UV map the result manually (Do you know an AI to create cloth and outfit? - Daz 3D Forums), but it jumpstarts the modeling process for complex costumes.\nDepth Map Extraction: If you have a front-view concept art of the outfit, you can generate a depth map (using AI like MiDaS or Stable Diffusion depth estimation). That depth map can be used to displace a plane or guide a mesh generation. Tools like PixelModeler AI automate this: they generate a depth internally from the image and produce a mesh (PixelModeller AI - Blender Market). The output will capture the relief (folds, protrusions) from the concept art, though you’ll have to model or guess the back side of the garment. This method is useful for armor pieces or relief details on clothing that are visible in the concept.\nTemplate-Based Generation (Parametric): Some solutions use parametric templates plus AI for customization. Sloyd.ai, for instance, combines a library of human-made base models with AI adjustments, ensuring the result is game-ready with UV maps and LODs generated, and optimized meshes (SLOYD AI: A 3D Automation Tool To Generate Game-Ready Assets – startupanz.com). If there are clothing templates (e.g. a generic T-shirt, jacket, dress) you can morph those to roughly match your design and let the tool handle topology. This is semi-manual: you pick the base closest to your design and tweak. Note: As of 2025, parametric generators like Sloyd have many props and environment assets; clothing templates might be limited, but the approach guarantees clean topology if a template fits your needs.\nManual Sculpt with AI Reference: Another assisted route is using the AI output as a reference or base mesh and then manually sculpting over it. For example, you can take a coarse mesh from an AI, bring it into Blender, and use multiresolution sculpting or retopology tools (like Quad Remesher or Blender’s shrinkwrap) to impose a clean topology that follows the AI model’s shape. The AI model essentially serves as a 3D concept sketch. You can also project the texture from the AI model (if it provided one) onto your new topology for a starting point.\n\n\n\n\nWhile AI is speeding things up, manual modeling tools are still crucial, especially for achieving the cleanest results and stylized looks:\n\nMarvelous Designer / CLO3D: These are industry-standard tools for designing clothing using pattern-based simulation. You draw 2D garment patterns, sew them, and the software simulates the cloth on a avatar model – perfect for creating natural folds and drapes. Pros: Extremely high fidelity cloth behavior; great for layered outfits, pleats, ruffles, etc. You can match an anime costume by designing similar patterns. Marvelous can even auto-generate PBR texture maps like normal and opacity for details ([Tips&Tricks] Discover Better Workflow with Marvelous Designer and Unreal Engine – Marvelous Designer). Cons: The meshes are triangulated and high-poly (since it’s focused on simulation). You will need to retopologize the garment for use in a game or realtime engine (Retopology of Marvelous Designer Clothes in Blender - YouTube). Marvelous has introduced some retopo tools (EveryWear Auto-Retopology) and can even rig garments, but often external retopo (using Blender or ZBrush) gives more control. Despite not being AI, Marvelous is frequently recommended for creating custom outfits (Do you know an AI to create cloth and outfit? - Daz 3D Forums) because of the quality of the result. The typical workflow is simulate in Marvelous → export OBJ → retopo in Blender → transfer to character rig.\n\n([Tips&Tricks] Discover Better Workflow with Marvelous Designer and Unreal Engine – Marvelous Designer) Example of a stylized 3D outfit created with cloth simulation. (This fairy-like garment was designed and simulated in Marvelous Designer, showcasing layered fabric, ruffles, and realistic folds.)\n\nBlender’s Sewing/Cloth Tools: If you prefer open-source, Blender itself has cloth simulation and addons like Garment Tool that mimic Marvelous’s pattern sewing approach. You can import your character into Blender, model garment panels (or even trace them from reference images), then use cloth physics to drape them. The result can then be applied as a shape key or applied mesh. You’ll still need to manually refine the mesh topology. Blender’s sculpting tools (cloth brush, slide relax, etc.) can also help adjust folds. This approach is manual and requires skill, but no additional cost.\nDirect Poly Modeling: For hard-surface armor pieces or very structured outfits (like a mech suit or a rigid breastplate), classic poly modeling or box modeling in Blender might be the way to go. You can use the 2D image as a reference in the background and model the clothing piece by piece (ensuring proper topology as you go). This is time-consuming but yields the cleanest meshes. You might use AI just to generate normals or texture details in this case, rather than the mesh.\nRetopology & Refinement Tools: No matter which initial method you choose, retopology tools are vital for clothing. Blender has a PolyBuild and Snap-to-face retopo workflow, and add-ons like RetopoFlow can speed it up. If you have ZBrush, ZRemesher can quickly re-mesh a triangulated Marvelous output into quads, which you can then tweak. There are also auto-retopology AI in development – for instance, some research tools attempt to auto-retopo meshes with neural networks, but in practice most artists still do this part manually or with traditional algorithms. The goal is to end up with edge loops around openings (neck, arm holes) and ideally follow the flow of fabric folds with the topology for deformation.\n\n\n\n\nBringing it all together, here is a step-by-step workflow to convert a 2D outfit into a 3D mesh and attach it to your Blender character, using the best of AI and manual tools:\n1. Gather Reference Images: Ideally have the concept art or reference of the clothing from as many angles as possible. A front view is usually required for AI tools; a side or back view (if available) will help during modeling or can be fed into some tools for better accuracy. If only a front view exists, be prepared to interpret the design for the unseen parts.\n2. Choose an AI Generation Method for Base Mesh: For a head start, pick one of the AI approaches:\n\nOption A: Use Meshy AI (or similar service) to upload the clothing image and generate a 3D model. Download the result (e.g. as a .glb or .obj) when ready (Meshy AI - The #1 AI 3D Model Generator for Creators).\nOption B: In Blender, install the Pic-to-3D Mesh addon and run it on your reference image to get a mesh (Top AI Tools for Model Generation on Blender 3D - Vagon).\nOption C: If the outfit is very complex or you want a full mannequin with clothing, try the Hunyuan 3D demo by providing an image of the clothed character; then extract the clothing mesh from the output.\nOption D: If you have a concept sketch, consider Kaedim/Tripo services for a perhaps cleaner base model (they might return the model next day or in a couple of hours, which you can then use).\nRegardless of option, don’t expect a perfect final model – treat this as a rough draft or proof of concept in 3D. It should capture the overall shape and major details of the clothing.\n\n3. Import and Inspect in Blender: Bring the generated 3D model into Blender. Center and scale it to your character. At this stage:\n\nCheck the mesh density and topology. Are there a lot of uneven triangles or random bumps?\nCheck if all parts of the outfit are present. Sometimes single-view reconstructions leave holes or undefined backs. You may need to patch holes (Blender’s Fill or Grid Fill can help) or even mirror parts of the mesh if symmetry can be assumed.\nIf the tool provided textures, apply them to see the look. However, for anime style, you might later hand-paint textures or use simple materials, so textures are optional.\n\n4. Retopologize the Clothing Mesh: This is crucial for optimization. You can use Blender’s retopology tools to create a new mesh over the AI mesh:\n\nAdd a shrinkwrap modifier on a new mesh and model low-poly geometry that tightly wraps the AI model. Focus on quads and logical edge flow (e.g. edge loops around cuffs, hemlines, and along seams).\nAlternatively, use an auto-retopo tool: for example, Instant Meshes (free tool) or Quad Remesher (paid) to get a quick quad mesh. You might still tweak the output by hand.\nEnsure the retopo’d mesh has proper thickness where needed (you can solidify later if it’s cloth, but parts like armor might be modeled as solid pieces).\nUV unwrap the new mesh if not already UV’d. Good UVs are needed for texturing anime-style details (like emblems or gradients on the fabric).\n\n5. Fit and Attach to the Character: Place the new clothing mesh on the character in the correct pose (usually T-pose or A-pose matching the rig). To attach:\n\nUse Blender’s Transfer Weights: parent the clothing to the armature (with empty groups), then select the body, then clothing, and use Weight Transfer (source: body, destination: clothing). This copies the rig weights so the clothing will move with the body (How separte clothes for Animatoion? - CG Cookie).\nCheck deformation by posing the character. Likely you will need to clean up weights (for instance, ensure sleeves move with the arms, etc. without too much clipping).\nIf the clothing is very close to the body, you might need to delete hidden faces of the character under the clothes to avoid mesh clipping in tight areas (e.g. remove torso polygons under a shirt).\nFor rigid pieces (like armor plates), you may instead want to assign them to a specific bone and keep them rigid or use a bone parent for that object.\n\n6. Detail and Texture: Now polish the visual fidelity:\n\nSculpt or model finer folds that the AI may have missed. You can use Blender’s sculpt mode with the cloth brush or crease brush to imprint additional wrinkle lines where appropriate.\nAdd thickness to cloth if it’s just a single surface (Solidify modifier). Stylized outfits often have a bit of thickness at edges (e.g. a coat lapel).\nTexture Painting: For anime style, a lot of detail can come from textures (like painted shadows or highlights, stylized fabric patterns). You can paint directly in Blender or use Substance 3D Painter. If the original 2D image has patterns (say, a symbol on the back of a cape), use it as a reference or even project it onto your UV map.\nGenerate normal maps if needed. For example, if the outfit has an engraved design or stitching that is too fine to model, you can paint a height map and bake it to a normal map. Some AI tools can assist in generating texture maps from descriptions (e.g. Meshy has an AI texturing feature) (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify), which could be used to create stylized fabric textures by prompting.\n\n7. Iterate and Refine: After these steps, you should have the clothing on the character, but iteration is key:\n\nGo back and forward between sculpting, adjusting topology, and tweaking weights until the clothing looks right and deforms well in various poses.\nIf something is off compared to the concept art (maybe the AI misunderstood a part of the design), you might have to model that part manually. It’s common to model small accessories or intricate pieces separately (for example, a belt buckle or a brooch) and then attach them.\nLOD (Level of Detail): If this is for a game, consider making lower-poly versions or at least ensure the topology is efficient. AI meshes can be decimated or re-generated at lower detail if needed.\n\n8. Final Check and Export: Once satisfied, you can integrate the clothed character into your project. Because we focused on Blender compatibility, you can continue to animate or render in Blender. If exporting to a game engine, export the character with the outfit as FBX/GLTF with the armature. Double-check that all parts are properly bound and that textures are packed or exported.\nThroughout this process, remember that AI is a helper, not a replacement for your skill. Even the best AI-generated model benefits from a human artist’s eye for clean topology and style accuracy. As one guide noted, AI tools speed up getting a base, but “as AI is not perfect, [enhancement] is recommended” to reach production quality (Converting 2D Images into 3D Models with AI: The step-by-step Guide). Don’t hesitate to do manual touch-ups – the goal is a high-quality anime-style outfit that looks like it was hand-crafted for the character.\n\n\n\nConverting 2D anime-style clothing into 3D is becoming more accessible thanks to AI innovations. Tools like Meshy, PicTo3D, and others can generate a quick 3D draft of an outfit from a single concept image (Top AI Tools for Model Generation on Blender 3D - Vagon) (Converting 2D Images into 3D Models with AI: The step-by-step Guide), saving hours of initial modeling. However, the best results come from a hybrid workflow: leveraging AI for speed and then applying traditional modeling techniques for accuracy and clean topology. This collaborative approach (AI plus human) is highlighted as the future of 3D content creation (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide) – AI handles the heavy lifting of shape prediction, while the artist refines and stylizes the final asset.\nBy carefully choosing the right tools and following a structured workflow, you can efficiently bring 2D costume designs into the 3D world, ready to be worn by your Blender character. The combination of AI-assisted generation and manual refinement ensures you get both speed and quality – detailed Genshin Impact-style clothing that not only looks great but is also rigged and optimized for your creative projects.\n\n\n\nMazingXR Blog – “Converting 2D Images to 3D Models with AI” (Feb 2025) (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide)\nVagon Blog – “Top AI Tools for Model Generation on Blender 3D” (Top AI Tools for Model Generation on Blender 3D - Vagon) (Top AI Tools for Model Generation on Blender 3D - Vagon)\nDaz3D Forums – “Do you know an AI to create cloth and outfit?” (Jan 2025) (Do you know an AI to create cloth and outfit? - Daz 3D Forums) (Do you know an AI to create cloth and outfit? - Daz 3D Forums)\nStartupAnz – “Sloyd AI: Game-Ready 3D Asset Generation” (SLOYD AI: A 3D Automation Tool To Generate Game-Ready Assets – startupanz.com)\nAlpha3D.io – “2D image to 3D model generation (limitations)” (Transform text and 2D images into 3D assets with generative AI for free - Alpha3D)\nToolify AI – “Kaedim Alternatives in 2025” (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify) (Tripo3D features)\nMarvelous Designer Official Support – Workflow tips (pleat and texture generation)",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html#key-requirements-for-2d-to-3d-clothing-conversion",
    "href": "content/posts/Image to 3D-Model.html#key-requirements-for-2d-to-3d-clothing-conversion",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "Stylized Fidelity: The 3D clothing should match the anime/Genshin Impact aesthetic of the concept art (shapes, folds, and design details).\nOptimized Topology: Meshes need clean, animation-friendly topology (proper edge loops, reasonable polycount) for attaching to a rigged character.\nTexture & Detail: Preserve clothing details (patterns, trims, armor segments) either as modeled geometry or textures/normal maps.\nRigging Compatibility: The generated clothing must fit the existing character and allow weight painting or rig transfers so it deforms correctly during animation.\nMinimal Restrictions: Tools that allow creative freedom (no strict content rules) are preferred so any custom outfit design can be used.",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html#ai-powered-tools-for-image-to-3d-clothing-conversion",
    "href": "content/posts/Image to 3D-Model.html#ai-powered-tools-for-image-to-3d-clothing-conversion",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "Modern AI tools can convert a single 2D image into a 3D model in minutes (Converting 2D Images into 3D Models with AI: The step-by-step Guide). These are particularly useful to get a base 3D mesh of a clothing piece quickly, which can then be refined. Below are some of the best options:\n\nMeshy AI (Image to 3D): A popular AI 3D model generator with an image-to-3D feature and even a Blender plugin (Meshy AI - The #1 AI 3D Model Generator for Creators) (Meshy AI - The #1 AI 3D Model Generator for Creators). Meshy supports different art styles (including anime) for output (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Meshy AI - The #1 AI 3D Model Generator for Creators). You upload concept art or reference photos and get a 3D model with textures. Pros: Fast cloud generation, supports versatile art styles (can capture stylized looks) (Meshy AI - The #1 AI 3D Model Generator for Creators), exports to common formats (OBJ, FBX, GLB, etc.) for easy Blender import (Meshy AI - The #1 AI 3D Model Generator for Creators). Cons: Paid service (free tier available with limits), and results may require cleanup if topology is dense or if some parts are inaccurate.\nMazing AI / 3DFY.ai: Services that turn single images into 3D models with a focus on realism and high quality (Converting 2D Images into 3D Models with AI: The step-by-step Guide). Mazing (an e-commerce oriented tool) emphasizes automatic texturing and real-time optimization (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide). 3DFY.ai similarly promises high-quality results from one image (3DFY.ai). Pros: Quick image to model conversion; optimized for product visuals. Cons: May be geared towards realistic objects; stylized anime clothing might need additional editing to match the art style.\nKaedim and Alternatives (Tripo 3D, Alpha3D): Kaedim is an AI-assisted service where you upload an image (even a sketch or concept) and their pipeline (ML + human touch-ups) delivers a 3D model (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify). Tripo 3D offers a similar “single image to 3D in seconds” solution with emphasis on detailed geometry and textures (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify). Alpha3D provides image-to-3D generation but currently only for certain categories (e.g. shoes, furniture) (Transform text and 2D images into 3D assets with generative AI for free - Alpha3D). Pros: These services deliver production-ready assets with textures and decent topology, suitable for game engines (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify). Cons: They are paid services (some with subscriptions) and may have category limits. Quality can vary – often a good starting point but still might need retopology for optimal loops.\nThe New Black (AI Fashion Generator): A specialized tool for fashion design that can turn an outfit image into a realistic 3D clothing model (AI Fashion Features | Clothing Design). It’s geared toward apparel designers (e.g. previewing how a garment looks in 3D). Pros: Focused on clothing, likely good with fabric details like folds and drape. Cons: Primarily aimed at realistic fashion; you might need to simplify or stylize the output for anime characters. Also, it may output standalone clothing on a generic avatar that you’ll have to refit to your character.\nHunyuan 3D (Tencent): An AI model available via HuggingFace that generates 3D meshes from an image (used in the community alongside Meshy) (Do you know an AI to create cloth and outfit? - Daz 3D Forums). It’s free to try and can handle characters or clothes. Pros: Free and accessible; known to work for generating a rough clothed figure mesh. Cons: The output might be a combined human+clothes mesh (if the input was a full character image) and will definitely require manual retopology and separation of the clothing. Good for getting the overall shape of a complex outfit, but not a final game-ready mesh.\n“Pic-to-3D Mesh” Blender Add-on: An add-on that integrates AI image-to-3D conversion directly in Blender (Top AI Tools for Model Generation on Blender 3D - Vagon). You can input a reference image (e.g. a front view of a costume) and it generates a detailed 3D mesh inside Blender (Top AI Tools for Model Generation on Blender 3D - Vagon). Pros: Fully inside Blender – no need to use external apps; straightforward UI and quick conversion with just a few clicks (Top AI Tools for Model Generation on Blender 3D - Vagon). This is useful to instantly get a mesh that you can start editing in the same session. Cons: Being relatively new, results can be hit-or-miss on complex armor or multi-layer outfits; likely works best for simpler garments or accessory pieces.\nPixelModeler AI (Blender Add-on): A unique workflow where you paint on a 2D canvas in Blender and an AI generates a corresponding 3D mesh (PixelModeller AI - Blender Market) (PixelModeller AI - Blender Market). This can be used by painting the silhouette or even a depth map of the clothing; the addon will create a solid mesh from it. Generated models are watertight, UV-mapped, and come with vertex colors (a basic texture) (Top AI Tools for Model Generation on Blender 3D - Vagon), ready for further detailing. Pros: Gives a lot of control – you essentially guide the shape by painting, so it’s AI-assisted modeling rather than fully automatic. No external service needed (the AI model runs locally) (PixelModeller AI - Blender Market). Cons: There is a learning curve to painting effective guides. It won’t automatically produce intricate patterns – you’ll need to add those via texture or additional modeling.\n\n\n\nBelow is a quick comparison of these tools relevant to 2D-to-3D clothing conversion:\n\n\n\nTool/Service\nType\nOutput Quality\nTopology & UVs\nIntegration with Blender\nNotes\n\n\n\n\nMeshy AI\nCloud AI (image→3D)\nHigh detail; supports anime style (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Meshy AI - The #1 AI 3D Model Generator for Creators)\nDecent mesh; textured output (may need retopo)\nBlender plugin available (Meshy AI - The #1 AI 3D Model Generator for Creators)\nFast; paid (free trial available).\n\n\nMazing / 3DFY.ai\nCloud AI (image→3D)\nPhotorealistic focus, good folds\nOptimized for real-time (Converting 2D Images into 3D Models with AI: The step-by-step Guide); provides textures\nExports standard formats (OBJ/FBX)\nGreat for realism; stylization may require tweaks.\n\n\nKaedim\nCloud AI (+human)\nCustom models from concept art\nCleaned by artists; quad topology\nDownload to import in Blender\nConsistent results; subscription-based.\n\n\nTripo 3D\nCloud AI (image→3D)\nFast generation, detailed textures ([Kaedim Alternatives in 2025\nBest Kaedim Alternatives - Toolify](https://www.toolify.ai/alternative/kaedim#:~:text=,model%20generation))\nUnknown topology quality\nExports GLB/OBJ\n\n\nThe New Black (Fashion)\nCloud AI (image→3D)\nRealistic garment on avatar\nLikely well-formed cloth mesh\nExport capabilities (likely OBJ/FBX)\nFashion design oriented; may need rigging after import.\n\n\nHunyuan (Tencent)\nCloud AI (image→3D)\nFull character mesh with clothes\nHigh-poly, needs retopo\nOBJ export via HuggingFace demo\nFree; good for concept shape (Do you know an AI to create cloth and outfit? - Daz 3D Forums).\n\n\nPic-to-3D (Blender)\nBlender Add-on\nGood for single-object models (Top AI Tools for Model Generation on Blender 3D - Vagon)\nMesh quality varies; UV depends\nInside Blender (no export needed)\nConvenient, no coding needed.\n\n\nPixelModeler (Blender)\nBlender Add-on\nUser-guided, can achieve high detail\nWatertight & UV-mapped (Top AI Tools for Model Generation on Blender 3D - Vagon)\nInside Blender\nInteractive painting workflow.\n\n\n\nTable: AI-Based 2D→3D Clothing Tools – Comparison (performance as of 2025).",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html#ai-assisted-manual-workflow-strategies",
    "href": "content/posts/Image to 3D-Model.html#ai-assisted-manual-workflow-strategies",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "Fully automated results often need human improvement. In practice, the best quality comes from combining AI generation with manual modeling (Converting 2D Images into 3D Models with AI: The step-by-step Guide). Here are some AI-assisted workflows that clothing artists use:\n\nImage Inpainting + Mesh Generation: One clever approach is to use AI image tools to conceptually dress your character, then extract a model. For example, a community-suggested workflow is: render your character’s base body in T-pose, use an AI image editor (like Stable Diffusion inpainting or Photoshop’s generative fill) to “paint” new clothes onto the image, isolate just the garment in the edited image, then input that into an image-to-3D tool (Meshy or Hunyuan) to get a 3D mesh (Do you know an AI to create cloth and outfit? - Daz 3D Forums). This way, the AI helps create a consistent design on the body and another AI turns it into geometry. You’d still need to retopologize and UV map the result manually (Do you know an AI to create cloth and outfit? - Daz 3D Forums), but it jumpstarts the modeling process for complex costumes.\nDepth Map Extraction: If you have a front-view concept art of the outfit, you can generate a depth map (using AI like MiDaS or Stable Diffusion depth estimation). That depth map can be used to displace a plane or guide a mesh generation. Tools like PixelModeler AI automate this: they generate a depth internally from the image and produce a mesh (PixelModeller AI - Blender Market). The output will capture the relief (folds, protrusions) from the concept art, though you’ll have to model or guess the back side of the garment. This method is useful for armor pieces or relief details on clothing that are visible in the concept.\nTemplate-Based Generation (Parametric): Some solutions use parametric templates plus AI for customization. Sloyd.ai, for instance, combines a library of human-made base models with AI adjustments, ensuring the result is game-ready with UV maps and LODs generated, and optimized meshes (SLOYD AI: A 3D Automation Tool To Generate Game-Ready Assets – startupanz.com). If there are clothing templates (e.g. a generic T-shirt, jacket, dress) you can morph those to roughly match your design and let the tool handle topology. This is semi-manual: you pick the base closest to your design and tweak. Note: As of 2025, parametric generators like Sloyd have many props and environment assets; clothing templates might be limited, but the approach guarantees clean topology if a template fits your needs.\nManual Sculpt with AI Reference: Another assisted route is using the AI output as a reference or base mesh and then manually sculpting over it. For example, you can take a coarse mesh from an AI, bring it into Blender, and use multiresolution sculpting or retopology tools (like Quad Remesher or Blender’s shrinkwrap) to impose a clean topology that follows the AI model’s shape. The AI model essentially serves as a 3D concept sketch. You can also project the texture from the AI model (if it provided one) onto your new topology for a starting point.",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html#manual-tools-for-3d-clothing-creation",
    "href": "content/posts/Image to 3D-Model.html#manual-tools-for-3d-clothing-creation",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "While AI is speeding things up, manual modeling tools are still crucial, especially for achieving the cleanest results and stylized looks:\n\nMarvelous Designer / CLO3D: These are industry-standard tools for designing clothing using pattern-based simulation. You draw 2D garment patterns, sew them, and the software simulates the cloth on a avatar model – perfect for creating natural folds and drapes. Pros: Extremely high fidelity cloth behavior; great for layered outfits, pleats, ruffles, etc. You can match an anime costume by designing similar patterns. Marvelous can even auto-generate PBR texture maps like normal and opacity for details ([Tips&Tricks] Discover Better Workflow with Marvelous Designer and Unreal Engine – Marvelous Designer). Cons: The meshes are triangulated and high-poly (since it’s focused on simulation). You will need to retopologize the garment for use in a game or realtime engine (Retopology of Marvelous Designer Clothes in Blender - YouTube). Marvelous has introduced some retopo tools (EveryWear Auto-Retopology) and can even rig garments, but often external retopo (using Blender or ZBrush) gives more control. Despite not being AI, Marvelous is frequently recommended for creating custom outfits (Do you know an AI to create cloth and outfit? - Daz 3D Forums) because of the quality of the result. The typical workflow is simulate in Marvelous → export OBJ → retopo in Blender → transfer to character rig.\n\n([Tips&Tricks] Discover Better Workflow with Marvelous Designer and Unreal Engine – Marvelous Designer) Example of a stylized 3D outfit created with cloth simulation. (This fairy-like garment was designed and simulated in Marvelous Designer, showcasing layered fabric, ruffles, and realistic folds.)\n\nBlender’s Sewing/Cloth Tools: If you prefer open-source, Blender itself has cloth simulation and addons like Garment Tool that mimic Marvelous’s pattern sewing approach. You can import your character into Blender, model garment panels (or even trace them from reference images), then use cloth physics to drape them. The result can then be applied as a shape key or applied mesh. You’ll still need to manually refine the mesh topology. Blender’s sculpting tools (cloth brush, slide relax, etc.) can also help adjust folds. This approach is manual and requires skill, but no additional cost.\nDirect Poly Modeling: For hard-surface armor pieces or very structured outfits (like a mech suit or a rigid breastplate), classic poly modeling or box modeling in Blender might be the way to go. You can use the 2D image as a reference in the background and model the clothing piece by piece (ensuring proper topology as you go). This is time-consuming but yields the cleanest meshes. You might use AI just to generate normals or texture details in this case, rather than the mesh.\nRetopology & Refinement Tools: No matter which initial method you choose, retopology tools are vital for clothing. Blender has a PolyBuild and Snap-to-face retopo workflow, and add-ons like RetopoFlow can speed it up. If you have ZBrush, ZRemesher can quickly re-mesh a triangulated Marvelous output into quads, which you can then tweak. There are also auto-retopology AI in development – for instance, some research tools attempt to auto-retopo meshes with neural networks, but in practice most artists still do this part manually or with traditional algorithms. The goal is to end up with edge loops around openings (neck, arm holes) and ideally follow the flow of fabric folds with the topology for deformation.",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html#recommended-workflow-step-by-step",
    "href": "content/posts/Image to 3D-Model.html#recommended-workflow-step-by-step",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "Bringing it all together, here is a step-by-step workflow to convert a 2D outfit into a 3D mesh and attach it to your Blender character, using the best of AI and manual tools:\n1. Gather Reference Images: Ideally have the concept art or reference of the clothing from as many angles as possible. A front view is usually required for AI tools; a side or back view (if available) will help during modeling or can be fed into some tools for better accuracy. If only a front view exists, be prepared to interpret the design for the unseen parts.\n2. Choose an AI Generation Method for Base Mesh: For a head start, pick one of the AI approaches:\n\nOption A: Use Meshy AI (or similar service) to upload the clothing image and generate a 3D model. Download the result (e.g. as a .glb or .obj) when ready (Meshy AI - The #1 AI 3D Model Generator for Creators).\nOption B: In Blender, install the Pic-to-3D Mesh addon and run it on your reference image to get a mesh (Top AI Tools for Model Generation on Blender 3D - Vagon).\nOption C: If the outfit is very complex or you want a full mannequin with clothing, try the Hunyuan 3D demo by providing an image of the clothed character; then extract the clothing mesh from the output.\nOption D: If you have a concept sketch, consider Kaedim/Tripo services for a perhaps cleaner base model (they might return the model next day or in a couple of hours, which you can then use).\nRegardless of option, don’t expect a perfect final model – treat this as a rough draft or proof of concept in 3D. It should capture the overall shape and major details of the clothing.\n\n3. Import and Inspect in Blender: Bring the generated 3D model into Blender. Center and scale it to your character. At this stage:\n\nCheck the mesh density and topology. Are there a lot of uneven triangles or random bumps?\nCheck if all parts of the outfit are present. Sometimes single-view reconstructions leave holes or undefined backs. You may need to patch holes (Blender’s Fill or Grid Fill can help) or even mirror parts of the mesh if symmetry can be assumed.\nIf the tool provided textures, apply them to see the look. However, for anime style, you might later hand-paint textures or use simple materials, so textures are optional.\n\n4. Retopologize the Clothing Mesh: This is crucial for optimization. You can use Blender’s retopology tools to create a new mesh over the AI mesh:\n\nAdd a shrinkwrap modifier on a new mesh and model low-poly geometry that tightly wraps the AI model. Focus on quads and logical edge flow (e.g. edge loops around cuffs, hemlines, and along seams).\nAlternatively, use an auto-retopo tool: for example, Instant Meshes (free tool) or Quad Remesher (paid) to get a quick quad mesh. You might still tweak the output by hand.\nEnsure the retopo’d mesh has proper thickness where needed (you can solidify later if it’s cloth, but parts like armor might be modeled as solid pieces).\nUV unwrap the new mesh if not already UV’d. Good UVs are needed for texturing anime-style details (like emblems or gradients on the fabric).\n\n5. Fit and Attach to the Character: Place the new clothing mesh on the character in the correct pose (usually T-pose or A-pose matching the rig). To attach:\n\nUse Blender’s Transfer Weights: parent the clothing to the armature (with empty groups), then select the body, then clothing, and use Weight Transfer (source: body, destination: clothing). This copies the rig weights so the clothing will move with the body (How separte clothes for Animatoion? - CG Cookie).\nCheck deformation by posing the character. Likely you will need to clean up weights (for instance, ensure sleeves move with the arms, etc. without too much clipping).\nIf the clothing is very close to the body, you might need to delete hidden faces of the character under the clothes to avoid mesh clipping in tight areas (e.g. remove torso polygons under a shirt).\nFor rigid pieces (like armor plates), you may instead want to assign them to a specific bone and keep them rigid or use a bone parent for that object.\n\n6. Detail and Texture: Now polish the visual fidelity:\n\nSculpt or model finer folds that the AI may have missed. You can use Blender’s sculpt mode with the cloth brush or crease brush to imprint additional wrinkle lines where appropriate.\nAdd thickness to cloth if it’s just a single surface (Solidify modifier). Stylized outfits often have a bit of thickness at edges (e.g. a coat lapel).\nTexture Painting: For anime style, a lot of detail can come from textures (like painted shadows or highlights, stylized fabric patterns). You can paint directly in Blender or use Substance 3D Painter. If the original 2D image has patterns (say, a symbol on the back of a cape), use it as a reference or even project it onto your UV map.\nGenerate normal maps if needed. For example, if the outfit has an engraved design or stitching that is too fine to model, you can paint a height map and bake it to a normal map. Some AI tools can assist in generating texture maps from descriptions (e.g. Meshy has an AI texturing feature) (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify), which could be used to create stylized fabric textures by prompting.\n\n7. Iterate and Refine: After these steps, you should have the clothing on the character, but iteration is key:\n\nGo back and forward between sculpting, adjusting topology, and tweaking weights until the clothing looks right and deforms well in various poses.\nIf something is off compared to the concept art (maybe the AI misunderstood a part of the design), you might have to model that part manually. It’s common to model small accessories or intricate pieces separately (for example, a belt buckle or a brooch) and then attach them.\nLOD (Level of Detail): If this is for a game, consider making lower-poly versions or at least ensure the topology is efficient. AI meshes can be decimated or re-generated at lower detail if needed.\n\n8. Final Check and Export: Once satisfied, you can integrate the clothed character into your project. Because we focused on Blender compatibility, you can continue to animate or render in Blender. If exporting to a game engine, export the character with the outfit as FBX/GLTF with the armature. Double-check that all parts are properly bound and that textures are packed or exported.\nThroughout this process, remember that AI is a helper, not a replacement for your skill. Even the best AI-generated model benefits from a human artist’s eye for clean topology and style accuracy. As one guide noted, AI tools speed up getting a base, but “as AI is not perfect, [enhancement] is recommended” to reach production quality (Converting 2D Images into 3D Models with AI: The step-by-step Guide). Don’t hesitate to do manual touch-ups – the goal is a high-quality anime-style outfit that looks like it was hand-crafted for the character.",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Image to 3D-Model.html#conclusion",
    "href": "content/posts/Image to 3D-Model.html#conclusion",
    "title": "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow",
    "section": "",
    "text": "Converting 2D anime-style clothing into 3D is becoming more accessible thanks to AI innovations. Tools like Meshy, PicTo3D, and others can generate a quick 3D draft of an outfit from a single concept image (Top AI Tools for Model Generation on Blender 3D - Vagon) (Converting 2D Images into 3D Models with AI: The step-by-step Guide), saving hours of initial modeling. However, the best results come from a hybrid workflow: leveraging AI for speed and then applying traditional modeling techniques for accuracy and clean topology. This collaborative approach (AI plus human) is highlighted as the future of 3D content creation (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide) – AI handles the heavy lifting of shape prediction, while the artist refines and stylizes the final asset.\nBy carefully choosing the right tools and following a structured workflow, you can efficiently bring 2D costume designs into the 3D world, ready to be worn by your Blender character. The combination of AI-assisted generation and manual refinement ensures you get both speed and quality – detailed Genshin Impact-style clothing that not only looks great but is also rigged and optimized for your creative projects.\n\n\n\nMazingXR Blog – “Converting 2D Images to 3D Models with AI” (Feb 2025) (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide) (Converting 2D Images into 3D Models with AI: The step-by-step Guide)\nVagon Blog – “Top AI Tools for Model Generation on Blender 3D” (Top AI Tools for Model Generation on Blender 3D - Vagon) (Top AI Tools for Model Generation on Blender 3D - Vagon)\nDaz3D Forums – “Do you know an AI to create cloth and outfit?” (Jan 2025) (Do you know an AI to create cloth and outfit? - Daz 3D Forums) (Do you know an AI to create cloth and outfit? - Daz 3D Forums)\nStartupAnz – “Sloyd AI: Game-Ready 3D Asset Generation” (SLOYD AI: A 3D Automation Tool To Generate Game-Ready Assets – startupanz.com)\nAlpha3D.io – “2D image to 3D model generation (limitations)” (Transform text and 2D images into 3D assets with generative AI for free - Alpha3D)\nToolify AI – “Kaedim Alternatives in 2025” (Kaedim Alternatives in 2025 | Best Kaedim Alternatives - Toolify) (Tripo3D features)\nMarvelous Designer Official Support – Workflow tips (pleat and texture generation)",
    "crumbs": [
      "Notes",
      "Converting 2D Anime-Style Clothing to 3D: Tools & Workflow"
    ]
  },
  {
    "objectID": "content/posts/Short Cut for GIST.html",
    "href": "content/posts/Short Cut for GIST.html",
    "title": "Erise Note",
    "section": "",
    "text": "Enter\nssh astrogroup@170.140.162.12\nPassword:\nNGC6814\n\nRunning\ngistPipeline --config configFiles/MasterConfig --default-dir configFiles/defaultDir\n\n\nUpload directly from PowerShell\nscp \"C:\\\\Users\\\\19175\\\\Desktop\\\\TNG Research\\\\GIST\\\\gistTutorial.tar.gz\" astrogroup@170.140.162.12:~/Erise/\nscp “D:Files_MUSE.py” astrogroup@170.140.162.12:~/miniconda3/envs/gist/lib/python3.6/site-packages/gistPipeline/readData\nscp “D:Files_LR.py” astrogroup@170.140.162.12:~/miniconda3/envs/gist/lib/python3.6/site-packages/gistPipeline/readData\nThe Directory for Read-File\n~/miniconda3/envs/gist/lib/python3.6/site-packages/gistPipeline/readData\nCD command\n\nGo to gistTutorial\n\ncd ~/Erise/gistTutorial\nOpen LogFile\nnano ~/Erise/gistTutorial/results/Test/LOGFILE\nOpen masterConfig\nnano ~/Erise/gistTutorial/configFiles/MasterConfig\nExtract at your folder in Linux server:\ntar -xzvf gistTutorial.tar.gz\n~/miniconda3/envs/gist/lib/python3.6/site-packages/vorbin/voronoi_2d_binning.py\nunzip the gz file:\ngzip -d -k TNG50-reds-0.035-angle-010-FOV-61-re_kpc-10-snap-98-460756.cube.fits.gz\nFinding\nfind ~/Erise/gistTutorial -name _______\nRemove File\nrm\nRemove Dir\nrmdir\nC:\\19175Research-reds-0.06-angle-010-FOV-61-re_kpc-15-snap-98-460756.cube.fits.gz\nscp “C:\\19175Research-reds-0.06-angle-010-FOV-61-re_kpc-15-snap-98-460756.cube.fits.gz” astrogroup@170.140.162.12:~/Erise/gistTutorial/inputData\nC:\\19175Research-reds-0.06-angle-010-FOV-61-re_kpc-15-snap-98-460756.cube.fits.gz\n\nUpload SAURON_LR\ngistpipline\nNGC0000Example\nQuestion",
    "crumbs": [
      "Notes",
      "**Running**"
    ]
  },
  {
    "objectID": "content/posts/index.html",
    "href": "content/posts/index.html",
    "title": "文章 Posts",
    "section": "",
    "text": "一些记录随想和博客文章。\n\n\n\n\n\n\n   \n    \n    \n      排序方式\n      默认\n      \n        日期 - 日期升序\n      \n      \n        日期 - 日期降序\n      \n      \n        标题\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n标题\n\n\n\n日期\n\n\n\n\n\n\n\n\nSummer Application:\n\n\n \n\n\n\n\n\n\nConverting 2D Anime-Style Clothing to 3D: Tools & Workflow\n\n\n \n\n\n\n\n\n\nClose Reading Commentary\n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n\n\n\n\nCan you imagine sexuality without gender?\n\n\n \n\n\n\n\n\n\n随笔\n\n\n \n\n\n\n\n\n\n家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践\n\n\n \n\n\n\n\n\n\n \n\n\n \n\n\n\n\n\n\nRunning\n\n\n2025年3月17日\n\n\n\n\n\n\n1. Install R and Babeldown\n\n\n2025年3月16日\n\n\n\n\n\n\nCreating a New Theme\n\n\n2014年9月28日\n\n\n\n\n\n\nMigrate to Hugo from Jekyll\n\n\n2014年3月10日\n\n\n\n\n\n\n无匹配项",
    "crumbs": [
      "Notes",
      "文章 Posts"
    ]
  },
  {
    "objectID": "content/posts/随笔/Commentary on Foucault's The Order of Things.html",
    "href": "content/posts/随笔/Commentary on Foucault's The Order of Things.html",
    "title": "Close Reading Commentary",
    "section": "",
    "text": "Close Reading Commentary\nThe selected quote is from Foucault’s early-stage (1960s) intellectual project of philosophical “archaeology”, which was his first major methodological phase. He presents a radical historical analysis of knowledge in The Order of Things, intending to eliminate the assumption of unchanging criteria for knowledge.\nThis quote sits at the center of his archaeological method, in which he attempted “to bring to light” the underlying episteme of knowledge. This recursive long sentence, broken down into three main modifiers, describes the epistemological field, which almost, if not intentionally, resembles the idea of a “field” in physics - an invisible but structured influence that determines how objects behave within it. The traditional epistemological assumption that he challenged holds that knowledge is grounded by universal standards of rationality and objectivity, and the first modifier sets the stage for this argument. Foucault subverts this unchanging framework by treating it as historically contingent, or specifically, one of the possible conditions “having reference” to rationality and objectivity.\nThe second modifier, “grounds its positivity and thereby manifests a history,” presents one of his most radical takes on epistemology. The positivity of knowledge is constructed within the space established by the historical a priori, is thus validated by what is possible to be discovered as “knowledge.” For Foucault, the corresponding relationship between how well knowledge describes reality and knowledge itself is radically destabilized, because there is no objective guarantee of such a relationship, given that epistemes structure our perception and thus make reality itself historically conditioned.\nThe third modifier further develops this idea and explicitly rejects the notion of a progression of knowledge towards “growing perfection.” It is surprising for me to interpret that not only is progression non-linear and discontinuous, but progression itself simply cannot exist, precisely because epistemic ruptures shift the framework of what counts as knowledge and make previous ways of thinking unthinkable. (It reminds me of Thomas Kuhn’s view on science, but the preservation of continuity is completely abandoned.) Since the episteme structures the conditions under which the history of knowledge unfolds, it determines the framework within which historical institutions and discourses “ground” knowledge as legitimate.\nThis directly supports his examination of discourses on madness, crime, and sexuality, and how the changing episteme of madness throughout history, for example, redefines its implications - whether through the logic of confinement or its later medicalization under psychiatric authority. My close reading of this passage really forced me to zoom out from the sciences I have been studying and reflect on the historical illusion of epistemic progress.",
    "crumbs": [
      "Notes",
      "随笔",
      "Close Reading Commentary"
    ]
  },
  {
    "objectID": "content/posts/随笔/Create Graph Using LaTex Code.html",
    "href": "content/posts/随笔/Create Graph Using LaTex Code.html",
    "title": "Erise Note",
    "section": "",
    "text": "\\usetikzlibrary{arrows.meta, positioning}\n\n\\tikzset{\n  ladder/.style = {draw, rounded corners, align=left, minimum width=9.8cm, inner sep=6pt},\n  arrow/.style  = {-{Latex[length=3mm]}, thick}\n}\n\n\\begin{document}\n\\begin{tikzpicture}[node distance=8mm]\n  \\small\n\n  % Nodes (top to bottom)\n  \\node[ladder, fill=gray!10] (T5)  {\\bfseries $T_5$ \\; Completely normal Hausdorff（完全正规豪斯多夫）\\\\\n    Disjoint closed sets separated by $f:X\\to[0,1]$.};\n  \\node[ladder, below=of T5]  (T4)  {\\bfseries $T_4$ \\; Normal Hausdorff（正规豪斯多夫）\\\\\n    Disjoint closed sets contained in disjoint open sets.};\n  \\node[ladder, below=of T4]  (T35) {\\bfseries $T_{3.5}$ \\; Tychonoff（完全正规豪斯多夫）\\\\\n    For $x\\notin A$ (closed) $\\exists f:X\\to[0,1]$ with $f(x)=0,\\ f(A)=\\{1\\}$.};\n  \\node[ladder, below=of T35] (T3)  {\\bfseries $T_3$ \\; Regular Hausdorff（正规豪斯多夫）\\\\\n    For $x\\notin A$ (closed) $\\exists$ disjoint open $U,V$ with $x\\in U,\\ A\\subset V$.};\n  \\node[ladder, below=of T3]  (T25) {\\bfseries $T_{2.5}$ \\; Urysohn（乌里松）\\\\\n    Distinct points have disjoint closed neighborhoods.};\n  \\node[ladder, below=of T25] (T2)  {\\bfseries $T_2$ \\; Hausdorff（豪斯多夫）\\\\\n    Distinct points lie in disjoint open sets.};\n  \\node[ladder, below=of T2]  (T1)  {\\bfseries $T_1$ \\; Fréchet（Fréchet）\\\\\n    All singletons are closed.};\n  \\node[ladder, below=of T1]  (T0)  {\\bfseries $T_0$ \\; Kolmogorov（Kolmogorov）\\\\\n    For $x\\neq y$, some open set contains one but not the other.};\n\n  % Arrows\n  \\draw[arrow] (T5)  -- (T4);\n  \\draw[arrow] (T4)  -- (T35);\n  \\draw[arrow] (T35) -- (T3);\n  \\draw[arrow] (T3)  -- (T25);\n  \\draw[arrow] (T25) -- (T2);\n  \\draw[arrow] (T2)  -- (T1);\n  \\draw[arrow] (T1)  -- (T0);\n\n  % Caption\n  \\node[below=6mm of T0, align=center] {\\footnotesize Implications downward; reverse implications generally fail.};\n\\end{tikzpicture}\n\\end{document}\n\n\\usepackage{pgfplots}\n\\pgfplotsset{compat=1.16}\n\n\\begin{document}\n\n\\begin{tikzpicture}\n\\begin{axis}[colormap/viridis]\n\\addplot3[\n    surf,\n    samples=18,\n    domain=-3:3\n]\n{exp(-x^2-y^2)*x};\n\\end{axis}\n\\end{tikzpicture}\n\n\\end{document}\n\\usepackage{tikz-cd}\n\n\\begin{document}\n\\begin{tikzcd}\n\n    T\n    \\arrow[drr, bend left, \"x\"]\n    \\arrow[ddr, bend right, \"y\"]\n    \\arrow[dr, dotted, \"{(x,y)}\" description] & & \\\\\n    K & X \\times_Z Y \\arrow[r, \"p\"] \\arrow[d, \"q\"]\n    & X \\arrow[d, \"f\"] \\\\\n    & Y \\arrow[r, \"g\"]\n    & Z\n\n\\end{tikzcd}\n\n\\quad \\quad\n\n\\begin{tikzcd}[row sep=2.5em]\n\nA' \\arrow[rr,\"f'\"] \\arrow[dr,swap,\"a\"] \\arrow[dd,swap,\"g'\"] &&\n  B' \\arrow[dd,swap,\"h'\" near start] \\arrow[dr,\"b\"] \\\\\n& A \\arrow[rr,crossing over,\"f\" near start] &&\n  B \\arrow[dd,\"h\"] \\\\\nC' \\arrow[rr,\"k'\" near end] \\arrow[dr,swap,\"c\"] && D' \\arrow[dr,swap,\"d\"] \\\\\n& C \\arrow[rr,\"k\"] \\arrow[uu,&lt;-,crossing over,\"g\" near end]&& D\n\n\\end{tikzcd}\n\n\\end{document}\n\\usepackage{chemfig}\n\\begin{document}\n\n\\chemfig{[:-90]HN(-[::-45](-[::-45]R)=[::+45]O)&gt;[::+45]*4(-(=O)-N*5(-(&lt;:(=[::-60]O)-[::+60]OH)-(&lt;[::+0])(&lt;:[::-108])-S&gt;)--)}\n\n\\end{document}\n\\usepackage{chemfig}\n\\begin{document}\n\n\\definesubmol\\fragment1{\n\n    (-[:#1,0.85,,,draw=none]\n    -[::126]-[::-54](=_#(2pt,2pt)[::180])\n    -[::-70](-[::-56.2,1.07]=^#(2pt,2pt)[::180,1.07])\n    -[::110,0.6](-[::-148,0.60](=^[::180,0.35])-[::-18,1.1])\n    -[::50,1.1](-[::18,0.60]=_[::180,0.35])\n    -[::50,0.6]\n    -[::110])\n    }\n\n\\chemfig{\n!\\fragment{18}\n!\\fragment{90}\n!\\fragment{162}\n!\\fragment{234}\n!\\fragment{306}\n}\n\n\\end{document}",
    "crumbs": [
      "Notes",
      "随笔",
      "Create Graph Using LaTex Code"
    ]
  },
  {
    "objectID": "content/posts/随笔/Sex & Sexuality.html",
    "href": "content/posts/随笔/Sex & Sexuality.html",
    "title": "Erise Note",
    "section": "",
    "text": "Can you imagine sexuality without gender?\nFor Foucault\nSexual identity i s produced within the grid of sexuality - from normal to abnormal - changes over time\nModern subject is a sexual subject (gendered being)\nWhat does freedom look like in this? When there is no outside, what does it mean to have transgression?\npower-knowledge-pleasure - greatest pleasure is the pleasure of the analysis\n\np.154\n(It is apparent that the deployment of sexuality, with its differ­ ent strategies, was what established this notion of “sex”; and in the four major forms of hysteria, onanism, fetishism, and interrupted coition, it showed this sex to be governed by the interplay of whole and part, principle and lack, absence and presence, excess and deficiency, by the function of instinct, finality, and meaning, of reality and pleasure.)\nSexuality is not a drive, but a grid. That creates a speculative relationship\np.156\n(Hence the fact that over the centuries it has become more important than our soul, more important al­ most than our life; and so it is that all the world’s enigmas appear frivolous to us compared to this secret, minuscule in each of us, but of a density that makes it more serious than any other.)\np.156\n(we have arrived at the point where we expect our intelligibility to come from what was for many centuries thought of as madness; the plenitude of our body from what was long considered its stigma and likened to a wound)\n\nHOS Vol.1: p.144\nSovereign Power “law” law always referes to the sword - always taking lifes\nRegulatory (bio-power) - the rule fucntions as “norms” - the displayment - it looks like it is more humane, but it may not be so: - it becomes continuous, corrective - distribution of the living - continious apparatucy\nfoucault is like boxer, punching at whenever, and whatever is needed\nReistance? for Sovereign Power: revolution for Regulatory Power: breaking the continuity, some sort of rupture of such continuity.\nas long as we are trapped in illusion of choice, and agency, there is no way of resistance! Free thoughts of what is silencely thought, and hence free outself.\nFoucault: rejects S-O\nThe relation to others, and relation to the time: freedom is the practice of the self in relation to others.\nThoughts if a form of action, is the result of problemitization.\nWhy is sexuality conduct an object of moral solicitude? - we governed ourselves through sexuality - there is a sexual hierarchy (e.g. there is good sexuality and bad sexuality) -",
    "crumbs": [
      "Notes",
      "随笔",
      "Can you imagine sexuality without gender?"
    ]
  },
  {
    "objectID": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html",
    "href": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html",
    "title": "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践",
    "section": "",
    "text": "在《性史》第一卷中，米歇尔·福柯（Michel Foucault）提出现代权力沿两条轴线运行。纪律权力（disciplinary power）通过各种机构训练、监督和矫正个体的身体；而规训权力（regulatory power），即所谓的“人口生命政治”（biopolitics of the population），则兴起于18世纪的欧洲，当时国家开始通过统计与医疗体制（statistical-medical regimes）来优化和管理生命本身。后一种权力，即生命权力（biopower），并非仅仅是对古典主权权力（sovereign power）的技术性附加，而是一种在大规模层面上规训、监控和治理人类生命的新型权力模式。作为许多女性主义论述的基础文本，《性史》暗示了一种前现代道德秩序与现代国家主导的生命政治之间的断裂式转型。这种连续性的断裂，常被福柯表述为一种“前/后”（before/after）的叙事，显然源于国家迫切需要从“处死的权力”（the right to kill）转向“滋养生命的权力”（the power to foster life），这一转型自18世纪以来资本主义的发展所必然推动。然而，这种决定性转型并非源自现代权力本身的本质，而是特定的欧洲历史语境以及福柯有意排除了非欧洲地区的案例所导致的。\n在东亚地区，国家权力很少孤立地作用于“赤裸的”个体（bare individuals）或抽象的人口，这与欧洲情形显著不同；它一直通过已有的关系层级——家庭义务、孝道（filial piety）和宗族荣誉——运作，这些关系皆深植于长达数千年的儒家传统中。这些关系性的纪律维持了一种家庭-国家连续体（family-state continuum），指向一种集体自我（collective self），而福柯强调个体自我治理（individual self-governance）时往往忽视了这一点。我认为，西方式生命权力的引入——如人口普查、公共卫生委员会、人口控制政策等——并未取代东亚的传统规范，而是被吸纳进儒家-家庭等级制度中，形成了一种混合模式，即所谓的 “家庭式生命权力”（familial biopower）。这种模式以家庭/户为主要渠道，实现国家的生命政治治理。因此，与欧洲语境中经常假定的剧烈转型不同，东亚家庭式生命权力的引入表现出了更为明显的连续性。\n\n\n福柯在追溯西方权力如何渗透进身体内部并扩展到整个人口的著名分析中，指出18世纪出现了“一场多样且丰富的技术爆发，这些技术用于征服身体并控制人口”（Foucault 140）。这些权力技术并非边缘化，而是渗透进每一个社会制度中，包括家庭、军队、学校、个性化医疗以及集体机构管理。这些规训性操作（regulatory operations）以循环的方式运行，一定程度上构成了一种更宏大的“属于人类生命特有现象的介入”，从而彻底转变了西方人对自身的理解，即将自己视为“一个活在活的世界中的活物种……具有一个身体、生存条件、生命的可能性……”等。在福柯的理论框架中，一个社会之所以跨过现代性的门槛（threshold of modernity），是因为人类的生存本身成为政治计算的对象；也就是说，治理机构公开地将人口健康作为政策目标时，社会便成为了一个现代社会（Foucault 143）。\n然而，这一门槛在全球范围内呈现出明显的时间与形态差异。福柯对此保持了极大的谨慎，避免过度概括，因为作为一名历史学家，他清楚地意识到，他所描述的战胜饥荒和瘟疫、控制死亡的“胜利”历程并非普遍现象，而是特定于18和19世纪欧洲及其衍生地区的现象，这些地区的国家机构、医学科学和农业技术共同发展成熟。福柯理论在西欧轨迹上的特定应用，也因此留下了一个开放问题：例如在中国或日本存在哪些生命管理（life-management）形式，以及殖民力量又如何将它们的生命政治叠加到这些地方。因此，关键的问题并非生命权力是否具有普遍适用性，而是欧洲模式的生命权力如何整合进非西方社会，以及这种转型后的生命政治在多大程度上保留了其在欧洲的”断裂式特征”。\n回溯东亚历史，我们会发现，长期延续的儒家传统、家庭与宗族观念不仅在当今全球化的个人主义浪潮下幸存下来，而且形成了一种非常特殊的社会结构：一种儒家-家庭装置（Confucian-familial apparatus），它将国家治理与亲属义务紧密融合，并成为生命权力的通道。福柯的分析预设了一定程度的个体化（individualization）：公民、工人、病人……他们内化各种规范。福柯所谓“稍晚出现”的西方生命权力构型，是与古典欧洲政治理论（例如洛克或卢梭）预设的个体主义相融合的产物。福柯的分析反映了这种遗产：在大规模治理层面上，集体规训围绕着解剖政治（anatomo-politics）与生命政治（biopolitics）交汇的轴线形成，整体的人口与个体之间成为基本的分析单位。福柯着重分析诸如监狱、学校、精神病院等机构，因为它们生动地展现了现代权力的运作机制，但相较之下，他较少关注家庭作为现代权力中心的角色或直接作为国家生命政治装置（state biopolitics apparatus）的功能。他更多地将家庭视为“性最活跃的场所”（Foucault, 109），在他的论述中，家庭功能似乎只是资产阶级性欲部署的一个载体（可能是最重要的载体），但并未将家庭充分地视为一种国家权力的制度化机构来完整阐释。\n儒家哲学中，家庭是社会基本的构成单元，更被视作美德的训练场所。尽管福柯提出的分类框架大体上有效，但如果通过系谱学（genealogical）方式重新解读东亚的孝道和宗族体系，我们会发现家庭远非仅仅是性欲与纪律规范的载体，而是具有更加核心的功能性地位——同时也更加显著地政治化了。重新审视福柯在家庭作为国家机器（family-as-state-machine）方面的相对沉默是必要的，而这种必要性，直接可以从广泛流传的中文谚语“家是小国，国是大家”逐字逐句地体现出来。\n这种家国同构（family-state isomorphism）源自早期儒家经典文本，其中尤以《礼记·大学》中“修身齐家治国平天下”的论述最为著名，这一经典最早可追溯到公元前206年，并提出了一套有关自我修养的等级体系。这种观点并非仅限于道德劝诫，而是早自周代以来便已制度化。正如一位历史学家所指出，清代法律明确实施了“父母对子女所享有的关系权力（relational power），这一关系随后被类比为官员以及皇帝对平民的权威”（Blackwood）。换言之，国家利用家庭结构，尤其是父权制家庭（patriarchal family）的结构，来强化其自身结构。家庭-国家之间的连续性在东亚历史中一直显而易见：皇帝名义上被视为国家的“父亲”，个人对自己父亲的孝道服从被期待转化为对国家的忠诚。这种原始的纪律性与政治化的家庭共识普遍汇聚在东亚地区，长期以来便模糊了私人家庭生活与公共治理之间的界限，并远早于所谓的现代性门槛。在这种背景下，君主与臣民的关系直接映射了父与子的关系（即“君君臣臣父父子子”）。因此家庭户主负责登记出生与死亡，监督礼仪，发放慈善，以及裁决争端，其职能恰如地方县级官员（magistrate）。由此可见，家庭处于孤立的个体与国家机器之间，成为纪律规训与生命政治管理的基本单位。每个家庭同时既是国家的微观缩影，又是治理的单元，这一观念正是提示了另一种不同的生命政治治理需求——即通过亲属关系（kinship）来实现。\n因此，在讨论东亚生命权力兴起的问题时，我们必须系统地将家庭理论化为一种关键的配置（dispositif），将解剖政治（anatomo-politics）与生命政治（biopolitics）联结起来。这一特定的权力网络要求我们在现代语境下提出 “家庭式生命权力”（familial biopower） 的概念，其中生命政治技术首先由国家辐射到家庭单位，然后才进一步下沉至个体。在这种 “个体-家庭-人口”（individual-family-population） 的三元结构中，亲属义务与宗族礼仪调节着所有现代治理措施，包括出生登记到公共卫生宣传运动，使得家庭本身成为一种生命权力的微型官僚机制。因此，在东亚，家庭远非私人庇护所，而是国家权力对生命的延伸场域，其“私人”与“公共”领域之间的界限几乎已无法区分，这正是福柯理论框架所会预测的融合形式。\n\n\n\n福柯试图揭示的决定性转型，实质上是权力在逻辑与目标上双重变化的过程；然而，这种向“使其生、任其死”（making live and letting die）方向的转变，本身更多是一种强调重点与治理尺度的问题。“门槛”的连续性，并不在于权力是否瞄准生命，而在于它如何、以及在何处对生命施加控制。因此，强调东亚以家庭为核心的行政模式，并非意在夸大其独特性，以及是否存在家庭制度——因为西欧早期现代的生命政治措施，同样也扎根于原有的家庭和社区结构之中（如法国 livrets de famille、瑞典教区登记）——而是在于国家与个体之间是否发生了中介结构的剥离与重构。\n在东亚，公共与私人领域从未像欧洲那样被严格区分，因此外来生命权力对两者界限的模糊，并未对现有的家国同构（family–state isomorphism）造成根本性冲击。或者，更精准的说，“生命权力”在东亚是更容易嵌入原有秩序结构中，因此无需强行重构私域公化的渗透机制。在欧洲，随着统计学、现代警察制度和卫生法律的兴起，一套密集的微观治理网络逐步渗透进私人领域——在福柯看来，“权力无处不在”（there is no outside to power）。这一现象在东亚也有发生，但东亚的儒家-家庭格局本身就具有强调角色本位的“修身”的系谱根基，这是国家支持的项目。在这种语境下，个体若试图划出一个脱离社会角色的“私人内部”，是不被鼓励的。因为自由主义意义上的“自主人格”——即“选择你是谁”——并非理想状态；相反，社会强调的是与政治秩序和宇宙秩序之间的“和谐”。\n这些前现代中国的规范性叙事，使我们得以理解，“欧洲式”生命权力的导入在东亚看起来远不如福柯所描述的法国或英国那样构成一个清晰的“前后转折”。这一进程更像是将新的统计—医学技术嫁接（grafting）到既有的家庭治理结构之上，是一种有意识的增强（augmentation），而非强行替代。例如，西方式生命权力在中国的引入可以追溯到1901年，当时在外来影响下，清朝新政（New Policies）于北京设立中央卫生机构，统一监管全国各省的“健康、检疫与医疗实践”。这是中国历史上首次将人口健康作为独立的政策目标加以系统性测量、汇报与管理，标志着“西式卫生现代化的开端”（Cao 105）。在此生命权力改革的“门槛”上，国家政策是通过保甲制度（baojia）这一延续了数百年的社区治理网络来实施的。接着，这一框架又在1911年《户籍法》中正式确立了现代户口制度（hukou）的法律形态，其遗产一直延续至今。事实上，自周朝以来，中国各朝代已经实施多种形式的原始户籍制度，以管理“生命”，其连续性和稳定性远超欧洲——后者并未持续建立由国家运行的户籍制度。因此，清朝“新”卫生机构所采用的，并非是建立一个完全独立的国家机器，而是将新兴的统计—医疗技术叠加于已有的宗族与村社网络之中。家庭在治理结构中仍然作为核心节点，这种连续性揭示了一条不同的生命管理系谱，即以家庭为中心的更长远、持久的生命政治路径。\n同样，日本政府在1871年推行了“户籍”制度（koseki），有意识地将儒家家庭主义融入明治时期的家国意识形态中。该政策与中国的户口制度类似，要求“每户必须报告出生、死亡、婚姻与收养情况”（《户籍法》）。当明治维新时期引入西方公共卫生政策——尤其是1872年《传染病预防法》——时，所有疫苗接种、隔离命令与卫生检查均通过地方家庭登记与村庄首领来执行。在其核心， 是“家”（ie）的概念：一个用于法律、经济与精神目的的扩展家庭单位。这不仅仅是一个隐喻，还被1898年《明治民法典》正式确认为社会的基本单位。在这一制度中，女性被明确规定在“良妻贤母”的口号下承担支持性、再生产角色；而家长则被动员为国家行使婚姻、继承与家庭纪律等方面的生命权力代理人。日本著名女性主义者上野千鹤子（Chizuko Ueno）深受福柯权力理论的启发，她指出：“’家’制度被设计成符合现代民族国家的模型，而民族国家本身正是仿照家庭结构构建的”（Ueno 57）。在这种家国同构观念中，明治国家与中国清末类似，也将西方生命政治技术嫁接到既有的家庭格局上，使每一个家庭（ie）成为治理与人口管理的基本单元。\n值得强调的是，指出中国或日本的“家庭—人口”接口最为密集，并不意味着“个体—人口”型的西方生命权力在这里缺席。相反，尤其在本文所述的中日两国例子中，国家官僚体系日益频繁地绕过宗族结构，直接对个体进行规训，与欧洲相似。这类直接干预显示出中日两国在现代化改革过程中迈向个体化（moves towards individualization）的努力。虽然个体层面的治理措施仍与家国同构逻辑保持对话，但它们已经逐渐与宗族通道并行。这种改革进程正是维持西方式生命权力在东亚得以持续展开的关键所在。\n\n\n\n若要在当代社会中寻找家庭式生命权力（familial biopower）制度化的典范，中国于1980年全国推行的独生子女政策无疑是最具代表性的生命政治（biopolitics）实例之一。该政策深入介入最为私密的领域，是福柯所阐述的现代规训性权力（regulatory power）在微观层面控制再生产过程的具体体现：国家为每个家庭设定生育配额，随后通过户籍登记、罚款与服务拒绝等手段，在大规模层面调节生育行为。人口管理之所以精确至个体家庭，而非以其他政治形式为单位，并非偶然。这种机制依托于中华人民共和国自建国以来确立的全国性户籍制度（hukou system），该制度将每个人依法按照家庭单位进行分类。与西方社会普遍以个人为单位进行人口与居住登记不同，中国的户籍制度将每个个体与特定地区绑定——无论是就学、就医、迁徙管控还是福利获取，均需依托户籍。这种具地域性的制度结构充分体现了东亚“个体—家庭—人口”混合模式的核心理念：主体并非完全自主的个体，而是通过家庭关系而建构的相互关联的存在。在这一架构中，每一名新生儿的出生必须经过批准，方可获得出生和死亡登记、学校入学资格及各类公共服务的准入。这意味着，“家庭”这一概念通过户籍制度被制度化，成为国家可控的政治单元，呈现出一种在地化的家庭式生命权力版本：即“个体—户籍—人口”的生命政治机制。\n在这一家庭式权力网络中，国家的生命政治计算——诸如“每年允许多少出生？”——通过户籍这一家庭节点进行，而其纪律机器、监控机制与惩罚措施则直接落在个体身上，尤其是女性。如苏珊·格林哈利（Susan Greenhalgh）所指出：“家庭成为国家生命权力的前沿阵地，人口指标被直接书写在每一户的档案之中”（Greenhalgh, 22）。用福柯的术语来说，尽管户籍并非真正意义上的“全景敞视监狱”（Panopticon），但它却具备全景敞视功能：每户人家都明白，他们在持续被登记、检查及由基层计划生育官员监管的过程中处于可视状态。这种无形的凝视规范了夫妻的行为，使他们在预期的监控下内化独生子女政策。\n在东亚，现代生命权力从未孤立降临，而是从儒家家庭早已敞开的那扇门进入。生命政治与儒家图式相融合，其中“家庭秩序”即“政治秩序”，“家庭单元”即“政治单元”。这种家国同构（family-state isomorphism）揭示出远早于现代性门槛（threshold of modernity）之前就已存在的原始纪律性（proto-disciplinary）与原始生命政治实践（proto-biopolitical practices），指向了一条更为悠长、平稳的生命权力系谱路径。在这一“生物-家庭”（bio-familial）政体中，国家对生育率、疾病率和生产力的计算首先在宗族登记系统中流通，然后才传递至个体身体。从周代的保甲制度（baojia），到明治时期的户籍制度（koseki），再到清朝新政及当代中国的独生子女政策与三胎政策，家庭始终是国家“使其生、任其死”治理逻辑的核心工具。因此，福柯所描绘的生命权力门槛，并非一次断裂性的断层，而是权力聚焦生命所采取的规模与位置的转移。\n聚焦这种混合的家庭式生命权力，促使我们必须在儒家—家庭背景下重新措辞福柯的理论。若要理解今日的生命在东亚如何被治理，我们必须像福柯研究监狱、学校、精神病院和诊所那样去研究“家庭登记制度”；在东亚，这些机构被写在同一本簿册中。",
    "crumbs": [
      "Notes",
      "随笔",
      "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践"
    ]
  },
  {
    "objectID": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html#儒家家庭装置下的福柯生命权力系谱学再读",
    "href": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html#儒家家庭装置下的福柯生命权力系谱学再读",
    "title": "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践",
    "section": "",
    "text": "福柯在追溯西方权力如何渗透进身体内部并扩展到整个人口的著名分析中，指出18世纪出现了“一场多样且丰富的技术爆发，这些技术用于征服身体并控制人口”（Foucault 140）。这些权力技术并非边缘化，而是渗透进每一个社会制度中，包括家庭、军队、学校、个性化医疗以及集体机构管理。这些规训性操作（regulatory operations）以循环的方式运行，一定程度上构成了一种更宏大的“属于人类生命特有现象的介入”，从而彻底转变了西方人对自身的理解，即将自己视为“一个活在活的世界中的活物种……具有一个身体、生存条件、生命的可能性……”等。在福柯的理论框架中，一个社会之所以跨过现代性的门槛（threshold of modernity），是因为人类的生存本身成为政治计算的对象；也就是说，治理机构公开地将人口健康作为政策目标时，社会便成为了一个现代社会（Foucault 143）。\n然而，这一门槛在全球范围内呈现出明显的时间与形态差异。福柯对此保持了极大的谨慎，避免过度概括，因为作为一名历史学家，他清楚地意识到，他所描述的战胜饥荒和瘟疫、控制死亡的“胜利”历程并非普遍现象，而是特定于18和19世纪欧洲及其衍生地区的现象，这些地区的国家机构、医学科学和农业技术共同发展成熟。福柯理论在西欧轨迹上的特定应用，也因此留下了一个开放问题：例如在中国或日本存在哪些生命管理（life-management）形式，以及殖民力量又如何将它们的生命政治叠加到这些地方。因此，关键的问题并非生命权力是否具有普遍适用性，而是欧洲模式的生命权力如何整合进非西方社会，以及这种转型后的生命政治在多大程度上保留了其在欧洲的”断裂式特征”。\n回溯东亚历史，我们会发现，长期延续的儒家传统、家庭与宗族观念不仅在当今全球化的个人主义浪潮下幸存下来，而且形成了一种非常特殊的社会结构：一种儒家-家庭装置（Confucian-familial apparatus），它将国家治理与亲属义务紧密融合，并成为生命权力的通道。福柯的分析预设了一定程度的个体化（individualization）：公民、工人、病人……他们内化各种规范。福柯所谓“稍晚出现”的西方生命权力构型，是与古典欧洲政治理论（例如洛克或卢梭）预设的个体主义相融合的产物。福柯的分析反映了这种遗产：在大规模治理层面上，集体规训围绕着解剖政治（anatomo-politics）与生命政治（biopolitics）交汇的轴线形成，整体的人口与个体之间成为基本的分析单位。福柯着重分析诸如监狱、学校、精神病院等机构，因为它们生动地展现了现代权力的运作机制，但相较之下，他较少关注家庭作为现代权力中心的角色或直接作为国家生命政治装置（state biopolitics apparatus）的功能。他更多地将家庭视为“性最活跃的场所”（Foucault, 109），在他的论述中，家庭功能似乎只是资产阶级性欲部署的一个载体（可能是最重要的载体），但并未将家庭充分地视为一种国家权力的制度化机构来完整阐释。\n儒家哲学中，家庭是社会基本的构成单元，更被视作美德的训练场所。尽管福柯提出的分类框架大体上有效，但如果通过系谱学（genealogical）方式重新解读东亚的孝道和宗族体系，我们会发现家庭远非仅仅是性欲与纪律规范的载体，而是具有更加核心的功能性地位——同时也更加显著地政治化了。重新审视福柯在家庭作为国家机器（family-as-state-machine）方面的相对沉默是必要的，而这种必要性，直接可以从广泛流传的中文谚语“家是小国，国是大家”逐字逐句地体现出来。\n这种家国同构（family-state isomorphism）源自早期儒家经典文本，其中尤以《礼记·大学》中“修身齐家治国平天下”的论述最为著名，这一经典最早可追溯到公元前206年，并提出了一套有关自我修养的等级体系。这种观点并非仅限于道德劝诫，而是早自周代以来便已制度化。正如一位历史学家所指出，清代法律明确实施了“父母对子女所享有的关系权力（relational power），这一关系随后被类比为官员以及皇帝对平民的权威”（Blackwood）。换言之，国家利用家庭结构，尤其是父权制家庭（patriarchal family）的结构，来强化其自身结构。家庭-国家之间的连续性在东亚历史中一直显而易见：皇帝名义上被视为国家的“父亲”，个人对自己父亲的孝道服从被期待转化为对国家的忠诚。这种原始的纪律性与政治化的家庭共识普遍汇聚在东亚地区，长期以来便模糊了私人家庭生活与公共治理之间的界限，并远早于所谓的现代性门槛。在这种背景下，君主与臣民的关系直接映射了父与子的关系（即“君君臣臣父父子子”）。因此家庭户主负责登记出生与死亡，监督礼仪，发放慈善，以及裁决争端，其职能恰如地方县级官员（magistrate）。由此可见，家庭处于孤立的个体与国家机器之间，成为纪律规训与生命政治管理的基本单位。每个家庭同时既是国家的微观缩影，又是治理的单元，这一观念正是提示了另一种不同的生命政治治理需求——即通过亲属关系（kinship）来实现。\n因此，在讨论东亚生命权力兴起的问题时，我们必须系统地将家庭理论化为一种关键的配置（dispositif），将解剖政治（anatomo-politics）与生命政治（biopolitics）联结起来。这一特定的权力网络要求我们在现代语境下提出 “家庭式生命权力”（familial biopower） 的概念，其中生命政治技术首先由国家辐射到家庭单位，然后才进一步下沉至个体。在这种 “个体-家庭-人口”（individual-family-population） 的三元结构中，亲属义务与宗族礼仪调节着所有现代治理措施，包括出生登记到公共卫生宣传运动，使得家庭本身成为一种生命权力的微型官僚机制。因此，在东亚，家庭远非私人庇护所，而是国家权力对生命的延伸场域，其“私人”与“公共”领域之间的界限几乎已无法区分，这正是福柯理论框架所会预测的融合形式。",
    "crumbs": [
      "Notes",
      "随笔",
      "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践"
    ]
  },
  {
    "objectID": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html#现代性门槛的连续性continuity",
    "href": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html#现代性门槛的连续性continuity",
    "title": "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践",
    "section": "",
    "text": "福柯试图揭示的决定性转型，实质上是权力在逻辑与目标上双重变化的过程；然而，这种向“使其生、任其死”（making live and letting die）方向的转变，本身更多是一种强调重点与治理尺度的问题。“门槛”的连续性，并不在于权力是否瞄准生命，而在于它如何、以及在何处对生命施加控制。因此，强调东亚以家庭为核心的行政模式，并非意在夸大其独特性，以及是否存在家庭制度——因为西欧早期现代的生命政治措施，同样也扎根于原有的家庭和社区结构之中（如法国 livrets de famille、瑞典教区登记）——而是在于国家与个体之间是否发生了中介结构的剥离与重构。\n在东亚，公共与私人领域从未像欧洲那样被严格区分，因此外来生命权力对两者界限的模糊，并未对现有的家国同构（family–state isomorphism）造成根本性冲击。或者，更精准的说，“生命权力”在东亚是更容易嵌入原有秩序结构中，因此无需强行重构私域公化的渗透机制。在欧洲，随着统计学、现代警察制度和卫生法律的兴起，一套密集的微观治理网络逐步渗透进私人领域——在福柯看来，“权力无处不在”（there is no outside to power）。这一现象在东亚也有发生，但东亚的儒家-家庭格局本身就具有强调角色本位的“修身”的系谱根基，这是国家支持的项目。在这种语境下，个体若试图划出一个脱离社会角色的“私人内部”，是不被鼓励的。因为自由主义意义上的“自主人格”——即“选择你是谁”——并非理想状态；相反，社会强调的是与政治秩序和宇宙秩序之间的“和谐”。\n这些前现代中国的规范性叙事，使我们得以理解，“欧洲式”生命权力的导入在东亚看起来远不如福柯所描述的法国或英国那样构成一个清晰的“前后转折”。这一进程更像是将新的统计—医学技术嫁接（grafting）到既有的家庭治理结构之上，是一种有意识的增强（augmentation），而非强行替代。例如，西方式生命权力在中国的引入可以追溯到1901年，当时在外来影响下，清朝新政（New Policies）于北京设立中央卫生机构，统一监管全国各省的“健康、检疫与医疗实践”。这是中国历史上首次将人口健康作为独立的政策目标加以系统性测量、汇报与管理，标志着“西式卫生现代化的开端”（Cao 105）。在此生命权力改革的“门槛”上，国家政策是通过保甲制度（baojia）这一延续了数百年的社区治理网络来实施的。接着，这一框架又在1911年《户籍法》中正式确立了现代户口制度（hukou）的法律形态，其遗产一直延续至今。事实上，自周朝以来，中国各朝代已经实施多种形式的原始户籍制度，以管理“生命”，其连续性和稳定性远超欧洲——后者并未持续建立由国家运行的户籍制度。因此，清朝“新”卫生机构所采用的，并非是建立一个完全独立的国家机器，而是将新兴的统计—医疗技术叠加于已有的宗族与村社网络之中。家庭在治理结构中仍然作为核心节点，这种连续性揭示了一条不同的生命管理系谱，即以家庭为中心的更长远、持久的生命政治路径。\n同样，日本政府在1871年推行了“户籍”制度（koseki），有意识地将儒家家庭主义融入明治时期的家国意识形态中。该政策与中国的户口制度类似，要求“每户必须报告出生、死亡、婚姻与收养情况”（《户籍法》）。当明治维新时期引入西方公共卫生政策——尤其是1872年《传染病预防法》——时，所有疫苗接种、隔离命令与卫生检查均通过地方家庭登记与村庄首领来执行。在其核心， 是“家”（ie）的概念：一个用于法律、经济与精神目的的扩展家庭单位。这不仅仅是一个隐喻，还被1898年《明治民法典》正式确认为社会的基本单位。在这一制度中，女性被明确规定在“良妻贤母”的口号下承担支持性、再生产角色；而家长则被动员为国家行使婚姻、继承与家庭纪律等方面的生命权力代理人。日本著名女性主义者上野千鹤子（Chizuko Ueno）深受福柯权力理论的启发，她指出：“’家’制度被设计成符合现代民族国家的模型，而民族国家本身正是仿照家庭结构构建的”（Ueno 57）。在这种家国同构观念中，明治国家与中国清末类似，也将西方生命政治技术嫁接到既有的家庭格局上，使每一个家庭（ie）成为治理与人口管理的基本单元。\n值得强调的是，指出中国或日本的“家庭—人口”接口最为密集，并不意味着“个体—人口”型的西方生命权力在这里缺席。相反，尤其在本文所述的中日两国例子中，国家官僚体系日益频繁地绕过宗族结构，直接对个体进行规训，与欧洲相似。这类直接干预显示出中日两国在现代化改革过程中迈向个体化（moves towards individualization）的努力。虽然个体层面的治理措施仍与家国同构逻辑保持对话，但它们已经逐渐与宗族通道并行。这种改革进程正是维持西方式生命权力在东亚得以持续展开的关键所在。",
    "crumbs": [
      "Notes",
      "随笔",
      "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践"
    ]
  },
  {
    "objectID": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html#独生子女政策家庭式生命权力的现代行政范式",
    "href": "content/posts/随笔/家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践.html#独生子女政策家庭式生命权力的现代行政范式",
    "title": "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践",
    "section": "",
    "text": "若要在当代社会中寻找家庭式生命权力（familial biopower）制度化的典范，中国于1980年全国推行的独生子女政策无疑是最具代表性的生命政治（biopolitics）实例之一。该政策深入介入最为私密的领域，是福柯所阐述的现代规训性权力（regulatory power）在微观层面控制再生产过程的具体体现：国家为每个家庭设定生育配额，随后通过户籍登记、罚款与服务拒绝等手段，在大规模层面调节生育行为。人口管理之所以精确至个体家庭，而非以其他政治形式为单位，并非偶然。这种机制依托于中华人民共和国自建国以来确立的全国性户籍制度（hukou system），该制度将每个人依法按照家庭单位进行分类。与西方社会普遍以个人为单位进行人口与居住登记不同，中国的户籍制度将每个个体与特定地区绑定——无论是就学、就医、迁徙管控还是福利获取，均需依托户籍。这种具地域性的制度结构充分体现了东亚“个体—家庭—人口”混合模式的核心理念：主体并非完全自主的个体，而是通过家庭关系而建构的相互关联的存在。在这一架构中，每一名新生儿的出生必须经过批准，方可获得出生和死亡登记、学校入学资格及各类公共服务的准入。这意味着，“家庭”这一概念通过户籍制度被制度化，成为国家可控的政治单元，呈现出一种在地化的家庭式生命权力版本：即“个体—户籍—人口”的生命政治机制。\n在这一家庭式权力网络中，国家的生命政治计算——诸如“每年允许多少出生？”——通过户籍这一家庭节点进行，而其纪律机器、监控机制与惩罚措施则直接落在个体身上，尤其是女性。如苏珊·格林哈利（Susan Greenhalgh）所指出：“家庭成为国家生命权力的前沿阵地，人口指标被直接书写在每一户的档案之中”（Greenhalgh, 22）。用福柯的术语来说，尽管户籍并非真正意义上的“全景敞视监狱”（Panopticon），但它却具备全景敞视功能：每户人家都明白，他们在持续被登记、检查及由基层计划生育官员监管的过程中处于可视状态。这种无形的凝视规范了夫妻的行为，使他们在预期的监控下内化独生子女政策。\n在东亚，现代生命权力从未孤立降临，而是从儒家家庭早已敞开的那扇门进入。生命政治与儒家图式相融合，其中“家庭秩序”即“政治秩序”，“家庭单元”即“政治单元”。这种家国同构（family-state isomorphism）揭示出远早于现代性门槛（threshold of modernity）之前就已存在的原始纪律性（proto-disciplinary）与原始生命政治实践（proto-biopolitical practices），指向了一条更为悠长、平稳的生命权力系谱路径。在这一“生物-家庭”（bio-familial）政体中，国家对生育率、疾病率和生产力的计算首先在宗族登记系统中流通，然后才传递至个体身体。从周代的保甲制度（baojia），到明治时期的户籍制度（koseki），再到清朝新政及当代中国的独生子女政策与三胎政策，家庭始终是国家“使其生、任其死”治理逻辑的核心工具。因此，福柯所描绘的生命权力门槛，并非一次断裂性的断层，而是权力聚焦生命所采取的规模与位置的转移。\n聚焦这种混合的家庭式生命权力，促使我们必须在儒家—家庭背景下重新措辞福柯的理论。若要理解今日的生命在东亚如何被治理，我们必须像福柯研究监狱、学校、精神病院和诊所那样去研究“家庭登记制度”；在东亚，这些机构被写在同一本簿册中。",
    "crumbs": [
      "Notes",
      "随笔",
      "家庭式生命权力：通过儒家的家国体系重读福柯的生命政治理论在东亚的实践"
    ]
  }
]