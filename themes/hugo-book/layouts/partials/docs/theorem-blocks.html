<!-- Theorem Blocks -->
<script>
  // Idempotent processor so it can be called on initial load and after partial loads
  window.processTheoremBlocks = function() {
    document.querySelectorAll('blockquote').forEach(function(blockquote) {
      // Get the first paragraph
      const firstParagraph = blockquote.querySelector('p');
      if (!firstParagraph) return;
      
      // Use the raw original HTML before MathJax transforms
      const originalHTML = firstParagraph.getAttribute('data-raw') || firstParagraph.innerHTML;
      const text = originalHTML.replace(/<[^>]*>/g, '').trim();
      
      // More flexible pattern matching for theorem types with optional numbering
      // Match patterns like [!theorem|*] or [!theorem|7.1.1]
      // Support Obsidian-style: definition, proposition, lemma, theorem, assumption, claim
      for (const type of ['definition', 'proposition', 'lemma', 'theorem', 'assumption', 'claim']) {
        // Extract: marker + optional title on the same quoted line (ends at real line break) 
        // We only want the remainder of that quoted line as the subtitle
        const markerRe = new RegExp(`^\\s*\\[!${type}\\|(\\*|[\\w\\.\\-]+)\\]\\s*`, 'i');
        const match = text.match(markerRe);
        
        if (match) {
          console.log(`Found ${type} with label: ${match[1]}`);
          
          // Determine if we have a number or just a wildcard
          const hasNumber = match[1] !== '*';
          const number = hasNumber ? match[1] : '';
          // Extract subtitle from the first visual line
          // Extract subtitle more carefully: everything after the marker on the SAME LINE only
          // Remove HTML tags first to work with plain text
          const plainText = originalHTML.replace(/<[^>]*>/g, '');
          const lines = plainText.split(/\n/);
          const firstLine = lines[0] || '';
          const headerPlain = firstLine;
          const subtitle = headerPlain.replace(markerRe, '').trim();
          
          // Skip if already processed
          if (blockquote.classList.contains('math-theorem')) {
            break;
          }

          // Remove all children temporarily
          const childNodes = Array.from(blockquote.childNodes);
          blockquote.innerHTML = '';
          
          // Add class to blockquote
          blockquote.classList.add('math-theorem', type);
          
          // Create and add the header
          const header = document.createElement('div');
          header.className = 'theorem-header';
          
          // Build header content
          const typeText = type.charAt(0).toUpperCase() + type.slice(1);
          const left = document.createElement('span');
          left.textContent = hasNumber ? `${typeText} ${number}` : typeText;
          header.appendChild(left);
          if (subtitle) {
            const right = document.createElement('span');
            right.className = 'theorem-subtitle';
            right.textContent = ` (${subtitle})`;
            header.appendChild(right);
          }
          
          blockquote.appendChild(header);
          
          // Create content container
          const content = document.createElement('div');
          content.className = 'theorem-content';
          blockquote.appendChild(content);
          
          // Add all children back to the content div, but remove marker (and header line) from the first paragraph
          childNodes.forEach(function(node) {
            let toAppend = node.cloneNode(true);
             if (node === firstParagraph && toAppend.nodeType === 1) {
               // Replace the first paragraph content with everything AFTER the first newline only
               const plainText = originalHTML.replace(/<[^>]*>/g, '');
               const lines = plainText.split(/\n/);
               if (lines.length > 1) {
                 // Keep only lines after the first (header) line
                 const bodyLines = lines.slice(1);
                 const bodyText = bodyLines.join('\n').trim();
                 if (bodyText) {
                   toAppend.innerHTML = '';
                   toAppend.appendChild(document.createTextNode(bodyText));
                 } else {
                   // No body content after header, remove this paragraph entirely
                   return; // skip appending this node
                 }
               } else {
                 // Single line: just remove the marker and keep the rest
                 const cleaned = headerPlain.replace(markerRe, '').trim();
                 if (cleaned) {
                   toAppend.innerHTML = '';
                   toAppend.appendChild(document.createTextNode(cleaned));
                 } else {
                   return; // skip empty paragraph
                 }
               }
             }
            content.appendChild(toAppend);
          });
          
          break; // Stop after finding the first match
        }
      }
    });
  };

  document.addEventListener('DOMContentLoaded', function() {
    try { window.processTheoremBlocks(); } catch (e) { console.error(e); }
  });
</script> 